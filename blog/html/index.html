<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width">
        <title>Home &mdash; Leandro Pereira</title>
            <link rel="stylesheet" href="_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="_static/main.css" type="text/css">
            <link rel="stylesheet" href="_static/flat.css" type="text/css">
            <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="_static/plugins.js"></script>
        <script src="_static/main.js"></script>
        <link rel="search" title="Search" href="search.html" /><link rel="next" title="Older" href="page2.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="_static/underscore.js"></script><script type="text/javascript" src="_static/doctools.js"></script>
<style type="text/css">img {max-width: 100%;}</style>
</head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><header role="banner">
            <hgroup>
              <h1><a href="#">Leandro Pereira</a></h1><h2>Geek in training</h2></hgroup>
          </header>
      <nav role="navigation">
            <ul><li class="main-nav">
                  <a href="#">Home</a>
                </li>
              <li class="main-nav">
                  <a href="pages/about.html">About</a>
                </li>
              </ul>
          </nav><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>June 28, 2018</span>
        </div>
        <div class="section">
            <h1><a href="2018/06/28/include_next_and_portability.html">include_next and portability</a></h1>
<p>One of the decisions I took early on while writing Lwan was to only support
Linux, and think about portability later; this decision was influenced by the
way the <a class="reference external" href="https://www.openbsd.org/papers/portability.pdf">OpenBSD project approaches portability</a>.</p>
<p>In retrospect, this was a good decision: this avoided many of the pitfalls
associated in <a class="reference external" href="http://wiki.c2.com/?PrematureAbstraction">writing abstractions too early in the game</a>.  It also made the code cleaner:
the abundance of C preprocessor usage, common in some portable code, hinders
legibility and maintainability.  Of course, this decision made it
challenging to port it to other operating systems.</p>
<p>I was content with this decision – until people began asking for BSD and Mac
ports.  With the exception of some system calls (e.g.  epoll, or the Linux
<a class="reference external" href="http://man7.org/linux/man-pages/man2/sendfile.2.html">sendfile</a> variant), porting shouldn’t be surprising.  Ideally, having the code
largely <span class="docutils literal"><span class="pre">#ifdef</span></span> free would be ideal, so I had to find a way to make this happen.</p>
<p>While reading the GCC manual, I found out about an extension – that also
happens to be <a class="reference external" href="https://clang.llvm.org/docs/LanguageExtensions.html">implemented by Clang</a> – that fit perfectly
this scenario: <a class="reference external" href="https://gcc.gnu.org/onlinedocs/cpp/Wrapper-Headers.html">wrapper headers</a>.  It’s a C
preprocessor extension that includes the next file in the include lookup
path.  With this extension, it’s possible to write our own substitute header
files, named after standard header files:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span><span class="cpf">_next &lt;stdlib.h&gt; /* Include stdlib.h from system includes */</span><span class="cp"/>

<span class="cp">#ifndef MISSING_STDLIB_H_</span>
<span class="cp">#define MISSING_STDLIB_H_</span>

<span class="cp">#if !defined(HAVE_MKOSTEMP)</span>
<span class="kt">int</span> <span class="nf">mkostemp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(HAVE_REALLOCARRAY)</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">reallocarray</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">optr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* MISSING_STDLIB_H_ */</span><span class="cp"/>
</pre></div>
</div>
<p>Have it in a directory named, say, “missing”, and modify the header lookup path
so it is looked up first by the compiler.  This is easily accomplished in CMake
by specifying an include directory with the <span class="docutils literal"><span class="pre">BEFORE</span></span> option:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">include_directories</span><span class="p">(</span><span class="n">BEFORE</span> <span class="n">src</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">missing</span><span class="p">)</span>
</pre></div>
</div>
<p>(This just ensures that <span class="docutils literal"><span class="pre">src/lib/missing</span></span> will be passed before any other <span class="docutils literal"><span class="pre">-I</span></span>
argument to the compiler, regardless of the order any other
<span class="docutils literal"><span class="pre">include_directories()</span></span> macro is invoked.  Your build system might differ, this
is copied straight from Lwan’s.)</p>
<img alt="missing directory tree" class="align-right" src="https://i.imgur.com/c3ntvJL.png"/>
<p>Then it’s just the matter of implementing these functions in terms of other
functions available in the system, and code using it will be none the wise: a
<span class="docutils literal"><span class="pre">#include</span> <span class="pre">&lt;stdlib.h&gt;</span></span> line will include our wrapper header, which in turn will
include the system’s <span class="docutils literal"><span class="pre">stdlib.h</span></span> header; it then might define, in this example,
additional prototypes, based on what the build system could determine during the
configuration phase.</p>
<p>This way, most <span class="docutils literal"><span class="pre">#ifdefs</span></span> are hidden away in a single file, making it a lot easier
to maintain and read the code.  No application-specific abstraction layer with
quirky semantics; just the familiar quirkiness from POSIX.</p>
<p>One of the things I’m particular proud of is the miniature <a class="reference external" href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a> implementation on top
of <a class="reference external" href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2">kqueue</a>
(available in BSD systems).  I considered moving Lwan to use an abstraction
library (such as <a class="reference external" href="http://libevent.org/">libevent</a> or <a class="reference external" href="https://libuv.org/">libuv</a>) just for this, but was able to keep using its
event-handling loop as is.  Not only I understand 100% of it, it was a
worthwhile learning experience.  With ~120 lines of C code, this epoll
implementation is easier to wrap my head around than the thousands of lines
of code from those libraries.</p>

        </div>
        <div class="postmeta">
        
        
        
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>February 01, 2018</span>
        </div>
        <div class="section">
            <h1><a href="2018/02/01/more_on_string_switch_in_c.html">More on string switch in C</a></h1>
<p>Talking about uncommon programming tricks the other day, the subject of
switching on strings in C appeared on the table.</p>
<p>If you follow this blog, you know it’s something <a class="reference external" href="/posts/2012/08/09/string_switch_in_c.html">actually possible to do
with a little bit of ingenuity</a>; in fact, it’s one of the
things that I use in Lwan to parse the HTTP requests.  I didn’t spend too
much time in that blog post to explain why it is faster, so I’m rectifying
this now.</p>
<p>In order to understand why it’s so fast, let me step aside for a moment and
show a function every C programmer should be able to write: <span class="docutils literal"><span class="pre">strlen()</span></span>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span><span class="o">++</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Style issues aside, this is pretty much the simplest way to implement this
function.  And, maybe the one that generates the slowest code.  There are
many reasons here, so let’s explore some of them.</p>
<p>One of them is that CPUs are able to fetch more than a single byte at a time
from memory (or cache).  And it takes roughly the same time for it to fetch
8 bits than it takes to fetch 32 bits.  People that write C libraries know
about this fact, so that the version that your operating system provides is
most likely going to exploit this.  Let’s rewrite the <span class="docutils literal"><span class="pre">strlen()</span></span> function,
then:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>

        <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a big issue in this code: it is invoking undefined behavior.  The
explanation of why this is illegal in C will follow, but for now, let’s just
assume that the integer cast from a character pointer is valid.</p>
<p>With that assumption in mind, what this program is doing is in fact very
simple: it is reducing the amount of expensive operations (fetching things
from memory), and is increasing the amount of cheap operations (masking bits
and comparing integers).  In fact, that’s a recurring theme whenever you’re
trying to optimize any algorithm: the computer can’t run a piece of code faster,
but you can make the computer run smarter code that produces the same output.</p>
<p>This program, however, will most likely crash on some platforms, or be
really slow on others.  The reason is that it is trying to read a pointer
that is not aligned.  Some CPU designers decided to increase the complexity
and perform more work behind the scenes to make this work, and some decided
it wasn’t worth the trouble and will just generate an exception.  The major
problem, however, is that this is precisely the undefined behavior I was talking
about.  So, let’s fix this function, by modifying it slightly so that the fast
path operates on aligned pointers:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_ptr_aligned</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uintptr_t</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

    <span class="cm">/* Assuming a 32-bit machine with 4-byte alignment for</span>
<span class="cm">     * integers.  Executing "AND (n - 1)" is equivalent to "MOD</span>
<span class="cm">     * (n)", without an expensive division operation; this is</span>
<span class="cm">     * true for every (n), as long as (n) is a power of 2.</span>
<span class="cm">     * Compilers can do this optimization on constant values,</span>
<span class="cm">     * but I prefer to be explicit. */</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Read one byte at a time until the pointer is aligned. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_ptr_aligned</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
        <span class="n">len</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Pointer is aligned, try the faster version now. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>

        <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is still an even faster way, that is to improve the way the NUL byte
is found in a word.  The excellent (and one of my favorite websites) “<a class="reference external" href="https://graphics.stanford.edu/~seander/bithacks.html#ZeroInWord">Bit
Twiddling Hacks</a>” web
page has a method to find out if a word contains a NUL byte; it doesn’t tell
which byte is the NUL byte, but we don’t need to know that in the fast path:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">v</span><span class="p">;</span>

    <span class="cm">/* Read one byte at a time until the pointer is aligned. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_ptr_aligned</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
        <span class="n">len</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Pointer is aligned, try the faster version now. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>

        <span class="cm">/* Use a fast bit twiddling hack to find if the</span>
<span class="cm">         * next 4 bytes in the string has a 0 byte. If</span>
<span class="cm">         * it does, find out which byte it is. */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">-</span> <span class="mh">0x01010101</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0x80808080</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Another thing to consider in these functions is that they’re not endian
neutral.  A decent implementation would ensure that it would work both on
little-endian and on big-endian machines.  A decent programmer would even
build and test these; I didn’t.</p>
<p>Yet another thing to consider is that hand-tuned assembly versions, most
likely written to make use of vector instructions, are the ones that your
computer are executing at this very instant; but they all draw from these
very same ideas: read memory less often, compare in bulk.</p>
<p>Also, there are most likely better ways to write these functions, even without
vector instructions.  But this is besides the point of explaining why the
string switch trick works so well.</p>
<p>Now, this kind of optimization happens on pratically all string handling functions
in the C standard library.  And functions that perform substring comparison,
such as <span class="docutils literal"><span class="pre">strncmp()</span></span>, are no exception.</p>
<p>When faced with the necessity to check for a bunch of strings, the idiomatic
C way of doing so would be the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"GET "</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_GET</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"POST "</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_POST</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"DELETE "</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_DELETE</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"HEAD "</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_HEAD</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="k">return</span> <span class="n">HTTP_METHOD_UNKNOWN</span><span class="p">;</span>
</pre></div>
</div>
<p>It’s not difficult to imagine that each invocation of <span class="docutils literal"><span class="pre">strncmp()</span></span> would have to
do things that are similar to what our toy <span class="docutils literal"><span class="pre">strlen()</span></span> implementation had to do:
align the pointer (which is slow) before it could start the fast path.  But, in
this case, things are even worse, because, if the pointer isn’t aligned, it
might not even get to the point where the fast path will make sense, because the
strings it is comparing against are very close to the alignment of the word
size for this computer!</p>
<p>So, to recap, what the string switch does is the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">string_to_uint32</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">v</span><span class="p">;</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define STRING_SWITCH(s) switch (string_to_uint32(s))</span>
<span class="cp">#define MCC(a, b, c, d) ((a) &lt;&lt; 24 | (b) &lt;&lt; 16 | (c) &lt;&lt; 8 | (d))</span>
<span class="k">enum</span> <span class="p">{</span>
    <span class="n">METHOD_GET</span> <span class="o">=</span> <span class="n">MCC</span><span class="p">(</span><span class="sc">'G'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="sc">'T'</span><span class="p">,</span> <span class="sc">' '</span><span class="p">),</span>
    <span class="n">METHOD_POST</span> <span class="o">=</span> <span class="n">MCC</span><span class="p">(</span><span class="sc">'P'</span><span class="p">,</span> <span class="sc">'O'</span><span class="p">,</span> <span class="sc">'S'</span><span class="p">,</span> <span class="sc">'T'</span><span class="p">),</span>
    <span class="n">METHOD_DELETE</span> <span class="o">=</span> <span class="n">MCC</span><span class="p">(</span><span class="sc">'D'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="sc">'L'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">),</span>
    <span class="n">METHOD_HEAD</span> <span class="o">=</span> <span class="n">MCC</span><span class="p">(</span><span class="sc">'H'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">,</span> <span class="sc">'D'</span><span class="p">),</span>
    <span class="cm">/* ... */</span>
<span class="p">};</span>

<span class="n">STRING_SWITCH</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="nl">METHOD_GET</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_GET</span><span class="p">;</span>
<span class="k">case</span> <span class="nl">METHOD_POST</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_POST</span><span class="p">;</span>
<span class="k">case</span> <span class="nl">METHOD_DELETE</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_DELETE</span><span class="p">;</span>
<span class="k">case</span> <span class="nl">METHOD_HEAD</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_HEAD</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="k">default</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_UNKNOWN</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The good thing about the switch statement in C is that it is maybe the
highest level statement in the language: the compiler can get really
creative in how its code is generated.  It’s not uncommon for it to generate
jump tables or even binary searches.  So this implementation would actually
be faster than the various calls to <span class="docutils literal"><span class="pre">strncmp()</span></span> because:</p>
<ol class="arabic simple">
<li>Comparing integers is dirt cheap.</li>
<li>The compiler knows what <span class="docutils literal"><span class="pre">memcpy()</span></span> does, so it’s very likely that on
architectures where unaligned memory access is fine and there’s no
performance penalty (any Intel Core CPU after Sandy Bridge for instance),
it’ll be just a regular old MOV instruction when the size is small
and known at compile time.</li>
<li>Even if the compiler didn’t know what <span class="docutils literal"><span class="pre">memcpy()</span></span> does, it would only
fill a register once, by doing potentially expensive byte-by-byte copies
because of unaligned pointer access, and then proceed to just compare
integers.</li>
<li>There is less function call overhead; specially nice since this is
most likely not going through the PLT.</li>
<li>The compiler can reorder the comparisons as it see fit, often producing
very tight code.</li>
</ol>
<p>These kinds of micro-optimizations don’t necessarily have to be completely
unreadable and full of magical constants.</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        
        <div class="tags">
            <span>
                Tags:
                <a href="tags/lwan.html">lwan</a>, <a href="tags/programming.html">programming</a>, <a href="tags/trick.html">trick</a>, <a href="tags/c.html">C</a></span>
        </div>
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>May 08, 2017</span>
        </div>
        <div class="section">
            <h1><a href="2017/05/08/coreboot_luks.html">Coreboot &amp; LUKS</a></h1>
<p>My laptop is a 6-year old <a class="reference external" href="http://www.thinkwiki.org/wiki/Category:X220">ThinkPad X220</a>.  Although it’s almost
falling apart from years of constant abuse, I don’t see myself replacing it
anytime soon: it’s easy to repair, has a great keyboard, and is a very
dependable machine.</p>
<p>And it’s supported by <a class="reference external" href="https://en.wikipedia.org/wiki/Coreboot">Coreboot</a>.
Substituting the proprietary firmware with it is very trivial: I followed
the instructions on <a class="reference external" href="https://tylercipriani.com/blog/2016/11/13/coreboot-on-the-thinkpad-x220-with-a-raspberry-pi/">this blog post</a>
and they worked out of the box.  (I also went the extra mile and flashed the
firmware after passing it through <a class="reference external" href="https://github.com/corna/me_cleaner">me_cleaner</a>.)</p>
<div class="figure align-center" id="id1">
<img alt="flashing X220 bios" src="https://i.imgur.com/97rTiZH.jpg"/>
<p class="caption"><span class="caption-text">Flashing the serial flash using a Raspberry Pi 3. Yes, I need to clean
up this computer.</span></p>
</div>
<p>The major difference from my previous setup is that my SSD had
<a class="reference external" href="https://en.wikipedia.org/wiki/Hardware-based_full_disk_encryption">hardware-based full disk encryption</a>.  I
ended up disabling this for two reasons: first, this isn’t very secure (the
key will remain in the disk RAM for as long as power is supplied); second, I
was not sure if Coreboot supported this.  So I disabled encryption prior to
flashing the new firmware.</p>
<p>But keeping a hard drive unencrypted on a laptop isn’t good practice.  I
decided to use <a class="reference external" href="https://en.wikipedia.org/wiki/Linux_Unified_Key_Setup">LUKS</a>
instead.</p>
<p>However, instead of using <a class="reference external" href="https://en.wikipedia.org/wiki/SeaBIOS">SeaBIOS</a>
as the payload and have a standard bootloader, I opted to go through a
slightly different route: have a custom-built Linux inside the ROM, open the
<span class="docutils literal"><span class="pre">/boot</span></span> partition with LUKS, and
<a class="reference external" href="http://man7.org/linux/man-pages/man2/kexec_load.2.html">kexec</a> the current
vmlinuz/initrd.</p>
<p>Compared to the usual setup of using SeaBIOS as a payload, this setup
reduces boot time by cutting the middlemen.  With the ability to boot from
external devices removed, it’s also arguably more secure.  The in-ROM Linux
has only the bare minimum: no network subsystem, only necessary filesystems,
bare minimum drivers are built-in, USB is limited to HID devices, etc; the
compressed kernel has ~1.7MiB with room to shrink.  The in-ROM initrd is
also quite minimal, containing just one file.</p>
<p>The only file is a <a class="reference external" href="https://gist.github.com/lpereira/845fe060ba68a5db95827cbc5496bb6d">hacked version</a> of
cryptsetup that acts as a primitive init, creating <span class="docutils literal"><span class="pre">/proc</span></span>, <span class="docutils literal"><span class="pre">/dev</span></span> (and mounting
these two), and <span class="docutils literal"><span class="pre">/boot</span></span>, decrypting <span class="docutils literal"><span class="pre">/boot</span></span>, and performing kexec.  It’s
statically linked with <a class="reference external" href="https://www.musl-libc.org/">musl libc</a>.</p>
<p>Flashing this requires opening the laptop, and I’m planning to do this next
weekend when replacing the USB ports.  However, the setup works very well
under <a class="reference external" href="http://www.qemu.org/">QEMU</a>.</p>
<p>This blog post isn’t meant as a tutorial – feel free to contact me if you
have questions or ideas on how to improve this.  If you end up using
something similar to this idea, I’d love to know as well.</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        <div class="categories">
            <span>
                Filed under:
                <a href="categories/linux.html">linux</a>, <a href="categories/x220.html">x220</a>, <a href="categories/hack.html">hack</a></span>
        </div>
        
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>March 01, 2017</span>
        </div>
        <div class="section">
            <h1><a href="2017/03/01/parsing_json.html">Parsing JSON</a></h1>
<p>There are many libraries out there to parse JSON files.  It might be a
futile attempt, then, to write yet another one.  However, when you’re
working on a RTOS where memory is golden, and the alternatives don’t look
that great, you got to do something about it.</p>
<p>Recently I wrote a <a class="reference external" href="http://www.json.org">JSON</a> parser for a project at
work.  This parser uses constant memory, regardless of the amount of data
it’s working with, and deserializes directly to a C struct.  Similar, in
spirit, to the JSON parser that’s part of the Golang standard library, that
encodes and decodes data based on a tagged structure.</p>
<p>The lexer is the usual state machine, where the state itself is a function
pointer to a function that handles that particular state.</p>
<p>I’ve been using this technique for a while, and I found that it’s a very
clean and efficient way of describing state machines, specially for lexers.</p>
<p>I began using it after a coworker wrote a <a class="reference external" href="https://github.com/solettaproject/soletta/blob/3bda9802b243c2052555cf88263f754d34458414/src/shared/sol-fbp-internal-scanner.c">parser for a DSL</a>
using it – and he got the idea from the – you guessed – Golang template
package.  (There’s a <a class="reference external" href="https://www.youtube.com/watch?v=HxaD_trXwRE">nice talk by Rob Pike about it</a> – I recommend this talk
not only for the lexing goodness, but also for the tips on how to evolve a
concurrent design.)</p>
<p>The parser implementation itself is nothing to write home about.  However,
by using the same idea used in Lwan’s mustache template engine to <a class="reference external" href="https://tia.mat.br/posts/2012/11/11/mustache_templates_in_c.html">obtain
the variables</a>, it
manages to do some things that are not common in JSON parsers written in C:</p>
<ul class="simple">
<li>It will accept only values of known types for a particular key.</li>
<li>It will save the decoded value directly in a struct field.</li>
<li>It won’t try to decode the same field twice.</li>
</ul>
<p>The first point is crucial when working with data received from the network,
which is precisely the kind of thing I’m dealing with.  This avoids problems
such as type confusion and such, and moves the responsibility of checking
the types to the library rather than the user of the library.</p>
<p>By saving the decoded value directly into a struct field, it does use a
predictable amount of memory.  This is good, as it’s not going to balloon
out of control, or require some guesswork to know beforehand how many tokens
are going to be necessary to deserialize some values.  The C compiler
already knows exactly how many bytes a struct needs.</p>
<p>Some fields might be optional in a JSON blob.  So the parser uses a bitmask
to mark which fields have been decoded (and returns that, so that the
library user can efficiently test if a value has been deserialized or not).
Since it was easy to do, the library refuses to decode a key that has been
deserialized before.</p>
<p>So, a typical use is the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cm">/* First, define a struct to hold the values. */</span>
<span class="k">struct</span> <span class="n">values</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">some_string</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">some_int</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">some_bool</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Then, define a descriptor for that struct. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">json_descr</span> <span class="n">values_descr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">FIELD</span><span class="p">(</span><span class="k">struct</span> <span class="n">values</span><span class="p">,</span> <span class="n">some_string</span><span class="p">,</span> <span class="n">JSON_TOK_STRING</span><span class="p">),</span>
    <span class="n">FIELD</span><span class="p">(</span><span class="k">struct</span> <span class="n">values</span><span class="p">,</span> <span class="n">some_int</span><span class="p">,</span> <span class="n">JSON_TOK_NUMBER</span><span class="p">),</span>
    <span class="n">FIELD</span><span class="p">(</span><span class="k">struct</span> <span class="n">values</span><span class="p">,</span> <span class="n">some_bool</span><span class="p">,</span> <span class="n">JSON_TOK_TRUE</span><span class="p">),</span>
<span class="p">};</span>
<span class="cm">/* (FIELD is just a macro that saves the offsetof()</span>
<span class="cm"> * each struct member so that a pointer can be produced</span>
<span class="cm"> * afterwards.)  */</span>

<span class="cm">/* It's now just a matter of parsing the JSON now. */</span>
<span class="k">struct</span> <span class="n">values</span> <span class="n">values</span><span class="p">;</span>
<span class="kt">int32_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">json_parse</span><span class="p">(</span><span class="n">serialized</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">serialized</span><span class="p">),</span>
    <span class="n">values_descr</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">values_descr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">);</span>

<span class="cm">/* Bits 0, 1, and 2 of ret will be set if some_string,</span>
<span class="cm"> * some_int, and some_bool have been successfully</span>
<span class="cm"> * deserialized.  */</span>
</pre></div>
</div>
<p>Another thing that could be done – but that has not been implemented yet,
is to do the opposite as well: the descriptor and a struct to produce
JSON-encoded data.  This has many advantages over the usual JSON libraries
that require generating a JSON tree in memory just to serialize it
afterwards.</p>
<p>And although I’m quite happy with this code, there are still some
limitations that I’ll address whenever I have the need.</p>
<p>Mainly, there’s no way to parse nested objects or arrays.  I’ve written code
to do this but these changes haven’t gotten any fuzz-testing action so I’m
holding them off it until my living room heater^Wcomputer has worked on the
problem for at least a week.</p>
<p>Another one that’s not a deal breaker for an embedded OS is the lack of
floating pointing numbers (only integers for now).  Parsing floating point
is <a class="reference external" href="http://www.netlib.org/fp/dtoa.c">trickier than it sounds</a>, and
there’s no <span class="docutils literal"><span class="pre">strtod()</span></span> in Zephyr’s minimal libc.</p>
<p>As a minor issue to work around, there’s the return value: this limits the
number of fields to be parsed to 32; that should be plenty for most uses.
However, in the unlikely event that’s not sufficient, this can be worked
around by having multiple descriptors.</p>
<p>And, finally, there’s the JSON encoding part that I’ve mentioned already.</p>
<p>The major problem with this piece of code, that can’t be fixed by writing
more code, is that I can’t use it with Lwan due to licensing reasons:
although it is open source, part of the <a class="reference external" href="http://www.zephyrproject.org">Zephyr project</a>, it is licensed under the Apache 2
license, which is incompatible with the GPL2+ used by Lwan (would have to
bump it to [L]GPL3).</p>
<p>(For those that might ask how fast is it: it’s fast enough. I didn’t
measure, I didn’t compare, and I don’t really care: it’s readable,
maintainable, and does the job.)</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        
        <div class="tags">
            <span>
                Tags:
                <a href="tags/programming.html">programming</a>, <a href="tags/zephyr.html">zephyr</a>, <a href="tags/parser.html">parser</a></span>
        </div>
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>November 08, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/11/08/infect_to_protect.html">Infect to Protect</a></h1>
<div class="section" id="bandwagons">
<h2>Bandwagons</h2>
<p>I’m not one to jump on each and every bandwagon I see. Sometimes that’s a
good decision, sometimes it’s better to just wait and see where they go
before taking any action.</p>
<p>Containers are one of those ideas that, while promising and intriguing, were
quite clumsy in the beginning, so I ignored them for a good while.  It’s
sufficiently mature now; so much so that’s quite difficult to ignore them.
Time to investigate them again.</p>
<p>Now, most of my work revolve around writing embedded software that runs on
bare metal; containers don’t really solve any work-related problem I have.
For personal usage, package management is more than sufficient to install
programs.  However, the sandbox aspect of containers are quite interesting
and it’s something I’d like to know more about.</p>
<p>There are many articles around the web explaining how containers on Linux
work.  Some get out of their way to explain in depth all the machinery
necessary to make them work, so there’s no need to repeat it here.</p>
<p>But, in sum: almost all of the <a class="reference external" href="http://jvns.ca/blog/2016/10/10/what-even-is-a-container/">kernel side of things was already present</a> before
containers were actually a thing: cgroups, system call filters, etc.
Containers (and their runtimes) only make them so simple to use it’s
transparent for the user.</p>
<p>I usually have a hard time understanding things that I cannot build, so I
decided to build a toy container runtime.  It’s crude and it’s a far cry
from what any industrial-strength container runtime is capable of, but it’s
not only a start, it’s implemented in a way that makes things a
<em>lot</em> easier for the user.</p>
</div>
<div class="section" id="virulent-tutorials">
<h2>Virulent tutorials</h2>
<p>Before I go into details on how my contraption works, a little bit of
background. I’ve been using Linux for over 18 years, and began my forays
in C about 14 years ago.</p>
<p>Around that time, a pretty interesting HOWTO explaining <a class="reference external" href="http://virus.enemy.org/virus-writing-HOWTO/_html/">how to create
viruses for ELF binaries</a> came out.  It
explained not only various methods of infecting an ELF executable, but also
methods to detect them.  Suffice to say, I couldn’t understand a thing back
then.  A few months ago, though, a conversation in the <a class="reference external" href="https://lhc.net.br">local hackerspace</a> brought up that tutorial; I could now finally
not only understand the techniques but put them to use.</p>
<p>One of the techniques explained in the HOWTO involves finding some
unused space in an ELF segment that’s also executable, writing shellcode
to that area, rewiring the executable’s entry point to point to the shell
code, and modifying the shell code so that it points to the original entry
point. It’s all quite Rube Goldberg-ey, but it’s actually quite simple.</p>
<p>This way, a chunk of code can be executed every time that program
starts, without altering the size of the program. The perfect crime.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="2016/11/08/https://media.giphy.com/media/oX13doUEAPtIY/giphy.gif"><img alt="Perfect crime" src="https://media.giphy.com/media/oX13doUEAPtIY/giphy.gif" style="width: 50%;"/></a>
</div>
</div>
<div class="section" id="dual-use-technology">
<h2>Dual use technology</h2>
<p>By now, you’ve most likely connected the dots: the idea is to use the
very same technique, originally designed for viruses, to create a program that
transforms any program into a sandboxed version of itself.</p>
<p>The prototype I wrote is very elementary; the only thing it does is
limiting, just once, which system calls a program can execute.</p>
<p>Sort of a less-powerful version of <a class="reference external" href="http://man.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man2/pledge.2">OpenBSD’s
pledge(2)</a>
(née <span class="docutils literal"><span class="pre">tame(2)</span></span>), which can be repeatedly called to reduce the amount of
privileges a process has. Useful, for instance, in cases where a
configuration file has to be read before processing user-supplied work.
That BSD version has <a class="reference external" href="https://www.openbsd.org/papers/hackfest2015-pledge/mgp00001.html">been sprinkling calls to
pledge()</a>
in almost all of the programs in the base install (which is easier for a
BSD system, since everything is kept under the same roof.)</p>
<p>But, unlike <span class="docutils literal"><span class="pre">pledge(2)</span></span>, this thing can be applied to binaries that have
been already built. No source code modifications are necessary. If your
distribution can withstand the stench, “infected” binaries could be a
thing in the default installation.</p>
</div>
<div class="section" id="filtering-the-system-calls">
<h2>Filtering the system calls</h2>
<p>Any respectable container runtime will perform a lot of tasks to sandbox
a process and their children. So, for a proof of concept, I decided to
do just the bare minimum: limit system calls using Seccomp-BPF.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Seccomp">Seccomp</a> is a set of features
present in the Linux kernel, since the 2.6.x days, that allows
restricting what a program can do, system call-wise. The original intent
was to do not permit any other system calls excepting those to end the
program, and read and write to already-opened file descriptors. In some
scenarios, this is perfectly acceptable. For others, there’s the
seccomp-BPF extension.</p>
<p>BPF stands for <a class="reference external" href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">Berkeley Packet
Filter</a>. A
famous use of BPFs is in the tcpdump program, where rules such as “only
give me back TCP fragments with the RST flag set” can be passed to the
kernel; packets that don’t match the filter are not copied back to the
userland, reducing a lot of the chatter between the two lands.</p>
<p>Obviously, this must be extremely performant, since kernel time must be
conserved at all costs (the kernel is there only to serve userland, after
all).  Linux has many ways to speed up BPF programs, including an in-kernel
JIT compiler.  Some restrictions are in place that wouldn’t allow BPF
programs to take an infinite amount of time to execute, and this <a class="reference external" href="https://blog.cloudflare.com/bpf-the-forgotten-bytecode/">blog post</a> is a good
introductory reading material on the subject.</p>
<p>Another, slightly less famous use of BPFs is with the seccomp-BPF
extension. Instead of filtering network packets, processes can, for
instance, pick which system calls they’re allowed to perform. And that’s
precisely what’s necessary for my proof of concept.</p>
</div>
<div class="section" id="scripting-like-a-kid">
<h2>Scripting like a kid</h2>
<p>There are many ways to skin a cat. I decided to take a look how other
programs were doing their sandboxes, and eventually <a class="reference external" href="https://github.com/brynet/file/commit/612a76f47d879d8c7cc5791b49a3704b54391e05">found one that
seemed easy
enough</a>
to copy the technique from.</p>
<p>Unfortunately, writing shellcodes in C isn’t that easy, specially if you
don’t know which C library a program was linked with (or if it were
linked to a C library in the first place). Luckily, all the shellcode
has to do is make two system calls, which is straightforward to do with
a little bit of assembly.</p>
<p>The first call will forbid the process from getting more privileges. The
second call will actually copy the BPF program to the kernel side.</p>
<p>The first call is painless: just set a few registers, invoke the syscall,
done.</p>
<p>The other one takes a little bit more work. A few things helped: I’ve
used <a class="reference external" href="http://www.nasm.us/">nasm</a>, which is a <a class="reference external" href="https://en.wikipedia.org/wiki/Assembly_language#Macros">macro
assembler</a>,
and wrote a few macros that let me write BPF programs as if they were
standard x86-64 instructions.</p>
<p>The remaining issue is that a pointer to the BPF program must be passed
to the call to <span class="docutils literal"><span class="pre">prctl()</span></span>, and the shellcode must be relocatable. A <a class="reference external" href="http://stackoverflow.com/a/15704848">common
trick</a> to perform in these
scenarios is to employ the fact that, on x86, when a call instruction is
made, the return address (i.e. the address of the byte right after the
call instruction) is pushed to the stack:</p>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span/>    <span class="c1">; …</span>
    <span class="nf">jmp</span> <span class="nv">push_bpf_addr</span>
<span class="nl">apply_filter:</span>
    <span class="nf">pop</span> <span class="nb">rdx</span>     <span class="c1">; rdx points to the BPF program</span>
    <span class="c1">; …</span>
<span class="nl">push_bpf_adr:</span>
    <span class="nf">call</span> <span class="nv">apply_filter</span>
<span class="nl">bpf:</span>
    <span class="nf">bpf_stmt</span> <span class="c1">; …</span>
    <span class="nf">bpf_jump</span> <span class="c1">; …</span>
    <span class="nf">sc_allow</span> <span class="c1">; …</span>
    <span class="c1">; …</span>
<span class="nl">bpf_end:</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">bpf</span></span> label doesn’t point to any x86 instruction: it contains only
macros that expands to the definitions of <span class="docutils literal"><span class="pre">struct</span> <span class="pre">sock_filter</span></span> as defined
in <span class="docutils literal"><span class="pre">linux/filter.h</span></span>.  To copy the BPF program to the kernel, the <cite>prctl()</cite>
call expects a <span class="docutils literal"><span class="pre">struct</span> <span class="pre">sock_fprog</span></span>, which contains the BPF program length
(in number of <span class="docutils literal"><span class="pre">struct</span> <span class="pre">sock_filter</span></span> elements), and a pointer to the base of
that array.  Since there’s no way to know where this code is gong to land in
memory beforehand, this trick comes in handy: after the <span class="docutils literal"><span class="pre">call</span>
<span class="pre">apply_filter</span></span> instruction, the top of the stack now contains the base
address of that array.</p>
<p>Now that I had a way to write the shellcode, it was just the matter of
shoehorning it into the executable.</p>
<div class="figure align-center">
<img alt="Hacking time" src="https://media.giphy.com/media/l46C6sdSa5DVSJnLG/giphy.gif"/>
</div>
</div>
<div class="section" id="scoring-a-goal">
<h2>Scoring a goal</h2>
<p>For the proof of concept, I was initially going to write the infection
program in Python, as I usually do for throwaway code.  However, I wasn’t
successful in finding a working ELF library that would let me dump the
modified executable.</p>
<p>I was too lazy to actually fix or write support for that, so I kept
looking for alternatives and ended up finding the
<a class="reference external" href="http://www.muppetlabs.com/~breadbox/software/elfkickers.html">ELFkickers</a>
suite from the always excellent Muppet Labs. It includes an “infect”
program that does exactly what says in the tin: it takes in an
executable file, and produces another executable file that creates a
setuid shell before continuing to the original program. Exactly what one
would expect from a program with nefarious purposes.</p>
<p>So I substituted the original shellcode for the one I’ve just assembled, and
now I had a proof of concept.  Which of course didn’t work the first few
tries.  In fact, it took a long while to get it right.</p>
</div>
<div class="section" id="debugging-the-contraption-with-gdb">
<h2>Debugging the contraption with gdb</h2>
<p>The GNU Debugger is indeed very powerful, but ease of use (compared to
the Turbo Debugger I used to use in the DOS days) is not it’s strong
suit. I’m not used to using it to debug programs without access to
source, and this was a good opportunity to learn a few things.</p>
<p>Since the infection program modifies the ELF entry point, setting a
breakpoint on <span class="docutils literal"><span class="pre">main()</span></span> won’t actually work. But this is easily solvable:
just use <a class="reference external" href="https://linux.die.net/man/1/readelf">readelf(1)</a> to find
where the new entry point is, and set a breakpoint to that:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span/><span class="gp">$</span> gcc -o hello hello.c
<span class="gp">$</span> readelf -h hello <span class="p">|</span> grep Entry
<span class="go">  Entry point address: 0x400490</span>
<span class="gp">$</span> ./infect hello
<span class="gp">$</span> readelf -h hello <span class="p">|</span> grep Entry
<span class="go">  Entry point address: 0x4007bc</span>
<span class="gp">$</span> gdb ./hello
<span class="go">…</span>
<span class="go">(gdb) break *0x4007bc</span>
<span class="go">Breakpoint 1 at 0x4007bc</span>
</pre></div>
</div>
<p>From now on, it’s just the usual
execute-inspect-modify-reassemble-reinfect loop until it works. Although
it’s no <a class="reference external" href="https://www.youtube.com/watch?v=-ueCuJXF6po">td</a>, I’m
certainly glad GDB has layouts that displays both the <a class="reference external" href="https://reverseengineering.stackexchange.com/questions/1935/how-to-handle-stripped-binaries-with-gdb-no-source-no-symbols-and-gdb-only-sho">disassembly and
the
registers</a>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="2016/11/08/https://data.photofunky.net/output/image/f/b/5/0/fb50ca/photofunky.gif"><img alt="Step-by-step debugging" src="https://data.photofunky.net/output/image/f/b/5/0/fb50ca/photofunky.gif" style="width: 50%;"/></a>
</div>
</div>
<div class="section" id="watching-the-magic-happen">
<h2>Watching the magic happen</h2>
<p>The <span class="docutils literal"><span class="pre">hello</span></span> program is very short and the call to <span class="docutils literal"><span class="pre">socket(2)</span></span> doesn’t
make much sense there.  It’s just a way to test what’s going to happen when
the filter is in place, without the need to modify the program to test this
assumption.  (<a class="reference external" href="https://www.bsdcan.org/2016/schedule/attachments/357_20160610-bsdcan-helloworld.pdf">Lots of things</a>
happens when executing a simple program such as this.)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp"/>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"no socket created</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"created socket, fd=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Executing the program before infecting it gives the following output, as
expected:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>$ ./hello
no socket created
$ ./hello 1
created socket, fd = 3
</pre></div>
</div>
<p>Indeed, if the program is executed under strace, it all goes exactly
like it’s supposed to be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>$ strace ./hello
execve("./hello", ["./hello"], [/* 58 vars */]) = 0
…
write(1, "no socket created\n", 18no socket created
)     = 18
exit_group(0)                           = ?
+++ exited with 0 +++
</pre></div>
</div>
<p>And, with a command-line argument, so the socket is created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>…
socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
…
write(1, "created socket, fd = 3\n", 23created socket, fd = 3
) = 23
exit_group(0)                           = ?
+++ exited with 0 +++
</pre></div>
</div>
<p>However, the magic happens after the “infected” binary is executed.
First, without creating a socket:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>…
prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)  = 0
prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, {len=30, filter=0x400824}) = 0
…
write(1, "no socket created\n", 18no socket created
)     = 18
exit_group(0)                           = ?
+++ exited with 0 +++
</pre></div>
</div>
<p>Notice the calls to <span class="docutils literal"><span class="pre">prctl()</span></span>, very similar to the ones found in the
previously-mentioned commit. And then the program executes as usual.
Now, if an argument is passed, the program will attempt to create a
socket:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>…
prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)  = 0
prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, {len=30, filter=0x400824}) = 0
socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 41
--- SIGSYS {si_signo=SIGSYS, si_code=SYS_SECCOMP, si_call_addr=0x7f2d01aa19e7, si_syscall=__NR_socket, si_arch=AUDIT_ARCH_X86_64} ---
+++ killed by SIGSYS (core dumped) +++
[1]    27536 invalid system call (core dumped)  strace ./hello 1
</pre></div>
</div>
<p>And Seccomp kicks in and kills the program with a <span class="docutils literal"><span class="pre">SIGSYS</span></span> signal. As
expected. <strong>It’s alive!</strong></p>
<div class="figure align-center">
<img alt="It's alive!" src="https://i.imgur.com/sWwquxp.jpg"/>
</div>
</div>
<div class="section" id="next-steps">
<h2>Next steps</h2>
<p>The prototype works. But there are a few things that must be considered
before even considering this idea for anything.</p>
<div class="section" id="system-call-whitelist">
<h3>System call whitelist</h3>
<p>The list of system calls is still hardcoded within the shellcode. That’s
not optimal. Maintaining a list such as this for each and every program
will most likely be so boring nobody is going to do that.</p>
<p>I can think of three possible ways of coming up with this list.</p>
<p>The first would be doing the same thing <span class="docutils literal"><span class="pre">pledge(2)</span></span> does: allowing a very
restrict set of system calls at first, with some limitations, and then
providing a few sets of calls per set of features a program might use: stdio,
inet, tty, etc.  The nice thing about this is that the filters are more fine
grained; it’s not just a whitelist of system calls.  (The <a class="reference external" href="http://man.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man2/pledge.2">man page</a> has
more details.)</p>
<p>The second way would involve running the program under <span class="docutils literal"><span class="pre">strace(1)</span></span> and
record which system calls the program makes from a few runs.  If the test
coverage for each run is sufficiently high, this will work very reliably;
this isn’t always the case, so the mileage may vary.  Also, for certain
large, complicated programs, stracing it all automatically could prove to be
a challenge.</p>
<p>Another way would be the following: Grab a list of undefined symbols a
program uses, and find them in the shared libraries it links to.  Then scan
the executable and the libraries for sequences like <span class="docutils literal"><span class="pre">mov</span> <span class="pre">eax,</span> <span class="pre">57;</span> <span class="pre">syscall</span></span>
(for the oldschool <span class="docutils literal"><span class="pre">fork(2)</span></span> syscall on x86-64) or <span class="docutils literal"><span class="pre">mov</span> <span class="pre">rdi,</span> <span class="pre">57;</span> <span class="pre">call</span>
<span class="pre">syscall@plt</span></span>.  This is still not foolproof, since not necessarily a system
call number (loaded into <span class="docutils literal"><span class="pre">eax</span></span>) will be hardcoded within a program or
shared library.</p>
<p>There’s a fourth idea, as well, which involves both doing the automated
static analysis on the binary and running strace to catch “runaway”
syscalls. This can get quite complicated and it’s unlikely I’ll get it
correct in the first few tries (and, yet, the same shortcomings will
apply in the end.)</p>
<p>For me, though, these experiments are all about the hunt, not about the
treasure. So the tried and true approach that <span class="docutils literal"><span class="pre">pledge(2)</span></span> uses won’t be
used at first.</p>
</div>
<div class="section" id="filter-optimization">
<h3>Filter optimization</h3>
<p>Another thing that might be a problem is: on x86-64, Linux has hundreds of
system calls.  (329 according to <span class="docutils literal"><span class="pre">sys/syscall.h</span></span> at the moment I write
this.)</p>
<p>Even if the JIT for BPFs is quite efficient, doing a linear search before each
and every system call will certainly be a bottleneck.  Also, BPF programs are
limited in size, and a large whitelist that’s implemented the same way as the
prototype will limit the possibility for more fine-grained filters.  Things
like “the <span class="docutils literal"><span class="pre">socket(2)</span></span> call is allowed only for UNIX-domain sockets”, rather than
allowing whatever call to <span class="docutils literal"><span class="pre">socket(2)</span></span> would be impractical.</p>
<p>Since each syscall is identified by a number, a simple bitmap could be
used to implement the whitelist. This will also free up some space in
the BPF program for more detailed whitelisting for certain syscalls (for
instance, only allowing certain family of sockets to be created).</p>
<p>After a quick read of
<a class="reference external" href="https://www.kernel.org/doc/Documentation/networking/filter.txt">networking/filter.txt</a>,
this seems doable by using an algorithm such as this, which will reduce
the number of comparisons as the number of acceptable system calls
increases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>        if syscall_number &lt; 32:
                if bitmask_0 &amp; 1&lt;&lt;syscall_number: goto accept
        if syscall_number &lt; 64:
                syscall_number -= 32
                if bitmask_1 &amp; 1&lt;&lt;syscall_number: goto accept
        if syscall_number &lt; 96:
                syscall_number -= 64
                if bitmask_2 &amp; 1&lt;&lt;syscall_number: goto accept
        …
        if syscall_number &lt; 352:
                syscall_number -= 320
                if bitmask_10 &amp; 1&lt;&lt;syscall_number: goto accept
        return SECCOMP_RET_KILL
accept:
        return SECCOMP_RET_ACCEPT
</pre></div>
</div>
<p>(Some of the <span class="docutils literal"><span class="pre">if</span> <span class="pre">syscall_number</span> <span class="pre">&lt;</span> <span class="pre">N</span></span> blocks could be changed to
<span class="docutils literal"><span class="pre">syscall_number</span> <span class="pre">-=</span> <span class="pre">M</span></span> if their respective bitmask is <span class="docutils literal"><span class="pre">0</span></span>.)</p>
<p>Or maybe just a bloom filter instead of a series of bitmaps. I’ll have
to experiment.</p>
</div>
<div class="section" id="getting-a-larger-vessel">
<h3>Getting a larger vessel</h3>
<p>Containers, of course, are not just about restricting which system calls a
program is allowed to perform.  There are many things that can and must be
considered before even calling this a container runtime, or really consider
that this is in fact sandboxing anything.  Learning about namespaces,
cgroups and virtual machines are certainly on the list of things to learn
about.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>While the prototype I built isn’t practical and is of very limited use,
I find the idea of sandboxed programs without the need for specialized
runtimes very enticing.</p>
<p>Programs can be still packaged the way they have been packaged in the
past decades, without throwing away some of the sandboxing benefits that
containers provide, all the while not introducing new concepts for
users.</p>
<p>Of course, something like this – even if properly implemented – won’t
be a replacement for containers. Specially if one considers their role
as packets ready for deployment, which have a lot of value for devops
personnel.</p>
<p>The code, as usual, is open source, and available from <a class="reference external" href="https://github.com/lpereira/infect-to-protect">this Git
repository</a>.</p>
</div>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        
        <div class="tags">
            <span>
                Tags:
                <a href="tags/container.html">container</a>, <a href="tags/assembly.html">assembly</a>, <a href="tags/linux.html">linux</a>, <a href="tags/bpf.html">bpf</a></span>
        </div>
        </div><div class="archive_link">
        <a href="archive.html"> &mdash; Blog Archive &mdash; </a>
    </div><ul class="related clearfix">
            <li class="left"></li>
            <li class="right"><a href="page2.html">Older</a> &raquo; </li>
        </ul></article><aside class="sidebar"><section><div class="widget" id="searchbox" role="search">
    <h1><a href="#searchbox">Search</a></h1>
    <form action="search.html" method="get">
        <input type="text" name="q" />
        <button type="submit"><span class="fa fa-search"></span></button>
    </form>
</div></section><section><div class="widget">
    <h1>Recent Posts</h1>
    <ul><li>
            <a href="2018/06/28/include_next_and_portability.html">include_next and portability</a>
        </li><li>
            <a href="2018/02/01/more_on_string_switch_in_c.html">More on string switch in C</a>
        </li><li>
            <a href="2017/05/08/coreboot_luks.html">Coreboot & LUKS</a>
        </li><li>
            <a href="2017/03/01/parsing_json.html">Parsing JSON</a>
        </li><li>
            <a href="2016/11/08/infect_to_protect.html">Infect to Protect</a>
        </li><li>
            <a href="2015/05/01/initializing_a_heap_allocated_structure_in_c.html">Initializing a heap-allocated structure in C</a>
        </li><li>
            <a href="2014/11/02/hybrid_c_pascal_strings.html">Hybrid C/Pascal Strings</a>
        </li><li>
            <a href="2014/10/06/life_of_a_http_request.html">Life of a HTTP request, as seen by my toy web server</a>
        </li><li>
            <a href="2014/06/23/integer_to_string_conversion.html">Integer to string conversion</a>
        </li><li>
            <a href="2013/12/08/reducing_lwan_memory_usage.html">Reducing Lwan memory usage by 94%</a>
        </li></ul>
</div>
</section><section><div class="widget">
    <h1>Tags Cloud</h1>
      <a href="tags/arduino.html" style="font-size: 8pt">arduino</a>&nbsp;&nbsp;
      <a href="tags/assembly.html" style="font-size: 8pt">assembly</a>&nbsp;&nbsp;
      <a href="tags/bpf.html" style="font-size: 8pt">bpf</a>&nbsp;&nbsp;
      <a href="tags/c.html" style="font-size: 16pt">C</a>&nbsp;&nbsp;
      <a href="tags/c.html" style="font-size: 8pt">c</a>&nbsp;&nbsp;
      <a href="tags/conferences.html" style="font-size: 8pt">conferences</a>&nbsp;&nbsp;
      <a href="tags/container.html" style="font-size: 8pt">container</a>&nbsp;&nbsp;
      <a href="tags/data_structure.html" style="font-size: 8pt">data-structure</a>&nbsp;&nbsp;
      <a href="tags/efl.html" style="font-size: 8pt">efl</a>&nbsp;&nbsp;
      <a href="tags/enlightenment.html" style="font-size: 8pt">enlightenment</a>&nbsp;&nbsp;
      <a href="tags/finf.html" style="font-size: 8pt">finf</a>&nbsp;&nbsp;
      <a href="tags/javascript.html" style="font-size: 8pt">javascript</a>&nbsp;&nbsp;
      <a href="tags/linux.html" style="font-size: 9pt">linux</a>&nbsp;&nbsp;
      <a href="tags/lwan.html" style="font-size: 16pt">lwan</a>&nbsp;&nbsp;
      <a href="tags/optimization.html" style="font-size: 8pt">optimization</a>&nbsp;&nbsp;
      <a href="tags/parser.html" style="font-size: 8pt">parser</a>&nbsp;&nbsp;
      <a href="tags/profusion.html" style="font-size: 9pt">profusion</a>&nbsp;&nbsp;
      <a href="tags/programming.html" style="font-size: 20pt">programming</a>&nbsp;&nbsp;
      <a href="tags/strace.html" style="font-size: 8pt">strace</a>&nbsp;&nbsp;
      <a href="tags/template.html" style="font-size: 8pt">template</a>&nbsp;&nbsp;
      <a href="tags/tizen.html" style="font-size: 8pt">tizen</a>&nbsp;&nbsp;
      <a href="tags/trick.html" style="font-size: 14pt">trick</a>&nbsp;&nbsp;
      <a href="tags/tricks.html" style="font-size: 8pt">tricks</a>&nbsp;&nbsp;
      <a href="tags/zephyr.html" style="font-size: 8pt">zephyr</a>
</div></section></aside></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><footer class="wrapper">&copy; Copyright 2012—2015, Leandro Pereira. Powered by <a href="http://www.tinkerer.me/">Tinkerer</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.</footer></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>