<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width">
        <title>Home &mdash; Leandro Pereira</title>
            <link rel="stylesheet" href="_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="_static/main.css" type="text/css">
            <link rel="stylesheet" href="_static/flat.css" type="text/css">
            <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="_static/plugins.js"></script>
        <script src="_static/main.js"></script>
        <link rel="search" title="Search" href="search.html" /><link rel="next" title="Older" href="page2.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="_static/underscore.js"></script><script type="text/javascript" src="_static/doctools.js"></script>
<style type="text/css">img {max-width: 100%;}</style>
</head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><header role="banner">
            <hgroup>
              <h1><a href="#">Leandro Pereira</a></h1><h2>Geek in training</h2></hgroup>
          </header>
      <nav role="navigation">
            <ul><li class="main-nav">
                  <a href="#">Home</a>
                </li>
              <li class="main-nav">
                  <a href="pages/about.html">About</a>
                </li>
              </ul>
          </nav><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>March 01, 2017</span>
        </div>
        <div class="section">
            <h1><a href="2017/03/01/parsing_json.html">Parsing JSON</a></h1>
<p>There are many libraries out there to parse JSON files.  It might be a
futile attempt, then, to write yet another one.  However, when you’re
working on a RTOS where memory is golden, and the alternatives don’t look
that great, you got to do something about it.</p>
<p>Recently I wrote a <a class="reference external" href="http://www.json.org">JSON</a> parser for a project at
work.  This parser uses constant memory, regardless of the amount of data
it’s working with, and deserializes directly to a C struct.  Similar, in
spirit, to the JSON parser that’s part of the Golang standard library, that
encodes and decodes data based on a tagged structure.</p>
<p>The lexer is the usual state machine, where the state itself is a function
pointer to a function that handles that particular state.</p>
<p>I’ve been using this technique for a while, and I found that it’s a very
clean and efficient way of describing state machines, specially for lexers.</p>
<p>I began using it after a coworker wrote a <a class="reference external" href="https://github.com/solettaproject/soletta/blob/3bda9802b243c2052555cf88263f754d34458414/src/shared/sol-fbp-internal-scanner.c">parser for a DSL</a>
using it – and he got the idea from the – you guessed – Golang template
package.  (There’s a <a class="reference external" href="https://www.youtube.com/watch?v=HxaD_trXwRE">nice talk by Rob Pike about it</a> – I recommend this talk
not only for the lexing goodness, but also for the tips on how to evolve a
concurrent design.)</p>
<p>The parser implementation itself is nothing to write home about.  However,
by using the same idea used in Lwan’s mustache template engine to <a class="reference external" href="https://tia.mat.br/posts/2012/11/11/mustache_templates_in_c.html">obtain
the variables</a>, it
manages to do some things that are not common in JSON parsers written in C:</p>
<ul class="simple">
<li>It will accept only values of known types for a particular key.</li>
<li>It will save the decoded value directly in a struct field.</li>
<li>It won’t try to decode the same field twice.</li>
</ul>
<p>The first point is crucial when working with data received from the network,
which is precisely the kind of thing I’m dealing with.  This avoids problems
such as type confusion and such, and moves the responsibility of checking
the types to the library rather than the user of the library.</p>
<p>By saving the decoded value directly into a struct field, it does use a
predictable amount of memory.  This is good, as it’s not going to balloon
out of control, or require some guesswork to know beforehand how many tokens
are going to be necessary to deserialize some values.  The C compiler
already knows exactly how many bytes a struct needs.</p>
<p>Some fields might be optional in a JSON blob.  So the parser uses a bitmask
to mark which fields have been decoded (and returns that, so that the
library user can efficiently test if a value has been deserialized or not).
Since it was easy to do, the library refuses to decode a key that has been
deserialized before.</p>
<p>So, a typical use is the following:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="cm">/* First, define a struct to hold the values. */</span>
<span class="k">struct</span> <span class="n">values</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">some_string</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">some_int</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">some_bool</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Then, define a descriptor for that struct. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">json_descr</span> <span class="n">values_descr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">FIELD</span><span class="p">(</span><span class="k">struct</span> <span class="n">values</span><span class="p">,</span> <span class="n">some_string</span><span class="p">,</span> <span class="n">JSON_TOK_STRING</span><span class="p">),</span>
    <span class="n">FIELD</span><span class="p">(</span><span class="k">struct</span> <span class="n">values</span><span class="p">,</span> <span class="n">some_int</span><span class="p">,</span> <span class="n">JSON_TOK_NUMBER</span><span class="p">),</span>
    <span class="n">FIELD</span><span class="p">(</span><span class="k">struct</span> <span class="n">values</span><span class="p">,</span> <span class="n">some_bool</span><span class="p">,</span> <span class="n">JSON_TOK_TRUE</span><span class="p">),</span>
<span class="p">};</span>
<span class="cm">/* (FIELD is just a macro that saves the offsetof()</span>
<span class="cm"> * each struct member so that a pointer can be produced</span>
<span class="cm"> * afterwards.)  */</span>

<span class="cm">/* It's now just a matter of parsing the JSON now. */</span>
<span class="k">struct</span> <span class="n">values</span> <span class="n">values</span><span class="p">;</span>
<span class="kt">int32_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">json_parse</span><span class="p">(</span><span class="n">serialized</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">serialized</span><span class="p">),</span>
    <span class="n">values_descr</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">values_descr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">);</span>

<span class="cm">/* Bits 0, 1, and 2 of ret will be set if some_string,</span>
<span class="cm"> * some_int, and some_bool have been successfully</span>
<span class="cm"> * deserialized.  */</span>
</pre></div>
</div>
<p>Another thing that could be done – but that has not been implemented yet,
is to do the opposite as well: the descriptor and a struct to produce
JSON-encoded data.  This has many advantages over the usual JSON libraries
that require generating a JSON tree in memory just to serialize it
afterwards.</p>
<p>And although I’m quite happy with this code, there are still some
limitations that I’ll address whenever I have the need.</p>
<p>Mainly, there’s no way to parse nested objects or arrays.  I’ve written code
to do this but these changes haven’t gotten any fuzz-testing action so I’m
holding them off it until my living room heater^Wcomputer has worked on the
problem for at least a week.</p>
<p>Another one that’s not a deal breaker for an embedded OS is the lack of
floating pointing numbers (only integers for now).  Parsing floating point
is <a class="reference external" href="http://www.netlib.org/fp/dtoa.c">trickier than it sounds</a>, and
there’s no <span class="docutils literal"><span class="pre">strtod()</span></span> in Zephyr’s minimal libc.</p>
<p>As a minor issue to work around, there’s the return value: this limits the
number of fields to be parsed to 32; that should be plenty for most uses.
However, in the unlikely event that’s not sufficient, this can be worked
around by having multiple descriptors.</p>
<p>And, finally, there’s the JSON encoding part that I’ve mentioned already.</p>
<p>The major problem with this piece of code, that can’t be fixed by writing
more code, is that I can’t use it with Lwan due to licensing reasons:
although it is open source, part of the <a class="reference external" href="http://www.zephyrproject.org">Zephyr project</a>, it is licensed under the Apache 2
license, which is incompatible with the GPL2+ used by Lwan (would have to
bump it to [L]GPL3).</p>
<p>(For those that might ask how fast is it: it’s fast enough. I didn’t
measure, I didn’t compare, and I don’t really care: it’s readable,
maintainable, and does the job.)</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        
        <div class="tags">
            <span>
                Tags:
                <a href="tags/programming.html">programming</a>, <a href="tags/zephyr.html">zephyr</a>, <a href="tags/parser.html">parser</a></span>
        </div>
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>November 08, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/11/08/infect_to_protect.html">Infect to Protect</a></h1>
<div class="section" id="bandwagons">
<h2>Bandwagons</h2>
<p>I’m not one to jump on each and every bandwagon I see. Sometimes that’s a
good decision, sometimes it’s better to just wait and see where they go
before taking any action.</p>
<p>Containers are one of those ideas that, while promising and intriguing, were
quite clumsy in the beginning, so I ignored them for a good while.  It’s
sufficiently mature now; so much so that’s quite difficult to ignore them.
Time to investigate them again.</p>
<p>Now, most of my work revolve around writing embedded software that runs on
bare metal; containers don’t really solve any work-related problem I have.
For personal usage, package management is more than sufficient to install
programs.  However, the sandbox aspect of containers are quite interesting
and it’s something I’d like to know more about.</p>
<p>There are many articles around the web explaining how containers on Linux
work.  Some get out of their way to explain in depth all the machinery
necessary to make them work, so there’s no need to repeat it here.</p>
<p>But, in sum: almost all of the <a class="reference external" href="http://jvns.ca/blog/2016/10/10/what-even-is-a-container/">kernel side of things was already present</a> before
containers were actually a thing: cgroups, system call filters, etc.
Containers (and their runtimes) only make them so simple to use it’s
transparent for the user.</p>
<p>I usually have a hard time understanding things that I cannot build, so I
decided to build a toy container runtime.  It’s crude and it’s a far cry
from what any industrial-strength container runtime is capable of, but it’s
not only a start, it’s implemented in a way that makes things a
<em>lot</em> easier for the user.</p>
</div>
<div class="section" id="virulent-tutorials">
<h2>Virulent tutorials</h2>
<p>Before I go into details on how my contraption works, a little bit of
background. I’ve been using Linux for over 18 years, and began my forays
in C about 14 years ago.</p>
<p>Around that time, a pretty interesting HOWTO explaining <a class="reference external" href="http://virus.enemy.org/virus-writing-HOWTO/_html/">how to create
viruses for ELF binaries</a> came out.  It
explained not only various methods of infecting an ELF executable, but also
methods to detect them.  Suffice to say, I couldn’t understand a thing back
then.  A few months ago, though, a conversation in the <a class="reference external" href="https://lhc.net.br">local hackerspace</a> brought up that tutorial; I could now finally
not only understand the techniques but put them to use.</p>
<p>One of the techniques explained in the HOWTO involves finding some
unused space in an ELF segment that’s also executable, writing shellcode
to that area, rewiring the executable’s entry point to point to the shell
code, and modifying the shell code so that it points to the original entry
point. It’s all quite Rube Goldberg-ey, but it’s actually quite simple.</p>
<p>This way, a chunk of code can be executed every time that program
starts, without altering the size of the program. The perfect crime.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="2016/11/08/https://media.giphy.com/media/oX13doUEAPtIY/giphy.gif"><img alt="Perfect crime" src="https://media.giphy.com/media/oX13doUEAPtIY/giphy.gif" style="width: 50%;"/></a>
</div>
</div>
<div class="section" id="dual-use-technology">
<h2>Dual use technology</h2>
<p>By now, you’ve most likely connected the dots: the idea is to use the
very same technique, originally designed for viruses, to create a program that
transforms any program into a sandboxed version of itself.</p>
<p>The prototype I wrote is very elementary; the only thing it does is
limiting, just once, which system calls a program can execute.</p>
<p>Sort of a less-powerful version of <a class="reference external" href="http://man.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man2/pledge.2">OpenBSD’s
pledge(2)</a>
(née <span class="docutils literal"><span class="pre">tame(2)</span></span>), which can be repeatedly called to reduce the amount of
privileges a process has. Useful, for instance, in cases where a
configuration file has to be read before processing user-supplied work.
That BSD version has <a class="reference external" href="https://www.openbsd.org/papers/hackfest2015-pledge/mgp00001.html">been sprinkling calls to
pledge()</a>
in almost all of the programs in the base install (which is easier for a
BSD system, since everything is kept under the same roof.)</p>
<p>But, unlike <span class="docutils literal"><span class="pre">pledge(2)</span></span>, this thing can be applied to binaries that have
been already built. No source code modifications are necessary. If your
distribution can withstand the stench, “infected” binaries could be a
thing in the default installation.</p>
</div>
<div class="section" id="filtering-the-system-calls">
<h2>Filtering the system calls</h2>
<p>Any respectable container runtime will perform a lot of tasks to sandbox
a process and their children. So, for a proof of concept, I decided to
do just the bare minimum: limit system calls using Seccomp-BPF.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Seccomp">Seccomp</a> is a set of features
present in the Linux kernel, since the 2.6.x days, that allows
restricting what a program can do, system call-wise. The original intent
was to do not permit any other system calls excepting those to end the
program, and read and write to already-opened file descriptors. In some
scenarios, this is perfectly acceptable. For others, there’s the
seccomp-BPF extension.</p>
<p>BPF stands for <a class="reference external" href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">Berkeley Packet
Filter</a>. A
famous use of BPFs is in the tcpdump program, where rules such as “only
give me back TCP fragments with the RST flag set” can be passed to the
kernel; packets that don’t match the filter are not copied back to the
userland, reducing a lot of the chatter between the two lands.</p>
<p>Obviously, this must be extremely performant, since kernel time must be
conserved at all costs (the kernel is there only to serve userland, after
all).  Linux has many ways to speed up BPF programs, including an in-kernel
JIT compiler.  Some restrictions are in place that wouldn’t allow BPF
programs to take an infinite amount of time to execute, and this <a class="reference external" href="https://blog.cloudflare.com/bpf-the-forgotten-bytecode/">blog post</a> is a good
introductory reading material on the subject.</p>
<p>Another, slightly less famous use of BPFs is with the seccomp-BPF
extension. Instead of filtering network packets, processes can, for
instance, pick which system calls they’re allowed to perform. And that’s
precisely what’s necessary for my proof of concept.</p>
</div>
<div class="section" id="scripting-like-a-kid">
<h2>Scripting like a kid</h2>
<p>There are many ways to skin a cat. I decided to take a look how other
programs were doing their sandboxes, and eventually <a class="reference external" href="https://github.com/brynet/file/commit/612a76f47d879d8c7cc5791b49a3704b54391e05">found one that
seemed easy
enough</a>
to copy the technique from.</p>
<p>Unfortunately, writing shellcodes in C isn’t that easy, specially if you
don’t know which C library a program was linked with (or if it were
linked to a C library in the first place). Luckily, all the shellcode
has to do is make two system calls, which is straightforward to do with
a little bit of assembly.</p>
<p>The first call will forbid the process from getting more privileges. The
second call will actually copy the BPF program to the kernel side.</p>
<p>The first call is painless: just set a few registers, invoke the syscall,
done.</p>
<p>The other one takes a little bit more work. A few things helped: I’ve
used <a class="reference external" href="http://www.nasm.us/">nasm</a>, which is a <a class="reference external" href="https://en.wikipedia.org/wiki/Assembly_language#Macros">macro
assembler</a>,
and wrote a few macros that let me write BPF programs as if they were
standard x86-64 instructions.</p>
<p>The remaining issue is that a pointer to the BPF program must be passed
to the call to <span class="docutils literal"><span class="pre">prctl()</span></span>, and the shellcode must be relocatable. A <a class="reference external" href="http://stackoverflow.com/a/15704848">common
trick</a> to perform in these
scenarios is to employ the fact that, on x86, when a call instruction is
made, the return address (i.e. the address of the byte right after the
call instruction) is pushed to the stack:</p>
<div class="highlight-nasm"><div class="highlight"><pre><span/>    <span class="c1">; …</span>
    <span class="nf">jmp</span> <span class="nv">push_bpf_addr</span>
<span class="nl">apply_filter:</span>
    <span class="nf">pop</span> <span class="nb">rdx</span>     <span class="c1">; rdx points to the BPF program</span>
    <span class="c1">; …</span>
<span class="nl">push_bpf_adr:</span>
    <span class="nf">call</span> <span class="nv">apply_filter</span>
<span class="nl">bpf:</span>
    <span class="nf">bpf_stmt</span> <span class="c1">; …</span>
    <span class="nf">bpf_jump</span> <span class="c1">; …</span>
    <span class="nf">sc_allow</span> <span class="c1">; …</span>
    <span class="c1">; …</span>
<span class="nl">bpf_end:</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">bpf</span></span> label doesn’t point to any x86 instruction: it contains only
macros that expands to the definitions of <span class="docutils literal"><span class="pre">struct</span> <span class="pre">sock_filter</span></span> as defined
in <span class="docutils literal"><span class="pre">linux/filter.h</span></span>.  To copy the BPF program to the kernel, the <cite>prctl()</cite>
call expects a <span class="docutils literal"><span class="pre">struct</span> <span class="pre">sock_fprog</span></span>, which contains the BPF program length
(in number of <span class="docutils literal"><span class="pre">struct</span> <span class="pre">sock_filter</span></span> elements), and a pointer to the base of
that array.  Since there’s no way to know where this code is gong to land in
memory beforehand, this trick comes in handy: after the <span class="docutils literal"><span class="pre">call</span>
<span class="pre">apply_filter</span></span> instruction, the top of the stack now contains the base
address of that array.</p>
<p>Now that I had a way to write the shellcode, it was just the matter of
shoehorning it into the executable.</p>
<div class="figure align-center">
<img alt="Hacking time" src="https://media.giphy.com/media/l46C6sdSa5DVSJnLG/giphy.gif"/>
</div>
</div>
<div class="section" id="scoring-a-goal">
<h2>Scoring a goal</h2>
<p>For the proof of concept, I was initially going to write the infection
program in Python, as I usually do for throwaway code.  However, I wasn’t
successful in finding a working ELF library that would let me dump the
modified executable.</p>
<p>I was too lazy to actually fix or write support for that, so I kept
looking for alternatives and ended up finding the
<a class="reference external" href="http://www.muppetlabs.com/~breadbox/software/elfkickers.html">ELFkickers</a>
suite from the always excellent Muppet Labs. It includes an “infect”
program that does exactly what says in the tin: it takes in an
executable file, and produces another executable file that creates a
setuid shell before continuing to the original program. Exactly what one
would expect from a program with nefarious purposes.</p>
<p>So I substituted the original shellcode for the one I’ve just assembled, and
now I had a proof of concept.  Which of course didn’t work the first few
tries.  In fact, it took a long while to get it right.</p>
</div>
<div class="section" id="debugging-the-contraption-with-gdb">
<h2>Debugging the contraption with gdb</h2>
<p>The GNU Debugger is indeed very powerful, but ease of use (compared to
the Turbo Debugger I used to use in the DOS days) is not it’s strong
suit. I’m not used to using it to debug programs without access to
source, and this was a good opportunity to learn a few things.</p>
<p>Since the infection program modifies the ELF entry point, setting a
breakpoint on <span class="docutils literal"><span class="pre">main()</span></span> won’t actually work. But this is easily solvable:
just use <a class="reference external" href="https://linux.die.net/man/1/readelf">readelf(1)</a> to find
where the new entry point is, and set a breakpoint to that:</p>
<div class="highlight-shell-session"><div class="highlight"><pre><span/><span class="gp">$</span> gcc -o hello hello.c
<span class="gp">$</span> readelf -h hello <span class="p">|</span> grep Entry
<span class="go">  Entry point address: 0x400490</span>
<span class="gp">$</span> ./infect hello
<span class="gp">$</span> readelf -h hello <span class="p">|</span> grep Entry
<span class="go">  Entry point address: 0x4007bc</span>
<span class="gp">$</span> gdb ./hello
<span class="go">…</span>
<span class="go">(gdb) break *0x4007bc</span>
<span class="go">Breakpoint 1 at 0x4007bc</span>
</pre></div>
</div>
<p>From now on, it’s just the usual
execute-inspect-modify-reassemble-reinfect loop until it works. Although
it’s no <a class="reference external" href="https://www.youtube.com/watch?v=-ueCuJXF6po">td</a>, I’m
certainly glad GDB has layouts that displays both the <a class="reference external" href="https://reverseengineering.stackexchange.com/questions/1935/how-to-handle-stripped-binaries-with-gdb-no-source-no-symbols-and-gdb-only-sho">disassembly and
the
registers</a>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="2016/11/08/https://data.photofunky.net/output/image/f/b/5/0/fb50ca/photofunky.gif"><img alt="Step-by-step debugging" src="https://data.photofunky.net/output/image/f/b/5/0/fb50ca/photofunky.gif" style="width: 50%;"/></a>
</div>
</div>
<div class="section" id="watching-the-magic-happen">
<h2>Watching the magic happen</h2>
<p>The <span class="docutils literal"><span class="pre">hello</span></span> program is very short and the call to <span class="docutils literal"><span class="pre">socket(2)</span></span> doesn’t
make much sense there.  It’s just a way to test what’s going to happen when
the filter is in place, without the need to modify the program to test this
assumption.  (<a class="reference external" href="https://www.bsdcan.org/2016/schedule/attachments/357_20160610-bsdcan-helloworld.pdf">Lots of things</a>
happens when executing a simple program such as this.)</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp"/>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"no socket created</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"created socket, fd=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Executing the program before infecting it gives the following output, as
expected:</p>
<div class="highlight-default"><div class="highlight"><pre><span/>$ ./hello
no socket created
$ ./hello 1
created socket, fd = 3
</pre></div>
</div>
<p>Indeed, if the program is executed under strace, it all goes exactly
like it’s supposed to be:</p>
<div class="highlight-default"><div class="highlight"><pre><span/>$ strace ./hello
execve("./hello", ["./hello"], [/* 58 vars */]) = 0
…
write(1, "no socket created\n", 18no socket created
)     = 18
exit_group(0)                           = ?
+++ exited with 0 +++
</pre></div>
</div>
<p>And, with a command-line argument, so the socket is created:</p>
<div class="highlight-default"><div class="highlight"><pre><span/>…
socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
…
write(1, "created socket, fd = 3\n", 23created socket, fd = 3
) = 23
exit_group(0)                           = ?
+++ exited with 0 +++
</pre></div>
</div>
<p>However, the magic happens after the “infected” binary is executed.
First, without creating a socket:</p>
<div class="highlight-default"><div class="highlight"><pre><span/>…
prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)  = 0
prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, {len=30, filter=0x400824}) = 0
…
write(1, "no socket created\n", 18no socket created
)     = 18
exit_group(0)                           = ?
+++ exited with 0 +++
</pre></div>
</div>
<p>Notice the calls to <span class="docutils literal"><span class="pre">prctl()</span></span>, very similar to the ones found in the
previously-mentioned commit. And then the program executes as usual.
Now, if an argument is passed, the program will attempt to create a
socket:</p>
<div class="highlight-default"><div class="highlight"><pre><span/>…
prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)  = 0
prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, {len=30, filter=0x400824}) = 0
socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 41
--- SIGSYS {si_signo=SIGSYS, si_code=SYS_SECCOMP, si_call_addr=0x7f2d01aa19e7, si_syscall=__NR_socket, si_arch=AUDIT_ARCH_X86_64} ---
+++ killed by SIGSYS (core dumped) +++
[1]    27536 invalid system call (core dumped)  strace ./hello 1
</pre></div>
</div>
<p>And Seccomp kicks in and kills the program with a <span class="docutils literal"><span class="pre">SIGSYS</span></span> signal. As
expected. <strong>It’s alive!</strong></p>
<div class="figure align-center">
<img alt="It's alive!" src="https://i.imgur.com/sWwquxp.jpg"/>
</div>
</div>
<div class="section" id="next-steps">
<h2>Next steps</h2>
<p>The prototype works. But there are a few things that must be considered
before even considering this idea for anything.</p>
<div class="section" id="system-call-whitelist">
<h3>System call whitelist</h3>
<p>The list of system calls is still hardcoded within the shellcode. That’s
not optimal. Maintaining a list such as this for each and every program
will most likely be so boring nobody is going to do that.</p>
<p>I can think of three possible ways of coming up with this list.</p>
<p>The first would be doing the same thing <span class="docutils literal"><span class="pre">pledge(2)</span></span> does: allowing a very
restrict set of system calls at first, with some limitations, and then
providing a few sets of calls per set of features a program might use: stdio,
inet, tty, etc.  The nice thing about this is that the filters are more fine
grained; it’s not just a whitelist of system calls.  (The <a class="reference external" href="http://man.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man2/pledge.2">man page</a> has
more details.)</p>
<p>The second way would involve running the program under <span class="docutils literal"><span class="pre">strace(1)</span></span> and
record which system calls the program makes from a few runs.  If the test
coverage for each run is sufficiently high, this will work very reliably;
this isn’t always the case, so the mileage may vary.  Also, for certain
large, complicated programs, stracing it all automatically could prove to be
a challenge.</p>
<p>Another way would be the following: Grab a list of undefined symbols a
program uses, and find them in the shared libraries it links to.  Then scan
the executable and the libraries for sequences like <span class="docutils literal"><span class="pre">mov</span> <span class="pre">eax,</span> <span class="pre">57;</span> <span class="pre">syscall</span></span>
(for the oldschool <span class="docutils literal"><span class="pre">fork(2)</span></span> syscall on x86-64) or <span class="docutils literal"><span class="pre">mov</span> <span class="pre">rdi,</span> <span class="pre">57;</span> <span class="pre">call</span>
<span class="pre">syscall@plt</span></span>.  This is still not foolproof, since not necessarily a system
call number (loaded into <span class="docutils literal"><span class="pre">eax</span></span>) will be hardcoded within a program or
shared library.</p>
<p>There’s a fourth idea, as well, which involves both doing the automated
static analysis on the binary and running strace to catch “runaway”
syscalls. This can get quite complicated and it’s unlikely I’ll get it
correct in the first few tries (and, yet, the same shortcomings will
apply in the end.)</p>
<p>For me, though, these experiments are all about the hunt, not about the
treasure. So the tried and true approach that <span class="docutils literal"><span class="pre">pledge(2)</span></span> uses won’t be
used at first.</p>
</div>
<div class="section" id="filter-optimization">
<h3>Filter optimization</h3>
<p>Another thing that might be a problem is: on x86-64, Linux has hundreds of
system calls.  (329 according to <span class="docutils literal"><span class="pre">sys/syscall.h</span></span> at the moment I write
this.)</p>
<p>Even if the JIT for BPFs is quite efficient, doing a linear search before each
and every system call will certainly be a bottleneck.  Also, BPF programs are
limited in size, and a large whitelist that’s implemented the same way as the
prototype will limit the possibility for more fine-grained filters.  Things
like “the <span class="docutils literal"><span class="pre">socket(2)</span></span> call is allowed only for UNIX-domain sockets”, rather than
allowing whatever call to <span class="docutils literal"><span class="pre">socket(2)</span></span> would be impractical.</p>
<p>Since each syscall is identified by a number, a simple bitmap could be
used to implement the whitelist. This will also free up some space in
the BPF program for more detailed whitelisting for certain syscalls (for
instance, only allowing certain family of sockets to be created).</p>
<p>After a quick read of
<a class="reference external" href="https://www.kernel.org/doc/Documentation/networking/filter.txt">networking/filter.txt</a>,
this seems doable by using an algorithm such as this, which will reduce
the number of comparisons as the number of acceptable system calls
increases:</p>
<div class="highlight-default"><div class="highlight"><pre><span/>        if syscall_number &lt; 32:
                if bitmask_0 &amp; 1&lt;&lt;syscall_number: goto accept
        if syscall_number &lt; 64:
                syscall_number -= 32
                if bitmask_1 &amp; 1&lt;&lt;syscall_number: goto accept
        if syscall_number &lt; 96:
                syscall_number -= 64
                if bitmask_2 &amp; 1&lt;&lt;syscall_number: goto accept
        …
        if syscall_number &lt; 352:
                syscall_number -= 320
                if bitmask_10 &amp; 1&lt;&lt;syscall_number: goto accept
        return SECCOMP_RET_KILL
accept:
        return SECCOMP_RET_ACCEPT
</pre></div>
</div>
<p>(Some of the <span class="docutils literal"><span class="pre">if</span> <span class="pre">syscall_number</span> <span class="pre">&lt;</span> <span class="pre">N</span></span> blocks could be changed to
<span class="docutils literal"><span class="pre">syscall_number</span> <span class="pre">-=</span> <span class="pre">M</span></span> if their respective bitmask is <span class="docutils literal"><span class="pre">0</span></span>.)</p>
<p>Or maybe just a bloom filter instead of a series of bitmaps. I’ll have
to experiment.</p>
</div>
<div class="section" id="getting-a-larger-vessel">
<h3>Getting a larger vessel</h3>
<p>Containers, of course, are not just about restricting which system calls a
program is allowed to perform.  There are many things that can and must be
considered before even calling this a container runtime, or really consider
that this is in fact sandboxing anything.  Learning about namespaces,
cgroups and virtual machines are certainly on the list of things to learn
about.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>While the prototype I built isn’t practical and is of very limited use,
I find the idea of sandboxed programs without the need for specialized
runtimes very enticing.</p>
<p>Programs can be still packaged the way they have been packaged in the
past decades, without throwing away some of the sandboxing benefits that
containers provide, all the while not introducing new concepts for
users.</p>
<p>Of course, something like this – even if properly implemented – won’t
be a replacement for containers. Specially if one considers their role
as packets ready for deployment, which have a lot of value for devops
personnel.</p>
<p>The code, as usual, is open source, and available from <a class="reference external" href="https://github.com/lpereira/infect-to-protect">this Git
repository</a>.</p>
</div>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        
        <div class="tags">
            <span>
                Tags:
                <a href="tags/container.html">container</a>, <a href="tags/assembly.html">assembly</a>, <a href="tags/linux.html">linux</a>, <a href="tags/bpf.html">bpf</a></span>
        </div>
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>May 01, 2015</span>
        </div>
        <div class="section">
            <h1><a href="2015/05/01/initializing_a_heap_allocated_structure_in_c.html">Initializing a heap-allocated structure in C</a></h1>
<p>A pretty common mistake that happens when programming things in C is to
allocate less memory than necessary to hold a structure:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">foobar</span> <span class="o">*</span><span class="n">foobar</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foobaz</span><span class="p">));</span>
</pre></div>
</div>
<p>Note that <span class="docutils literal"><span class="pre">struct</span> <span class="pre">foobaz</span></span> is passed instead of <span class="docutils literal"><span class="pre">struct</span> <span class="pre">foobar</span></span>. We might get
lucky, and <span class="docutils literal"><span class="pre">sizeof(struct</span> <span class="pre">foobaz)</span></span> might be larger or equal than
<span class="docutils literal"><span class="pre">sizeof(struct</span> <span class="pre">foobar)</span></span>, but we might not.</p>
<p>There are lots of tools out there that will catch these mistakes: static
analyzers such as the one from Clang, and Memcheck from Valgrind are just
two examples that should be in any C programmer’s toolbelt.</p>
<p>Even then, people often resort to a a nicer idiom: <span class="docutils literal"><span class="pre">sizeof(*foobar)</span></span>,
which not only avoids these problems, but also is somewhat future-proof,
should the type of <span class="docutils literal"><span class="pre">foobar</span></span> change:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">foobar</span> <span class="o">*</span><span class="n">foobar</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">foobar</span><span class="p">));</span>
</pre></div>
</div>
<p>However, structures often have members that, if someone forgets to
initialize, will inflict some undefined behavior pains on the user.  The
things in the toolbelt might help here, as well as the <span class="docutils literal"><span class="pre">calloc()</span></span>
function, that, in addition to allocating memory, also zero-out the memory
block:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">foobar</span> <span class="o">*</span><span class="n">foobar</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">foobar</span><span class="p">));</span>
</pre></div>
</div>
<p>Not always one would want to zero out the whole memory chunk just to fill
out important fields afterwards, though.</p>
<p>Here’s a trick that’s being used in a yet-to-be-released project I’ve been
working on and off for the past few months. It starts by defining the
generic-chunk-of-memory equivalent of <span class="docutils literal"><span class="pre">strdup()</span></span>, <span class="docutils literal"><span class="pre">memdup()</span></span>:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="o">*</span><span class="nf">memdup</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">mem</span> <span class="o">?</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then a macro is defined:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="cp">#define ALLOC_INIT(type, ...)   \</span>
<span class="cp">        (type *)memdup((type[]){ __VA_ARGS__ }, sizeof(type))</span>
</pre></div>
</div>
<p>Then it is used like so:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">foobar</span> <span class="o">*</span><span class="n">foobar</span> <span class="o">=</span> <span class="n">ALLOC_INIT</span><span class="p">(</span><span class="k">struct</span> <span class="n">foobar</span><span class="p">,</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span>
        <span class="p">.</span><span class="n">other_field</span> <span class="o">=</span> <span class="n">other_value</span><span class="p">,</span>
        <span class="p">.</span><span class="n">yet_another_field</span> <span class="o">=</span> <span class="n">yet_another_value</span>
<span class="p">});</span>
</pre></div>
</div>
<p>The compiler will check if <span class="docutils literal"><span class="pre">field</span></span>, <span class="docutils literal"><span class="pre">other_field</span></span>, and <span class="docutils literal"><span class="pre">yet_another_field</span></span>
are actually part of <span class="docutils literal"><span class="pre">struct</span> <span class="pre">foobar</span></span>, and will abort compilation of a field
isn’t there or is of the wrong type.</p>
<p>The cast prevents the allocated memory block from being assigned to the wrong
type. (C will happily cast any <span class="docutils literal"><span class="pre">void*</span></span> to any other pointer.)</p>
<p>The amount of memory allocated will be exactly what’s needed by the
structure, and all fields that not mentioned will be initialized with their
default values as per <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">designated initializer rules</a>.</p>
<p>If <span class="docutils literal"><span class="pre">memdup()</span></span> is inlined, a good compiler will generate pretty good code,
that’s often byte-by-byte equivalent to allocating directly with
<span class="docutils literal"><span class="pre">malloc()</span></span>, initializing all the fields by hand, etc.</p>
<p>If GCC is being used, the <span class="docutils literal"><span class="pre">__auto_type</span></span> <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Typeof.html">extension</a> can be used, to avoid
having to type <span class="docutils literal"><span class="pre">struct</span> <span class="pre">foobar</span></span> twice. This has been suggested by <a class="reference external" href="https://plus.google.com/117917253135468806554/posts/DcBUyuicdLW">Thiago
Macieira</a>. I’d use this sparingly, though.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="n">__auto_type</span> <span class="n">foobar</span> <span class="o">=</span> <span class="n">ALLOC_INIT</span><span class="p">(</span><span class="k">struct</span> <span class="n">foobar</span><span class="p">,</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span>
        <span class="p">.</span><span class="n">other_field</span> <span class="o">=</span> <span class="n">other_value</span><span class="p">,</span>
        <span class="p">.</span><span class="n">yet_another_field</span> <span class="o">=</span> <span class="n">yet_another_value</span>
<span class="p">});</span>
</pre></div>
</div>
<p>It’s a pretty nice idiom that I haven’t seen anywhere else, and I’m blogging
here as the project I’m working on might not ever see the light of day and
it would be a shame if at least this didn’t become public.</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        
        <div class="tags">
            <span>
                Tags:
                <a href="tags/c.html">C</a>, <a href="tags/programming.html">programming</a>, <a href="tags/trick.html">trick</a></span>
        </div>
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>November 02, 2014</span>
        </div>
        <div class="section">
            <h1><a href="2014/11/02/hybrid_c_pascal_strings.html">Hybrid C/Pascal Strings</a></h1>
<p>I’ve been thinking for a while on how to reduce the overhead in <a class="reference external" href="http://lwan.ws">Lwan</a>‘s
string buffer, when the strings are small. There are a number of
ways of accomplishing this.</p>
<p>A somewhat common way is what <span class="docutils literal"><span class="pre">std::string</span></span> does: it reuses the bits
reserved for <cite>effective string length</cite>, <cite>allocated buffer size</cite>, and
<cite>pointer to buffer</cite> to store the string contents inline.</p>
<p>A <a class="reference external" href="http://tulrich.com/rants-2009.html#d2009-01-03T00:00:00Z">clever improvement</a> is, when the string is small, to turn the
<cite>effective string length</cite> counter to a <cite>bytes remaining counter</cite>, and
put it after the buffer that’s storing the string; this way, when the
string is at full capacity, this serves as a <span class="docutils literal"><span class="pre">\0</span></span> terminator, which
is very useful for compatibility with C.  And, of course, as a result,
one more byte can be stored in that string.</p>
<p>Another common approach are the strings used in <a class="reference external" href="https://en.wikipedia.org/wiki/String_(computer_science)#Length-prefixed">Pascal</a>, where the first
byte tells the length of the string. This has the advantage of allowing
strings to contain <span class="docutils literal"><span class="pre">\0</span></span>, but the disadvantage of limiting the maximum
size of the string. If someone were to implement this in C, the
advantage would turn into a disadvantage, as most string-handling
routines present in the standard library would be then rendered useless.</p>
<p>Or would it?</p>
<p>I’m sure I’m not the first person to come up with the idea of having a
C/Pascal String hybrid.  But at least the <a class="reference external" href="https://en.wikipedia.org/wiki/String_(computer_science)">Wikipedia</a> article on
Strings doesn’t seem to mention this variant I just came up with:</p>
<ul class="simple">
<li>Keep the <span class="docutils literal"><span class="pre">\0</span></span> to terminate the string. This helps reusing the
string handling routines from the C standard library, which are usually
very fast, hand-tuned functions</li>
<li>The first byte tells the size, not in bytes, but in 8-byte blocks.
To calculate the string length, one just jumps that amount of 8-byte
blocks and find the position of the <span class="docutils literal"><span class="pre">\0</span></span> terminator.</li>
<li>Larger blocks could be considered if <a class="reference external" href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> instructions were available.</li>
</ul>
<p>With 8-byte blocks, this can yield strings up to 2KiB of size (256 *
8), with an overhead of only two bytes, while retaining compatibility
with C strings.  With SIMD, the maximum string size could be easily
doubled or quadrupled.</p>
<p>Of course, this isn’t actually an improvement on the kind of small
string optimization performed by <span class="docutils literal"><span class="pre">std::string</span></span>, so I’m not yet
convinced this is the way to go. This is one of the reasons I haven’t
yet implemented this, but I might use the fact that I’m currently
enjoying some vacation time and write a prototype.</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        
        <div class="tags">
            <span>
                Tags:
                <a href="tags/c.html">C</a>, <a href="tags/trick.html">trick</a>, <a href="tags/optimization.html">optimization</a>, <a href="tags/programming.html">programming</a></span>
        </div>
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>October 06, 2014</span>
        </div>
        <div class="section">
            <h1><a href="2014/10/06/life_of_a_http_request.html">Life of a HTTP request, as seen by my toy web server</a></h1>
<p>When learning a new programming language, I tend to write two things with
it: a language interpreter (usually a FORTH-like language or Brainfuck if
I’m feeling lazy), and a HTTP server.  Sometimes, just as a challenge or a
way to quench my boredom, I do this even though I’ve been working with a
particular language for some time, as is the case with C.</p>
<p>None of these projects I’ve written over the years have been as complex as
<a class="reference external" href="http://lwan.ws">Lwan</a> ended up being: most of them were nothing but weekend hacks and were
never able to hold my attention for more than a few dozen hours.</p>
<p>It’s to be expected, then, that I might have a thing or two to say about it.
In fact, I’ve been <a class="reference external" href="http://tia.mat.br/blog/html/tags/lwan.html">doing this in homeopathic doses</a> over the almost two years
since I’ve started the project.  Never actually connected all the dots,
leaving out important details.</p>
<p>This article is an attempt to describe, from the perspective of Lwan, the
life of a HTTP request — from the socket being accepted to the response
being sent — and explaining details and reasoning behind the implementation.</p>
<div class="section" id="creating-the-listening-socket-accepting-connections">
<h2>Creating the listening socket &amp; accepting connections</h2>
<p>There’s nothing really special here: sockets are either created using the
<a class="reference external" href="http://linux.die.net/man/2/socket">standard POSIX stuff</a>, or are passed down from <a class="reference external" href="http://0pointer.net/blog/projects/socket-activation.html">systemd</a>.  In either case, TCP
<a class="reference external" href="http://lwn.net/Articles/508865/">Fastopen</a> and <a class="reference external" href="http://linux.die.net/man/7/tcp#TCP_QUICKACK">Quickack</a> are enabled, in addition to socket lingering.  The
socket is left in its default, blocking mode. The <a class="reference external" href="http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/023/2333/2333s2.html">listen() backlog</a> is the
maximum allowed by the system.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">int</span>
<span class="nf">_get_backlog_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef SOMAXCONN</span>
    <span class="kt">int</span> <span class="n">backlog</span> <span class="o">=</span> <span class="n">SOMAXCONN</span><span class="p">;</span>
<span class="cp">#else</span>
    <span class="kt">int</span> <span class="n">backlog</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">somaxconn</span><span class="p">;</span>

    <span class="n">somaxconn</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"/proc/sys/net/core/somaxconn"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">somaxconn</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fscanf</span><span class="p">(</span><span class="n">somaxconn</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">backlog</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">fclose</span><span class="p">(</span><span class="n">somaxconn</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">backlog</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It’s a blocking file descriptor since the main thread (responsible for
accepting all the sockets and scheduling clients) blocks on a call to
<a class="reference external" href="http://linux.die.net/man/2/accept4">accept4()</a> instead of something like <a class="reference external" href="http://linux.die.net/man/4/epoll">Epoll</a>.  This <a class="reference external" href="http://linux.die.net/man/2/accept">accept()</a> variant is
Linux-only and, among other things, lets one specify flags in sockets
without requiring an additional round trip to the kernel; the only flag that
interests Lwan is <span class="docutils literal"><span class="pre">SOCK_NONBLOCK</span></span>.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="kt">void</span>
<span class="nf">lwan_main_loop</span><span class="p">(</span><span class="n">lwan_t</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">setjmp</span><span class="p">(</span><span class="n">cleanup_jmp_buf</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">_signal_handler</span><span class="p">);</span>

    <span class="n">lwan_status_info</span><span class="p">(</span><span class="s">"Ready to serve"</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">client_fd</span> <span class="o">=</span> <span class="n">accept4</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">main_socket</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                                <span class="n">SOCK_NONBLOCK</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">client_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">lwan_status_perror</span><span class="p">(</span><span class="s">"accept"</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">_schedule_client</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">client_fd</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>File descriptor limits are raised to the <a class="reference external" href="https://github.com/lpereira/lwan/blob/e660ab753bfc83eb428c5b7de98bd40341589614/common/lwan.c#L415-L432">maximum allowed by system
settings</a> — at which time, Lwan pre-allocates an array of structures to hold
connection state for all possible file descriptors.</p>
</div>
<div class="section" id="scheduling-connection">
<h2>Scheduling connection</h2>
<p>In order to multiplex connections, Lwan spawns one thread per logical CPU,
and uses Epoll to determine which socket is ready to be written to or read
from.  Once a connection is scheduled to one of these threads, it stays
there until it is explicitly closed or a timeout occurs.</p>
<p>All threads share the preallocated connection array, and there are no
explicit locks.  The index to this array is the connection file descriptor,
which makes lookup very quick. This exploits the notion that file
descriptors are always allocated from the lowest possible number.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">lwan_connection_t_</span> <span class="p">{</span>
    <span class="cm">/* This structure is exactly 32-bytes on x86-64. If it is</span>
<span class="cm">     * changed, make sure the scheduler (lwan.c) is updated as</span>
<span class="cm">     * well. */</span>
    <span class="n">lwan_connection_flags_t</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time_to_die</span><span class="p">;</span> <span class="cm">/* In seconds since DQ epoch */</span>
    <span class="n">coro_t</span> <span class="o">*</span><span class="n">coro</span><span class="p">;</span>
    <span class="n">lwan_thread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>           <span class="cm">/* For death queue */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Since this structure is quite small, this leads to a form of implicit
lock called <a class="reference external" href="https://en.wikipedia.org/wiki/False_sharing">false sharing</a>, which is solved with a scheduler that is
aware of that problem and groups two connection structures per cache
line.  It’s simpler than it sounds:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="kr">thread</span> <span class="o">=</span> <span class="p">((</span><span class="n">fd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_threads</span><span class="p">;</span>
</pre></div>
</div>
<p>A <a class="reference external" href="https://en.wikipedia.org/wiki/Round-robin_scheduling">round robin scheduler</a> is used on other architectures.</p>
<p>An interesting curiosity about the connection structure is that it doesn’t
store the file descriptor: pointer arithmetic is performed to obtain it, as
the the base address for the connection array is known.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="n">ALWAYS_INLINE</span> <span class="kt">int</span>
<span class="nf">lwan_connection_get_fd</span><span class="p">(</span><span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">ptrdiff_t</span><span class="p">)(</span><span class="n">conn</span> <span class="o">-</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">lwan</span><span class="o">-&gt;</span><span class="n">conns</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After a thread has been chosen by the scheduler, the file descriptor number
is sent to a <a class="reference external" href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix domain socket</a> created with <a class="reference external" href="http://linux.die.net/man/2/socketpair">socketpair()</a> to that particular
thread’s Epoll. This part used to use <a class="reference external" href="http://linux.die.net/man/2/epoll_ctl">epoll_ctl()</a> directly — which, although
threadsafe, had a problem: <a class="reference external" href="http://linux.die.net/man/2/epoll_wait">epoll_wait()</a> will never timeout on a socket if
nothing was read from it previously. By writing to that socketpair, Epoll
awakens, the file descriptor is added to it, and that thread’s death queue
can handle the timeout by itself.</p>
<p>The sole purpose of each thread is to react to Epoll events, such as:</p>
<ul class="simple">
<li>Timeouts (in which case the death queue iterates, potentially
terminating connections);</li>
<li>Epoll errors (in which case the thread finishes gracefully);</li>
<li>Readiness events (can read, can write);</li>
<li>Connection hung up.</li>
</ul>
<p>Epoll events are used as signals to create, destroy, resume, and reset
coroutines: there’s one for each connection, and they’re used both as
lightweight threads and as resource management facilities.</p>
</div>
<div class="section" id="coroutines">
<h2>Coroutines</h2>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Coroutine">Coroutines</a> provides a reasonably simple model for asynchronous I/O handling
that’s less convoluted than the dreaded <a class="reference external" href="https://developer.gnome.org/gio/stable/">callback idiom</a> prevalent in C. They
also require a lot less stack space than a thread and their creation is
pretty efficient: essentially just a call to <span class="docutils literal"><span class="pre">malloc()</span></span>.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="n">coro_t</span> <span class="o">*</span>
<span class="nf">coro_new</span><span class="p">(</span><span class="n">coro_switcher_t</span> <span class="o">*</span><span class="n">switcher</span><span class="p">,</span>
         <span class="n">coro_function_t</span> <span class="n">function</span><span class="p">,</span>
         <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">coro_t</span> <span class="o">*</span><span class="n">coro</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">coro</span><span class="p">)</span> <span class="o">+</span> <span class="n">CORO_STACK_MIN</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">coro</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">coro</span><span class="o">-&gt;</span><span class="n">switcher</span> <span class="o">=</span> <span class="n">switcher</span><span class="p">;</span>
    <span class="n">coro</span><span class="o">-&gt;</span><span class="n">defer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* coro_reset() is just a few assignments on x86-64 */</span>
    <span class="n">coro_reset</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

<span class="cp">#if !defined(NDEBUG) &amp;&amp; defined(USE_VALGRIND)</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">stack</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">coro</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">coro</span><span class="o">-&gt;</span><span class="n">vg_stack_id</span> <span class="o">=</span> <span class="n">VALGRIND_STACK_REGISTER</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span>
                                   <span class="n">stack</span> <span class="o">+</span> <span class="n">CORO_STACK_MIN</span><span class="p">);</span>
<span class="cp">#endif</span>

    <span class="k">return</span> <span class="n">coro</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Request handlers can be written using an API that’s completely synchronous
on the surface but behind the curtains, I/O happens in the background
(client sockets are non-blocking) and control is given to the next coroutine
as commanded by each thread’s loop.</p>
<p>Execution resumes where the coroutine left off. This saves a lot of code,
not only making things easier to reason about, but also simplifying resource
management by having a single cleanup point.</p>
<p>To provide a synchronous-looking API, Lwan provides a few wrappers for
common operations, such as <a class="reference external" href="http://linux.die.net/man/2/writev">writev()</a> or <a class="reference external" href="http://linux.die.net/man/2/sendfile">sendfile()</a>. Unlike the functions
these wrap, they return no error:</p>
<ul class="simple">
<li>On success, the same return code is returned;</li>
<li>Recoverable errors (such as <span class="docutils literal"><span class="pre">EINTR</span></span>) are handled by trying them again a
few times before giving up;</li>
<li>When giving up, or on unrecoverable errors, coroutines are aborted.</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="kt">int</span>
<span class="nf">lwan_openat</span><span class="p">(</span><span class="n">lwan_request_t</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span>
            <span class="kt">int</span> <span class="n">dirfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">tries</span> <span class="o">=</span> <span class="n">max_failed_tries</span><span class="p">;</span> <span class="n">tries</span><span class="p">;</span> <span class="n">tries</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">openat</span><span class="p">(</span><span class="n">dirfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/*</span>
<span class="cm">             * close() will be called as soon as the</span>
<span class="cm">             * coroutine ends</span>
<span class="cm">             */</span>
            <span class="n">coro_defer</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">coro</span><span class="p">,</span> <span class="n">CORO_DEFER</span><span class="p">(</span><span class="n">close</span><span class="p">),</span>
                       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">intptr_t</span><span class="p">)</span><span class="n">fd</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">EINTR</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">EMFILE</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">ENFILE</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">ENOMEM</span><span class="p">:</span>
            <span class="n">coro_yield</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">coro</span><span class="p">,</span>
                       <span class="n">CONN_CORO_MAY_RESUME</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">errno</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When a coroutine is destroyed, user-defined callbacks are executed. These
include callbacks set by the wrapper functions, to close files, free memory,
and perform many other cleanup tasks. This ensures resources are released
regardless if the coroutine ended normally or an unrecoverable error has
been detected.</p>
<div class="figure align-center" id="id2">
<img alt="coroutines" src="https://i.imgur.com/7sHL2ZH.png"/>
<p class="caption"><span class="caption-text">Diagram of main loop plus two coroutines</span></p>
</div>
<p>On supported architectures, coroutine context switching is almost as cheap
as a function call.  This is possible because hand-written assembly routines
are used, which only performs the essential register exchange, as mandated
by the <a class="reference external" href="http://www.x86-64.org/documentation/abi.pdf">ABI</a>.  There is still some work to do in order to speed up this;
tricks used by <a class="reference external" href="http://byuu.org/programming/libco/">libco</a>, for instance, might be used in the future to reduce
some of the overhead.</p>
<p>On every other architecture, <a class="reference external" href="http://linux.die.net/man/3/swapcontext">swapcontext()</a> is used and this usually incurs
in saving and restoring the signal mask, in addition to swapping every
register (including those not required by the calling convention); this
might change to setjmp() in the future to avoid at least the two system
calls.</p>
<p>Another use for coroutines in Lwan is inside the Mustache templating engine,
described in more depth below.</p>
</div>
<div class="section" id="reading-requests">
<h2>Reading requests</h2>
<p>The loop within each I/O thread is <a class="reference external" href="https://github.com/lpereira/lwan/blob/e660ab753bfc83eb428c5b7de98bd40341589614/common/lwan-thread.c#L278-L342">quite crude</a>.</p>
<p>Essentially, a coroutine will only be resumed for reading once per request:
once it yields, Epoll will only be interested in write events. Because of
this, reading a request uses a purpose-built <a class="reference external" href="https://github.com/lpereira/lwan/blob/e660ab753bfc83eb428c5b7de98bd40341589614/common/lwan-request.c#L459-L514">read() wrapper</a> that tricks the
scheduler to still be interested in read events, unless the request has been
fully received (by ending with the “␍␊␍␊” separator).</p>
<p>As soon as the whole request has been received, it is then parsed and acted
upon.</p>
</div>
<div class="section" id="parsing-request">
<h2>Parsing request</h2>
<p>Request parsing in Lwan is quite efficient: there are no copies, no memory
allocations from the heap.  The buffer is modified in place by slicing and
storing pointers to stuff the server might be interested in.  Parsing of
HTTP request headers is delayed until needed (and they might not be needed).</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">lwan_request_parse_t_</span> <span class="p">{</span>
    <span class="n">lwan_value_t</span> <span class="n">buffer</span><span class="p">;</span>            <span class="cm">/* The whole buffer */</span>
    <span class="n">lwan_value_t</span> <span class="n">query_string</span><span class="p">;</span>      <span class="cm">/* Stuff after URLs ? */</span>
    <span class="n">lwan_value_t</span> <span class="n">if_modified_since</span><span class="p">;</span> <span class="cm">/* If-Modified-Since: */</span>
    <span class="n">lwan_value_t</span> <span class="n">range</span><span class="p">;</span>             <span class="cm">/* Range: */</span>
    <span class="n">lwan_value_t</span> <span class="n">accept_encoding</span><span class="p">;</span>   <span class="cm">/* Accept-Encoding: */</span>
    <span class="n">lwan_value_t</span> <span class="n">fragment</span><span class="p">;</span>          <span class="cm">/* Stuff after URLs # */</span>
    <span class="n">lwan_value_t</span> <span class="n">content_length</span><span class="p">;</span>    <span class="cm">/* Content-Length: */</span>
    <span class="n">lwan_value_t</span> <span class="n">post_data</span><span class="p">;</span>         <span class="cm">/* POST data */</span>
    <span class="n">lwan_value_t</span> <span class="n">content_type</span><span class="p">;</span>      <span class="cm">/* Content-Type: */</span>
    <span class="n">lwan_value_t</span> <span class="n">authorization</span><span class="p">;</span>     <span class="cm">/* Authorization: */</span>
    <span class="kt">char</span> <span class="n">connection</span><span class="p">;</span>                <span class="cm">/* k=keep-alive, c=close */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Among other things, one that often receives comments is how headers are
parsed.  Two tricks are involved: avoiding <a class="reference external" href="https://en.wikipedia.org/wiki/Register_allocation#Spilling">spilling/filling registers</a> to
compare strings with <span class="docutils literal"><span class="pre">strncmp()</span></span>, and applying a heuristic to avoid
reading (and comparing) more than necessary.  Both tricks are intertwined
into a “string prefix switch”:</p>
<ul class="simple">
<li>Four bytes are read from memory, and are cast to a 32-bit integer pointer;</li>
<li>That pointer is then dereferenced;</li>
<li>A standard switch statement is used to perform cheap comparisons on a 32-bit
integer;</li>
<li>When a header prefix is matched, a simple heuristic of finding the
separating colon and space character where they’re supposed to be is used.<ul>
<li>This might give false positives, although that’s very unlikely in practice.</li>
</ul>
</li>
</ul>
<p>Once the request has been parsed, it is time to look up what is going to
handle it.</p>
</div>
<div class="section" id="looking-up-handler">
<h2>Looking up handler</h2>
<p>A <a class="reference external" href="https://en.wikipedia.org/wiki/Trie">prefix tree</a> is used to look up handlers. It is a modified trie data
structure that has only eight pointers per node, so that on x86-64, each
node fills one cache line exactly. This is achieved by hashing each
character used to build up a node by taking the 3 least significant bits.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">lwan_trie_node_t_</span> <span class="p">{</span>
    <span class="n">lwan_trie_node_t</span> <span class="o">*</span><span class="n">next</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="n">lwan_trie_leaf_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ref_count</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The canonical and naïve alternative to the hashed trie is having <a class="reference external" href="https://github.com/lpereira/lwan/blob/b2c9b37e63c7ffedfcbd00c25349ab9501dc4985/lwan-trie.c#L27-L31">256
pointers per node</a>, which puts too much virtual memory pressure: the approach
used in Lwan is a good compromise between keeping this pressure low and
implementation complexity.</p>
<p>Another alternative (which might be considered in the future) is to reduce
the amount of nodes by <a class="reference external" href="https://en.wikipedia.org/wiki/Trie#Compressing_tries">coalescing common prefixes</a>; this significantly
increases implementation complexity, though, but combined with the string
switch trick, this might yield a good performance boost.</p>
<p>Yet another technique investigated was to <a class="reference external" href="https://gist.github.com/lpereira/c744c08c74ca600e58ff">generate machine code to perform
lookup</a>: essentially turning a data structure into executable code. The idea
works but the instruction cache pressure isn’t worth the trouble. I’m still
partial to this solution, though, so I might revisit it later: <a class="reference external" href="http://www.varnish-cache.org">Varnish</a> does
something remotely similar with VCL and it seems to work, so this deserves a
little bit more research.</p>
<p>After a handler is found, a second round of parsing might happen. Each
handler contains a set of flags that signal if headers (which were sliced in
the request parsing stage) should be actually parsed. This include headers
such as Range, Accept-Encoding, If-Modified-Since, and authorization stuff.
Handlers that do not require parsing these headers will not trigger
potentially expensive string crunching.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">HANDLER_PARSE_QUERY_STRING</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">HANDLER_PARSE_IF_MODIFIED_SINCE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">HANDLER_PARSE_RANGE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">HANDLER_PARSE_ACCEPT_ENCODING</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">HANDLER_PARSE_POST_DATA</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">HANDLER_MUST_AUTHORIZE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">HANDLER_REMOVE_LEADING_SLASH</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">,</span>

    <span class="n">HANDLER_PARSE_MASK</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span>
<span class="p">}</span> <span class="n">lwan_handler_flags_t</span><span class="p">;</span>
</pre></div>
</div>
<p>To reduce the amount of boilerplate necessary to declare a handler, there’s
a shortcut that parses almost everything; these are the “request handlers”,
such as the “Hello world handler” example shown below.</p>
<p>Modules, on the other hand, provide much more fine-grained control of how
the request will be handled; an example is the static file serving feature,
also discussed further down.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">const</span> <span class="n">lwan_module_t</span> <span class="n">serve_files</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"serve_files"</span><span class="p">,</span>
    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">serve_files_init</span><span class="p">,</span>
    <span class="p">.</span><span class="n">init_from_hash</span> <span class="o">=</span> <span class="n">serve_files_init_from_hash</span><span class="p">,</span>
    <span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">serve_files_shutdown</span><span class="p">,</span>
    <span class="p">.</span><span class="n">handle</span> <span class="o">=</span> <span class="n">serve_files_handle_cb</span><span class="p">,</span>
    <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">HANDLER_REMOVE_LEADING_SLASH</span>
        <span class="o">|</span> <span class="n">HANDLER_PARSE_IF_MODIFIED_SINCE</span>
        <span class="o">|</span> <span class="n">HANDLER_PARSE_RANGE</span>
        <span class="o">|</span> <span class="n">HANDLER_PARSE_ACCEPT_ENCODING</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="section" id="hello-world-handler">
<h3>Hello world handler</h3>
<p>The simplest handler possible is a “Hello, World!“. This tests the raw
read-parse-write capacity of Lwan, without requiring more system calls than
absolutely necessary.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="n">lwan_http_status_t</span>
<span class="nf">hello_world</span><span class="p">(</span><span class="n">lwan_request_t</span> <span class="o">*</span><span class="n">request</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">)),</span>
            <span class="n">lwan_response_t</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">)))</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hello_world</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="p">;</span>

    <span class="n">response</span><span class="o">-&gt;</span><span class="n">mime_type</span> <span class="o">=</span> <span class="s">"text/plain"</span><span class="p">;</span>
    <span class="n">strbuf_set_static</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">hello_world</span><span class="p">,</span>
                      <span class="n">strlen</span><span class="p">(</span><span class="n">hello_world</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">HTTP_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These simple handlers will use whatever is inside their respective string
buffers (which is an array that grows automatically when needed, with some
bookkeeping attached). In the “Hello, World!” case, however, the string
buffer acts merely as a pointer to some read-only string stored in the text
section; this simplifies the interface a little bit, while avoiding string
copies and unneeded heap allocations.</p>
</div>
<div class="section" id="chunked-encoding-and-server-sent-events">
<h3>Chunked encoding and Server-sent events</h3>
<p>Supported also is the <a class="reference external" href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding">Chunked Encoding</a>. Using it is very simple: just set
the response MIME Type, fill the string buffer, and call
<span class="docutils literal"><span class="pre">lwan_response_send_chunk()</span></span>. From this point on, the response headers will be
sent alongside the first chunk, the string buffer will be cleared, and the
coroutine will yield. To send the next chunk, just fill the string buffer
again and send another chunk, until your handler is complete.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="n">lwan_http_status_t</span>
<span class="nf">test_chunked_encoding</span><span class="p">(</span><span class="n">lwan_request_t</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span>
            <span class="n">lwan_response_t</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">)))</span>
<span class="p">{</span>
    <span class="n">response</span><span class="o">-&gt;</span><span class="n">mime_type</span> <span class="o">=</span> <span class="s">"text/plain"</span><span class="p">;</span>

    <span class="n">strbuf_printf</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"First chunk</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">lwan_response_send_chunk</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">strbuf_printf</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"*Chunk #%d*</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">lwan_response_send_chunk</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">strbuf_printf</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"Last chunk</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">lwan_response_send_chunk</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">HTTP_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The same general idea is used by <a class="reference external" href="https://en.wikipedia.org/wiki/Server-sent_events">Server-sent events</a>; however, one uses
<span class="docutils literal"><span class="pre">lwan_response_send_event()</span></span>, and passes the event name as well.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="n">lwan_http_status_t</span>
<span class="nf">test_server_sent_event</span><span class="p">(</span><span class="n">lwan_request_t</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span>
            <span class="n">lwan_response_t</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">)))</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">strbuf_printf</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"{n: %d}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">lwan_response_send_event</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="s">"currval"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">HTTP_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation inside Lwan is as straightforward as it looks: coroutines
saved the day.</p>
</div>
<div class="section" id="file-serving-module">
<h3>File serving module</h3>
<p>Since files can be served using the <span class="docutils literal"><span class="pre">sendfile()</span></span> system call, the kind of
handlers used by Hello World can’t be used: responses are sent using
<span class="docutils literal"><span class="pre">writev()</span></span> to send both response headers and contents in one kernel roundtrip.
Because of this, there’s a different kind of handler that gives more control
as to how the response is sent: the (for the lack of a better name)
streaming handlers. Streaming handlers are expected to send the whole
response themselves.</p>
<p>To convert a “normal” handler into a streaming handler is simple: just set a
few pointers in the “normal” handler and return. With the exception of
producing error responses automatically — streaming handlers function
exactly the same as a “normal” handler that does not send the response
headers automatically.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">static</span> <span class="n">lwan_http_status_t</span>
<span class="nf">serve_files_handle_cb</span><span class="p">(</span><span class="n">lwan_request_t</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span>
                      <span class="n">lwan_response_t</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lwan_http_status_t</span> <span class="n">return_status</span> <span class="o">=</span> <span class="n">HTTP_NOT_FOUND</span><span class="p">;</span>
    <span class="n">serve_files_priv_t</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">cache_entry_t</span> <span class="o">*</span><span class="n">ce</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">return_status</span> <span class="o">=</span> <span class="n">HTTP_INTERNAL_ERROR</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ce</span> <span class="o">=</span> <span class="n">cache_coro_get_and_ref_entry</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">,</span>
                <span class="n">request</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">coro</span><span class="p">,</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">url</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">ce</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">file_cache_entry_t</span> <span class="o">*</span><span class="n">fce</span> <span class="o">=</span> <span class="p">(</span><span class="n">file_cache_entry_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ce</span><span class="p">;</span>
        <span class="n">response</span><span class="o">-&gt;</span><span class="n">mime_type</span> <span class="o">=</span> <span class="n">fce</span><span class="o">-&gt;</span><span class="n">mime_type</span><span class="p">;</span>
        <span class="n">response</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">fce</span><span class="o">-&gt;</span><span class="n">funcs</span><span class="o">-&gt;</span><span class="n">serve</span><span class="p">;</span>
        <span class="n">response</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">ce</span><span class="p">;</span>
        <span class="n">response</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">.</span><span class="n">priv</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">HTTP_OK</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">fail</span><span class="p">:</span>
    <span class="n">response</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">return_status</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To avoid having to obtain information about a file for every request, this
information is cached for a few seconds. The caching mechanism itself is
discussed in detail further down.</p>
<p>While caching file information, the file size is considered while picking
the way to serve it.  Files larger than 16KiB are served with <span class="docutils literal"><span class="pre">sendfile()</span></span>
to allow zero (or fewer) copy transfers, and smaller files are mapped in
memory using <span class="docutils literal"><span class="pre">mmap()</span></span>.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">const</span> <span class="n">cache_funcs_t</span> <span class="o">*</span>
<span class="nf">_get_funcs</span><span class="p">(</span><span class="n">serve_files_priv_t</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
           <span class="kt">char</span> <span class="o">*</span><span class="n">full_path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">index_html_path_buf</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">index_html_path</span> <span class="o">=</span> <span class="n">index_html_path_buf</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">st_mode</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* It is a directory. It might be the root directory</span>
<span class="cm">         * (empty key), or something else.  In either case,</span>
<span class="cm">         * tack priv-&gt;index_html to the path.  */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">key</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">index_html_path</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">index_html</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* Redirect /path to /path/. This is to help</span>
<span class="cm">             * cases where there's something like &lt;img</span>
<span class="cm">             * src="../foo.png"&gt;, so that actually</span>
<span class="cm">             * /path/../foo.png is served instead of</span>
<span class="cm">             * /path../foo.png.  */</span>
            <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key_end</span> <span class="o">=</span> <span class="n">rawmemchr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">key_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">'/'</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">&amp;</span><span class="n">redir_funcs</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">snprintf</span><span class="p">(</span><span class="n">index_html_path</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">,</span>
                                  <span class="s">"%s%s"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
                                  <span class="n">priv</span><span class="o">-&gt;</span><span class="n">index_html</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* See if it exists. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fstatat</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">index_html_path</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">ENOENT</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

            <span class="cm">/* If it doesn't, generate a directory list. */</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">dirlist_funcs</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* If it does, we want its full path. */</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">path_len</span> <span class="o">+</span> <span class="mi">1</span> <span class="cm">/* slash */</span> <span class="o">+</span>
                     <span class="n">strlen</span><span class="p">(</span><span class="n">index_html_path</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">PATH_MAX</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="n">full_path</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">path_len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'/'</span><span class="p">;</span>
        <span class="n">strncpy</span><span class="p">(</span><span class="n">full_path</span> <span class="o">+</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">path_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">index_html_path</span><span class="p">,</span>
                <span class="n">PATH_MAX</span> <span class="o">-</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">path_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* It's not a directory: choose the fastest way to serve the</span>
<span class="cm">     * file judging by its size.  */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">st_size</span> <span class="o">&lt;</span> <span class="mi">16384</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="n">mmap_funcs</span><span class="p">;</span>

    <span class="k">return</span> <span class="o">&amp;</span><span class="n">sendfile_funcs</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Small files may also be compressed, unless compressed data ends up being
larger than the original data. Especially if the response header is
considered. Because of this, small files are only compressed if it’s worth
the trouble. The 16KiB threshold has been chosen empirically: larger values
did not yield substantial performance gains compared to using <span class="docutils literal"><span class="pre">sendfile()</span></span>.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">void</span>
<span class="nf">_compress_cached_entry</span><span class="p">(</span><span class="n">mmap_cache_data_t</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">deflated_header_size</span> <span class="o">=</span>
            <span class="k">sizeof</span><span class="p">(</span><span class="s">"Content-Encoding: deflate"</span><span class="p">);</span>

    <span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">compressBound</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">uncompressed</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>

    <span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="o">!</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">contents</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">error_zero_out</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">contents</span><span class="p">,</span>
                       <span class="o">&amp;</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
                       <span class="n">md</span><span class="o">-&gt;</span><span class="n">uncompressed</span><span class="p">.</span><span class="n">contents</span><span class="p">,</span>
                       <span class="n">md</span><span class="o">-&gt;</span><span class="n">uncompressed</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">Z_OK</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">error_free_compressed</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">total_size</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span>
            <span class="o">+</span> <span class="n">deflated_header_size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">total_size</span> <span class="o">&lt;</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">uncompressed</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

<span class="nl">error_free_compressed</span><span class="p">:</span>
    <span class="n">free</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">contents</span><span class="p">);</span>
    <span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">error_zero_out</span><span class="p">:</span>
    <span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For directories, the template engine is used to create the listing. The
contents are cached using the same mechanism files are. Templating is
discussed below.</p>
<p>An interesting optimization is that, to obtain the full path, a special
version of <a class="reference external" href="http://linux.die.net/man/3/realpath">realpath()</a>, forked from the GNU libc implementation, is used.
This version uses the <a class="reference external" href="http://lwn.net/Articles/164887/">lighter “-at()” variants</a> of system calls that operates
on paths; they do not need to perform path-to-inode conversion for the whole
path, only from a path pointed to by a directory file descriptor.</p>
<p>The file server is a module. It is a simple way to keep per instance state,
such as the file descriptor for the root directory, the directory list
template, and a few other things.</p>
</div>
</div>
<div class="section" id="mustache-templating-engine">
<h2>Mustache templating engine</h2>
<p>Not all features from <a class="reference external" href="http://mustache.github.io/">Mustache</a> are implemented: some are pretty much only
practical if using a language that’s more expressive than C. However,
without requiring (too much) boilerplate, a substantial amount of its
specification is implemented, in a pretty efficient way, and suits all Lwan
uses pretty well. (Being performant <a class="reference external" href="http://blog.codinghorror.com/the-sad-tragedy-of-micro-optimization-theater/">might not matter</a>, though, but I’m
here to have fun, not solve problems.)</p>
<p>Not everything is implemented exactly as in the standard, though: that’s
mostly for laziness reasons, but the non-dynamic nature of C would make
certain things needlessly difficult to implement and use, anyway. The
templating engine supports the basic stuff. In no particular order:</p>
<ul class="simple">
<li>Variables of different types;</li>
<li>Checking the emptiness of variables;</li>
<li>Iteration on lists (and any kind of sequences);</li>
<li>Partials;</li>
<li>Comments;</li>
<li>Inverted sections.</li>
</ul>
<p>Setting the delimiters, triple mustaches (for escaping HTML output),
ampersand to unescape strings — and possibly other things — are not
implemented, but could be implemented with relatively minimal effort. String
escaping is supported by using a special string type and should <a class="reference external" href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content">conform to
best practices</a>.</p>
<p>Templates are pre-processed. This pre-processing step uses a state machine
parser to break down its text representation into a series of actions that
can be performed by the engine very efficiently. Actions include things like
“append string”, “append variable”, “start iteration”, and so on.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">TPL_ACTION_APPEND</span><span class="p">,</span>
    <span class="n">TPL_ACTION_APPEND_CHAR</span><span class="p">,</span>
    <span class="n">TPL_ACTION_VARIABLE</span><span class="p">,</span>
    <span class="n">TPL_ACTION_LIST_START_ITER</span><span class="p">,</span>
    <span class="n">TPL_ACTION_LIST_END_ITER</span><span class="p">,</span>
    <span class="n">TPL_ACTION_IF_VARIABLE_NOT_EMPTY</span><span class="p">,</span>
    <span class="n">TPL_ACTION_END_IF_VARIABLE_NOT_EMPTY</span><span class="p">,</span>
    <span class="n">TPL_ACTION_APPLY_TPL</span><span class="p">,</span>
    <span class="n">TPL_ACTION_LAST</span>
<span class="p">}</span> <span class="n">lwan_tpl_action_t</span><span class="p">;</span>
</pre></div>
</div>
<p>For instance, a stack of hash tables is used during this pre-processing step
to act as a symbol table; this table can be thrown away as soon as the
pre-processing step is complete, as all variables have been resolved and a
much more efficient value lookup mechanism can be used instead.</p>
<div class="section" id="obtaining-variables">
<h3>Obtaining variables</h3>
<p>To use the templating mechanism, one should have a structure for each
template. Structures are cheap and provide some welcome compile-time type
checking that wouldn’t be possible otherwise.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">typedef</span> <span class="k">struct</span> <span class="n">hello_t</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In addition to a structure, due to the lack of introspection in C, an array
of variable descriptors should be declared. A variable descriptor contains a
string representation of a variable name, the offset in bytes of that
variable within the structure, and pointers to functions to test the
emptiness of that kind of variable and to append the variable to the string
buffer; macros help alleviate boilerplate headaches.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="n">lwan_var_descriptor_t</span> <span class="n">hello_descriptor</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">TPL_VAR_STR</span><span class="p">(</span><span class="n">hello_t</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span>
  <span class="n">TPL_VAR_INT</span><span class="p">(</span><span class="n">hello_t</span><span class="p">,</span> <span class="n">age</span><span class="p">),</span>
  <span class="n">TPL_VAR_SENTINEL</span>
<span class="p">};</span>

<span class="n">lwan_tpl_t</span> <span class="o">*</span><span class="n">hello</span> <span class="o">=</span> <span class="n">lwan_tpl_compile</span><span class="p">(</span><span class="s">"hello.tpl"</span><span class="p">,</span>
                                     <span class="n">hello_descriptor</span><span class="p">);</span>
</pre></div>
</div>
<p>A structure containing all the variables can then be supplied by some sort
of database layer, caching layer, or be declared on the spot: compound
literals with designated initializers make this use case pretty
straightforward.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="n">strbuf_t</span> <span class="o">*</span><span class="n">rendered</span> <span class="o">=</span> <span class="n">lwan_tpl_render</span><span class="p">(</span><span class="n">hello</span><span class="p">,</span> <span class="p">(</span><span class="n">hello_t</span><span class="p">[])</span> <span class="p">{{</span>
  <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"World"</span><span class="p">,</span>
  <span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">42</span>
<span class="p">}});</span>

<span class="cm">/* Do something with `rendered` */</span>

<span class="n">strbuf_free</span><span class="p">(</span><span class="n">rendered</span><span class="p">);</span>
</pre></div>
</div>
<p>Appending a variable is then just the matter of calling the
appropriate callback function (conveniently in the descriptor), passing the
base address of that structure plus the byte offset within it.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">void</span>
<span class="nf">append_var_to_strbuf</span><span class="p">(</span><span class="n">lwan_tpl_chunk_t</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">variables</span><span class="p">,</span>
                     <span class="n">strbuf_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lwan_var_descriptor_t</span> <span class="o">*</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">descriptor</span><span class="p">))</span>
        <span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">append_to_strbuf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span>
                      <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">variables</span> <span class="o">+</span> <span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sequences">
<h3>Sequences</h3>
<p>To avoid creating potentially lots of small, temporary objects, for lists
and sequences a coroutine is created and is used as a makeshift generator
function. Another option was to implement iterators using a structure to
hold state plus a few callbacks — I gave up while imagining the amount of
boilerplate necessary. A function is simple to write on the other hand, and
can include initialization, iteration, and cleanup.</p>
<div class="figure align-center" id="id3">
<img alt="sequences" src="https://i.imgur.com/VsAfnsC.png"/>
<p class="caption"><span class="caption-text">How sequences are evaluated by the templating engine</span></p>
</div>
<p>The only user of sequences in templates within Lwan is the file listing
feature in the file serving module. The generator function is pretty
straightforward, and is responsible for opening the directory, obtaining
information for each entry, and then closing the directory. A shorter
version of it is described in the original blog post about <a class="reference external" href="http://tia.mat.br/blog/html/2013/09/26/implementing_sequences_in_lwan_template_engine.html">sequences in the
templating engine</a>.</p>
</div>
</div>
<div class="section" id="caching">
<h2>Caching</h2>
<p>I’ve used and implemented a few caching infrastructures over the years, and
I believe that the one in Lwan is, so far, the simplest one I’ve used. Most
caches will require items to be created — and then added manually to the
cache. Not only clumsy, but could also lead to race conditions.</p>
<p>The one in Lwan knows how to create and destroy a cache entry: one just asks
the cache to obtain a value for a given key. If it’s not there, the entry is
created and returned. The lifetime of a cache entry is controlled
automatically, and a low priority thread kicks in every now and then to
prune old entries.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">cache_t</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">hash</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
        <span class="n">pthread_rwlock_t</span> <span class="n">lock</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">hash</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
        <span class="n">pthread_rwlock_t</span> <span class="n">lock</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">queue</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
        <span class="n">CreateEntryCallback</span> <span class="n">create_entry</span><span class="p">;</span>
        <span class="n">DestroyEntryCallback</span> <span class="n">destroy_entry</span><span class="p">;</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">cb</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">time_t</span> <span class="n">time_to_live</span><span class="p">;</span>
        <span class="kt">clockid_t</span> <span class="n">clock_id</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">settings</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">;</span>

<span class="cp">#ifndef NDEBUG</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">hits</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="n">misses</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="n">evicted</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">stats</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Unlike most caches, the one in Lwan isn’t limited by size: items stay in the
cache for a predetermined amount of time.</p>
<p>Cache entries are reference-counted, and they’re not automatically reaped if
something is holding on a reference: these items are marked as floating when
this happens, and the last one to give up the reference will also destroy
the entry.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">cache_entry_t</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">list_node</span> <span class="n">entries</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">refs</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">timespec</span> <span class="n">time_to_die</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">file_cache_entry_t_</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">cache_entry_t</span> <span class="n">base</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">string</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
        <span class="kt">time_t</span> <span class="n">integer</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">last_modified</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mime_type</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">cache_funcs_t</span> <span class="o">*</span><span class="n">funcs</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When used within a coroutine, two things can happen: ➀ the coroutine might
yield if the cache lock were to become contended and ➁ automatically
releasing a reference when a coroutine is destroyed.</p>
<p>In addition to floating entries, there are also temporary entries. The cache
uses read-write locks, but most of the time, locks are only obtained using
the “trylock” primitive: if a lock can’t be obtained for a reason, Lwan
tries to move on to something else. This could be attending to another
request (by yielding the coroutine), or merely returning an off-the-books
entry that will be destroyed as soon as its sole user releases its
reference. The difference to floating entries is merely an implementation
detail, so that an atomic decrement (and its accompanying memory barrier)
isn’t used.</p>
<p>The cache tries to avoid keeping the locks locked. As an example, while an
item is being created, no locks are held. This can, of course, lead to
multiple entries being created concurrently, but if caching would be useful
anyway, having a few temporary entries lying around isn’t a problem, as at
least one will be cached for future access.</p>
<p>As nice as the cache subsystem ended up being, there is a lot of room for
improvement.  Reducing the amount of concurrent reference counting is high
on the list.  Reducing the latency is also in consideration.  Making HTTP
responses cacheable without special code in the handler is there as well.</p>
</div>
<div class="section" id="keep-alive-connections-death-queue">
<h2>Keep-alive connections, death queue</h2>
<p>Connection lifetime is managed by a per-thread queue.</p>
<p>Each time a connection is scheduled to a certain thread, it is pushed to the
queue, and a time to die is set. When there are connections in this queue,
Epoll will timeout every second to iterate through it and kill connections
when their time has come. Timeouts are infinite when the queue is empty, to
avoid waking the process unnecessarily. Every time a coroutine is resumed,
the time to die is updated, and the connection is pushed to the end of the
queue.</p>
<p>Each death queue has its own epoch, which starts at zero and increments at
every timeout. Whenever the last connection is removed from a queue, the
epoch restarts. Keeping the epoch a small number will help shave a few bytes
from each connection in the future.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">death_queue_t</span> <span class="p">{</span>
    <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">conns</span><span class="p">;</span>
    <span class="n">lwan_connection_t</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">time</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">keep_alive_timeout</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The same timeout value is used for keep-alive connections and coroutines.
This ensures coroutines will not linger indefinitely when not performing any
kind of work.</p>
<p>The death queue is so important that almost a third of the connection
structure is dedicated to its existence. Three integers keep state for the
death queue: the time to die (as an unsigned int), and two integers as
pointers to a doubly linked list.</p>
<p>Integers were used instead of pointers in order to save memory. This was
possible since in reality they are indices to the connection array. A doubly
linked list was also chosen since removing a connection from the middle of
the queue should be efficient, as it is done very frequently to move the
entry to the end. The list is also circular, in order to avoid branching to
handle empty queue cases. Maintaining the queue inline with the connection
structures help reducing cache pressure.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">_death_queue_node_to_idx</span><span class="p">(</span>
            <span class="k">struct</span> <span class="n">death_queue_t</span> <span class="o">*</span><span class="n">dq</span><span class="p">,</span> <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">conn</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span> <span class="o">?</span>
            <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">ptrdiff_t</span><span class="p">)(</span><span class="n">conn</span> <span class="o">-</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">conns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="nf">_death_queue_idx_to_node</span><span class="p">(</span>
            <span class="k">struct</span> <span class="n">death_queue_t</span> <span class="o">*</span><span class="n">dq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">dq</span><span class="o">-&gt;</span><span class="nl">head</span> <span class="p">:</span> <span class="o">&amp;</span><span class="n">dq</span><span class="o">-&gt;</span><span class="n">conns</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_death_queue_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">death_queue_t</span> <span class="o">*</span><span class="n">dq</span><span class="p">,</span>
    <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">new_node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
    <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">_death_queue_idx_to_node</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span>
                                           <span class="n">dq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>
    <span class="n">dq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">_death_queue_node_to_idx</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span>
                                                   <span class="n">new_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_death_queue_remove</span><span class="p">(</span>
            <span class="k">struct</span> <span class="n">death_queue_t</span> <span class="o">*</span><span class="n">dq</span><span class="p">,</span> <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">_death_queue_idx_to_node</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span>
                                              <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">);</span>
    <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">_death_queue_idx_to_node</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span>
                                              <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="closing-words">
<h2>Closing words</h2>
<p>That’s pretty much it: when a response has been sent, the connection can
either be closed, or a new request can be serviced in the same connection.
Repeat ad infinitum and there’s the <a class="reference external" href="http://lwan.ws">HTTP server</a>.</p>
<p>If you’ve made this far, I invite you to take a look at the <a class="reference external" href="https://github.com/lpereira/lwan">full source code</a>.
There are things that were not mentioned in this article. It’s also a young
Free Software project with no entry barrier: just fork and issue a pull
request.</p>
</div>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        
        <div class="tags">
            <span>
                Tags:
                <a href="tags/lwan.html">lwan</a>, <a href="tags/programming.html">programming</a>, <a href="tags/c.html">C</a></span>
        </div>
        </div><div class="archive_link">
        <a href="archive.html"> &mdash; Blog Archive &mdash; </a>
    </div><ul class="related clearfix">
            <li class="left"></li>
            <li class="right"><a href="page2.html">Older</a> &raquo; </li>
        </ul></article><aside class="sidebar"><section><div class="widget" id="searchbox" role="search">
    <h1><a href="#searchbox">Search</a></h1>
    <form action="search.html" method="get">
        <input type="text" name="q" />
        <button type="submit"><span class="fa fa-search"></span></button>
    </form>
</div></section><section><div class="widget">
    <h1>Recent Posts</h1>
    <ul><li>
            <a href="2017/03/01/parsing_json.html">Parsing JSON</a>
        </li><li>
            <a href="2016/11/08/infect_to_protect.html">Infect to Protect</a>
        </li><li>
            <a href="2015/05/01/initializing_a_heap_allocated_structure_in_c.html">Initializing a heap-allocated structure in C</a>
        </li><li>
            <a href="2014/11/02/hybrid_c_pascal_strings.html">Hybrid C/Pascal Strings</a>
        </li><li>
            <a href="2014/10/06/life_of_a_http_request.html">Life of a HTTP request, as seen by my toy web server</a>
        </li><li>
            <a href="2014/06/23/integer_to_string_conversion.html">Integer to string conversion</a>
        </li><li>
            <a href="2013/12/08/reducing_lwan_memory_usage.html">Reducing Lwan memory usage by 94%</a>
        </li><li>
            <a href="2013/09/26/implementing_sequences_in_lwan_template_engine.html">Implementing sequences in lwan template engine</a>
        </li><li>
            <a href="2013/07/20/partial_functions_in_c.html">Partially Applied Functions in C</a>
        </li><li>
            <a href="2012/11/11/mustache_templates_in_c.html">Mustache templates in C</a>
        </li></ul>
</div>
</section><section><div class="widget">
    <h1>Tags Cloud</h1>
      <a href="tags/arduino.html" style="font-size: 8pt">arduino</a>&nbsp;&nbsp;
      <a href="tags/assembly.html" style="font-size: 8pt">assembly</a>&nbsp;&nbsp;
      <a href="tags/bpf.html" style="font-size: 8pt">bpf</a>&nbsp;&nbsp;
      <a href="tags/c.html" style="font-size: 16pt">C</a>&nbsp;&nbsp;
      <a href="tags/c.html" style="font-size: 8pt">c</a>&nbsp;&nbsp;
      <a href="tags/conferences.html" style="font-size: 8pt">conferences</a>&nbsp;&nbsp;
      <a href="tags/container.html" style="font-size: 8pt">container</a>&nbsp;&nbsp;
      <a href="tags/data_structure.html" style="font-size: 8pt">data-structure</a>&nbsp;&nbsp;
      <a href="tags/efl.html" style="font-size: 8pt">efl</a>&nbsp;&nbsp;
      <a href="tags/enlightenment.html" style="font-size: 8pt">enlightenment</a>&nbsp;&nbsp;
      <a href="tags/finf.html" style="font-size: 8pt">finf</a>&nbsp;&nbsp;
      <a href="tags/javascript.html" style="font-size: 8pt">javascript</a>&nbsp;&nbsp;
      <a href="tags/linux.html" style="font-size: 9pt">linux</a>&nbsp;&nbsp;
      <a href="tags/lwan.html" style="font-size: 16pt">lwan</a>&nbsp;&nbsp;
      <a href="tags/optimization.html" style="font-size: 8pt">optimization</a>&nbsp;&nbsp;
      <a href="tags/parser.html" style="font-size: 8pt">parser</a>&nbsp;&nbsp;
      <a href="tags/profusion.html" style="font-size: 9pt">profusion</a>&nbsp;&nbsp;
      <a href="tags/programming.html" style="font-size: 20pt">programming</a>&nbsp;&nbsp;
      <a href="tags/strace.html" style="font-size: 8pt">strace</a>&nbsp;&nbsp;
      <a href="tags/template.html" style="font-size: 8pt">template</a>&nbsp;&nbsp;
      <a href="tags/tizen.html" style="font-size: 8pt">tizen</a>&nbsp;&nbsp;
      <a href="tags/trick.html" style="font-size: 14pt">trick</a>&nbsp;&nbsp;
      <a href="tags/tricks.html" style="font-size: 8pt">tricks</a>&nbsp;&nbsp;
      <a href="tags/zephyr.html" style="font-size: 8pt">zephyr</a>
</div></section></aside></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><footer class="wrapper">&copy; Copyright 2012—2015, Leandro Pereira. Powered by <a href="http://www.tinkerer.me/">Tinkerer</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.</footer></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>