<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width">
        <title>Home &mdash; Leandro Pereira</title>
            <link rel="stylesheet" href="_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="_static/main.css" type="text/css">
            <link rel="stylesheet" href="_static/flat.css" type="text/css">
            <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="_static/plugins.js"></script>
        <script src="_static/main.js"></script>
        <link rel="search" title="Search" href="search.html" /><link rel="next" title="Older" href="page2.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.7.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="_static/underscore.js"></script><script type="text/javascript" src="_static/doctools.js"></script>
<style type="text/css">img {max-width: 100%;}</style>
</head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><header role="banner">
            <hgroup>
              <h1><a href="#">Leandro Pereira</a></h1></hgroup>
          </header>
      <nav role="navigation">
            <ul><li class="main-nav">
                  <a href="#">Home</a>
                </li>
              <li class="main-nav">
                  <a href="pages/about.html">About</a>
                </li>
              </ul>
          </nav><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>February 10, 2020</span>
        </div>
        <div class="section">
            <h1><a href="2020/02/10/optimizing_a_json_serializer.html">Optimizing a JSON serializer (part 1)</a></h1>
<p>A few years back, I wrote a <a class="reference external" href="https://tia.mat.br/posts/2017/03/01/parsing_json.html">tiny JSON library for the Zephyr OS</a>; it focused
mostly in things that are important for an embedded real-time operating
system: code size, type-safety, and predictability (both for memory and CPU
time usage).  It was never tuned to ace performance benchmarks: the other
constraints were far more important driver for its design decisions.</p>
<p>As part of the Lwan entry in the <a class="reference external" href="https://www.techempower.com/benchmarks/">TechEmpower Web Framework Benchmarks</a> (TWFB), the <a class="reference external" href="https://github.com/rustyrussell/ccan/tree/master/ccan/json">JSON library</a> from CCAN
was used.  It was responsible in part for Lwan <a class="reference external" href="https://www.techempower.com/blog/2015/04/21/framework-benchmarks-round-10/">“taking the crown”</a> for that
around, according to their blog post.  It’s certainly not a bad library, but
considering I can reason about every line of code in the JSON library I
wrote for Zephyr, I decided to use it instead, moving forward.</p>
<p>I could just consider the JSON library as a black box and not worry about
its guts, but I wanted to optimize it – just for fun – and being able to
understand every design decision in the new library contributed a lot to the
decision of changing libraries.</p>
<p>In the end, though, there’s not much point in spending time optimizing a
JSON encoder that’s good enough already; most of the time is spent in the
network transport, and it’s very unlikely that changes in something like
this will actually influence benchmarks.  Lwan is, however, more of a
testbed of ideas, where I’m free to try out different techniques or play
with things I rarely have the opportunity to play with in the “real world”,
so this seemed like a good candidate to start.</p>
<p>For those unfamiliar with the JSON benchmark in TWFB, it essentially has the
requirement that, for a particular endpoint, an object is created and
serialized on-the-fly (without caching).  The object has to have the content
(<span class="docutils literal"><span class="pre">{"message":</span> <span class="pre">"Hello,</span> <span class="pre">World!"}</span></span>), so unless the JSON library is pretty bad
to begin with, there isn’t much that can be done to speed this up.</p>
<p>The CCAN library requires a JSON object tree to be built before
it can serialize, just to require that data to be torn down immediately
afterwards; it is kind of wasteful.  It also requires serializing the whole
JSON buffer into a chunk of memory that’s allocated by the encoder,
potentially requiring copies.</p>
<p>The new JSON library, however, takes a different approach.</p>
<p>Instead of requiring an object tree to be built, the serializer traverses a
descriptor array while obtaining values from a user-supplied struct (the
descriptor contains the type and offserts to the user-supplied pointer where
the values can be obtained); it kind of does “manual reflection”, if such
thing would make sense.  The struct can be allocated in the stack, avoiding
expensive roundtrips to malloc (and occasional heap fragmentation).  My
<a class="reference external" href="https://tia.mat.br/posts/2017/03/01/parsing_json.html">previous blog post about the JSON library</a> has more details
on how this works, from the parsing side.</p>
<p>In addition, the encoder takes a function pointer that’s called to append
bytes to a buffer; this interface, inspired by Go’s Writer interface,
completely decouples the JSON encoder from the buffer manipulation
facilities.  For the benchmark, since each response in Lwan has a <span class="docutils literal"><span class="pre">struct</span>
<span class="pre">lwan_strbuf</span></span>, that’s what the supplied callback ends up using.  (This
function pointer is also used as a way to calculate the amount of memory
necessary to serialize some piece of data.  More on this later.)</p>
<div class="section" id="miscelaneous-little-improvements">
<h2>Miscelaneous little improvements</h2>
<p><strong>Alignment: shift ➡ full values.</strong> Zephyr is built for embedded devices.
Memory is severely constrained, so it’s usually fine to pay the price of
packing multiple integer values into a single <cite>uint32_t</cite>.  Lwan doesn’t
have that limitation, so bitfields were removed from that version.</p>
<p><strong>Getting rid of branches while encoding commas between elements:</strong> JSON
uses commas as item delimiter in its collection types; as such, it doesn’t
allow trailing commas.  The encoder originally checked if every descriptor
entry was the last item; it was modified to never check if it’s the last
item, but rather:</p>
<ul class="simple">
<li>For objects, is starts looping from the second descriptor element,
always appending a comma inside the loop; when that’s done, the first
descriptor is serialized.</li>
<li>For arrays, the loop runs <span class="docutils literal"><span class="pre">(N</span> <span class="pre">-</span> <span class="pre">1)</span></span> times, always appending the comma,
and finally adds the last element.</li>
</ul>
<p><strong>Using `int_to_string()` to serialize integers:</strong> the library originally
used <span class="docutils literal"><span class="pre">snprintf()</span></span> to serialize integers.  This is inneficient, <a class="reference external" href="https://tia.mat.br/posts/2014/06/23/integer_to_string_conversion.html">so another
method to convert integers to string</a>
was used instead.</p>
<p><strong>Keys don’t need to be escaped, most of the time.</strong>  If that’s the case,
branches can be removed from the fast path and <span class="docutils literal"><span class="pre">append_bytes()</span></span> can be
called with the key name directly.  This saves a lot of indirect function
calls.   For keys that need to be escaped, or for string values, the
library would previously call <span class="docutils literal"><span class="pre">append_bytes()</span></span> for each byte from the
string to be escaped; it’s now batched and only split into multiple calls
if there’s a character that needs to be escaped.</p>
<p><strong>Deferred error checking: ``append_bytes()`` isn’t supposed to fail, most of
the time.</strong>  So it’s fine to not return early and keep trying to serialize,
as long as the original caller knows that an encoding error happened. So,
instead of many <span class="docutils literal"><span class="pre">err</span> <span class="pre">=</span> <span class="pre">append_bytes(...);</span> <span class="pre">if</span> <span class="pre">(err</span> <span class="pre">&lt;</span> <span class="pre">0)</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">err;</span> <span class="pre">}</span></span>
lines, the encoder essentially does <span class="docutils literal"><span class="pre">err</span> <span class="pre">|=</span> <span class="pre">append_bytes(...)</span></span> and returns
<span class="docutils literal"><span class="pre">err</span></span> at the end.  This code is not equivalent, especially since
<span class="docutils literal"><span class="pre">append_bytes()</span></span> can return any negative error code, but it does remove
alot of branches in the fast path.  If you know your error codes (e.g.
they’re all power of two), this can actually be a good solution, and better
than relying on error codes from <span class="docutils literal"><span class="pre">&lt;errno.h&gt;</span></span>.</p>
<p><strong>Pre-encode keys with quotes and colon:</strong> for every key/value pair in an
object, the encoder had to call <span class="docutils literal"><span class="pre">append_bytes()</span></span> at least 5 times: one for
each comma, one for the colon, one for the key, and one for the value.  By
pre-calculating the key+colon in compile time, each key/value pair will
make at most 2 calls to <span class="docutils literal"><span class="pre">append_bytes()</span></span>: one for the key, and one for the
value.  This could be easily done in the macros that define a JSON object
descriptor, and stored right after the unencoded key (because each
descriptor also carries the key length with it).</p>
</div>
<div class="section" id="next-time">
<h2>Next time</h2>
<p>I’ll probably continue working in this JSON library before the next round of
the TWFB takes place.  I’m working on another improvement (that will take
some time to finish) that, if it works, will be described here in the blog.
(And, of course, next time performance numbers will accompany the article.)</p>
</div>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        
        <div class="tags">
            <span>
                Tags:
                <a href="tags/lwan.html">lwan</a>, <a href="tags/json.html">json</a>, <a href="tags/optimization.html">optimization</a>, <a href="tags/programming.html">programming</a></span>
        </div>
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>October 24, 2019</span>
        </div>
        <div class="section">
            <div class="section" id="lwan-5-years-in-snippets">
<h1><a href="2019/10/24/lwan_5_years_in_snippets.html">Lwan: 5 years in snippets</a></h1>
<p>Around five years ago, I wrote a blog post that went though the
life-cycle of a HTTP request, as seen by my toy web server, Lwan. It was
a surprisingly popular article, not only raising visibility for my toy
project, but also generating some discussions on link aggregator web
sites and personal emails. (<a class="reference external" href="https://tia.mat.br/posts/2014/10/06/life_of_a_http_request.html">You can read the blog
post</a>
if you haven’t already or need some refreshing.)</p>
<p>While I haven’t been working on it with the vigor I had in its first few
years, a few things changed nonetheless; this article is a follow-up
article on that. (Which I recommend reading, as out-of-date as it is:
most things in the server didn’t change.)</p>
<p>Items in this article aren’t in any particular order; it’s just a
collection of changes that happened since the original article was
written. Not everything is mentioned here, of course, but should give an
idea of the kind of work that kept me busy during some lazy Sundays.</p>
</div>
<div class="section" id="main-loop-changes">
<h1>Main Loop Changes</h1>
<p>The main loop was designed to either wait indefinitely, or time out
every second, depending on how many file descriptors are being watched
by a worker thread. This made it quite hard to implement something that
was required for some use cases I wanted to use Lwan for: the ability
for a request handler to pause the execution for a specified amount of
time.</p>
<p>Request handlers, being executed in a coroutine, are subject to a
cooperative scheduler, so they can’t just use system calls like
<span class="docutils literal"><span class="pre">usleep()</span></span>; instead, many changes in the main loop were performed to
support timers, paving the way for other potential enhancements in the
future (e.g.  non-client file descriptor watching, for instance).</p>
<p>Each thread has a timer wheel data structure, which can be thought of a
efficient priority queue that has the sole purpose of maintaining a set
of timers. Usually, I’d just implement one from the scratch; however,
while looking for implementations for inspiration, I ended up stumbling
over
<a class="reference external" href="https://25thandclement.com/~william/projects/timeout.c.html">timeout.c</a>,
which has a decent API and has seen some abuse in programs like TOR. I
performed a few minor tweaks when importing the library to the tree, and
am now using it to control how much time <span class="docutils literal"><span class="pre">epoll_wait()</span></span> will block
waiting for file descriptor events; and, if none were returned, timers
are processed, and coroutines are marked as “ready to be resumed”.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/>static void *thread_io_loop(void *data)
{
    /* This is the entry point for the worker threads.  The infinite loop
     * below is the meat of event handling in Lwan.  Everything passes
     * through this loop.  */

    /* (Initialization omitted for brevity.) */

    for (;;) {
        /* Turning the timer wheel will also process pending timers,
         * including the one that moves the timeout queue and updates the
         * date/time cache.  It then returns how much time epoll_wait()
         * has to wait in ms. */
        int timeout = turn_timer_wheel(&amp;dq, t, epoll_fd);
        int n_fds = epoll_wait(epoll_fd, events, max_events, timeout);

    /* To quit Lwan, all epoll file descriptors are closed, and the
     * threads are nudged.  This wakes up epoll_wait(), and the next
     * time it's called, it's going to probably return EBADF. */
        if (UNLIKELY(n_fds &lt; 0)) {
            if (errno == EBADF || errno == EINVAL)
                break;
            continue;
        }

        for (struct epoll_event *event = events; n_fds--; event++) {
            if (UNLIKELY(!event-&gt;data.ptr)) {
                accept_nudge(read_pipe_fd, t, lwan-&gt;conns, &amp;dq, &amp;switcher,
                             epoll_fd);
                continue;
            }

            struct lwan_connection *conn = event-&gt;data.ptr;

            if (UNLIKELY(event-&gt;events &amp; (EPOLLRDHUP | EPOLLHUP))) {
                death_queue_kill(&amp;dq, conn);
                continue;
            }

            resume_coro(&amp;dq, conn, epoll_fd);
            death_queue_move_to_last(&amp;dq, conn);
        }
    }

    /* (Cleanup omitted for brevity.) */

    return NULL;
}
</pre></div>
</div>
<p>While coroutines are sleeping, their file descriptor is still tracked by
epoll, in case the connection is dropped by the peer. Awaking a
coroutine is essentially just the matter of listening to the events that
it was listening before it went on to sleep. (At the moment, this means
both read and write events, as it was easier to implement – although
different on kqueue systems, where reading/writing are not events but
filters, which can’t be combined in a single throw.)</p>
<p>A coroutine expresses their desire to sleep to the main loop by yielding
with a special value. (Previously, it could only say ‘yield, but resume
me later’ or ‘yield, but destroy me whenever you can’; this changed in
the recent months.)</p>
<p>With all the infrastructure work, the API entry point to suspend the
corroutine for an specified amount of time becomes trivial:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/>static void remove_sleep(void *data1, void *data2)
{
    struct timeouts *wheel = data1;
    struct timeout *timeout = data2;
    struct lwan_request *request =
        container_of(timeout, struct lwan_request, timeout);

    if (request-&gt;conn-&gt;flags &amp; CONN_SUSPENDED_TIMER)
        timeouts_del(wheel, timeout);

    request-&gt;conn-&gt;flags &amp;= ~CONN_HAS_REMOVE_SLEEP_DEFER;
}

void lwan_request_sleep(struct lwan_request *request, uint64_t ms)
{
    struct lwan_connection *conn = request-&gt;conn;
    struct timeouts *wheel = conn-&gt;thread-&gt;wheel;

    request-&gt;timeout = (struct timeout) {};
    timeouts_add(wheel, &amp;request-&gt;timeout, ms);

    if (!(conn-&gt;flags &amp; CONN_HAS_REMOVE_SLEEP_DEFER)) {
        coro_defer2(conn-&gt;coro, remove_sleep, wheel, &amp;request-&gt;timeout);
        conn-&gt;flags |= CONN_HAS_REMOVE_SLEEP_DEFER;
    }

    /* The meaning of CONN_CORO_SUSPEND_TIMER will become clear in the next
     * section. */
    coro_yield(conn-&gt;coro, CONN_CORO_SUSPEND_TIMER);
}
</pre></div>
</div>
<p>(The next section explains a little bit more of how the infrastructure
works.)</p>
<p>Due to the nature of the hashed timer wheel, when <span class="docutils literal"><span class="pre">epoll_wait()</span></span> wakes
up every second to update the time cache and process the timeout queue,
it may wake up a few more times with intervals smaller than 1 second. In
practice, this ends up being slightly more accurate, as the system’s
monotonic clock source is used to offset any time between
<span class="docutils literal"><span class="pre">epoll_wait()</span></span> invocations, avoiding timer drift. (It’s slightly more
accurate because the coarse monotonic clock is used if available, and
the timeout in <span class="docutils literal"><span class="pre">epoll_wait()</span></span> uses the fine-grained variant instead.
Maybe a <span class="docutils literal"><span class="pre">EPOLL_COARSE_CLOCKSOURCE</span></span> flag to <span class="docutils literal"><span class="pre">epoll_create1()</span></span> would
be worthwhile investigating?)</p>
</div>
<div class="section" id="changing-connection-coroutine-yield-values">
<h1>Changing Connection Coroutine Yield Values</h1>
<p>One of the trickiest bits in Lwan was its main loop and how it
determined which epoll events mask to choose depending on the connection
state. It was often the case that a connection would stall indefinitely
for no reason, which was often caused when it had declared that it
wanted to be resumed only when the socket was ready to read, when it
wanted to write instead. The code responsible for this was very brittle
and didn’t make much sense, although it worked most of the time. It
really needed a big overhaul (which turned out to not be big, line-count
wise.)</p>
<p>The main idea behind the changes here was to add new values that
coroutines could use to inform the scheduler what it was interested in:
reading from the socket, writing to the socket, sleeping, this sort of
stuff. This is mostly hidden from most of the code, though, being
necessary to be aware of only by the I/O wrappers (a coroutine now
yields automatically, for instance, if <span class="docutils literal"><span class="pre">lwan_read()</span></span> detects that
read() failed with a <span class="docutils literal"><span class="pre">EAGAIN</span></span> <span class="docutils literal"><span class="pre">errno</span></span>, to change the coroutine
intent to be resumed whenever the socket can be read again).</p>
<p>The nice thing about this change is that it changed a bunch of branches
and operations with straightforward table lookups. In the past few
years, I’ve been moving towards using lookup tables a whole lot more;
it’s sometimes difficult to express a rat’s nest of branches in a way
that’s efficient to look it up on a table, but it’s a satisfying feeling
when all that crud is gone and all you’re left with are a few array
accesses.</p>
<p>Contrast the new, shiny, table-based approach:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="n">static</span> <span class="n">ALWAYS_INLINE</span> <span class="n">uint32_t</span>
<span class="n">conn_flags_to_epoll_events</span><span class="p">(</span><span class="n">enum</span> <span class="n">lwan_connection_flags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">uint32_t</span> <span class="nb">map</span><span class="p">[</span><span class="n">CONN_EVENTS_MASK</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">[</span><span class="mi">0</span> <span class="o">/*</span> <span class="n">Suspended</span> <span class="n">by</span> <span class="n">timer</span> <span class="o">*/</span><span class="p">]</span> <span class="o">=</span> <span class="n">EPOLLRDHUP</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_EVENTS_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="n">EPOLLOUT</span> <span class="o">|</span> <span class="n">EPOLLRDHUP</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_EVENTS_READ</span><span class="p">]</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLRDHUP</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_EVENTS_READ_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLOUT</span> <span class="o">|</span> <span class="n">EPOLLRDHUP</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">return</span> <span class="nb">map</span><span class="p">[</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CONN_EVENTS_MASK</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">#if defined(__linux__)</span>
<span class="c1"># define CONN_EVENTS_RESUME_TIMER CONN_EVENTS_READ_WRITE</span>
<span class="c1">#else</span>
<span class="o">/*</span> <span class="n">Kqueue</span> <span class="n">doesn</span><span class="s1">'t like when you filter on both read and write, so</span>
 <span class="o">*</span> <span class="n">wait</span> <span class="n">only</span> <span class="n">on</span> <span class="n">write</span> <span class="n">when</span> <span class="n">resuming</span> <span class="n">a</span> <span class="n">coro</span> <span class="n">suspended</span> <span class="n">by</span> <span class="n">a</span> <span class="n">timer</span><span class="o">.</span>
 <span class="o">*</span> <span class="n">The</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">wrappers</span> <span class="n">should</span> <span class="k">yield</span> <span class="k">if</span> <span class="n">trying</span> <span class="n">to</span> <span class="n">read</span> <span class="n">without</span> <span class="n">anything</span>
 <span class="o">*</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">changing</span> <span class="n">the</span> <span class="nb">filter</span> <span class="n">to</span> <span class="n">only</span> <span class="n">read</span><span class="p">,</span> <span class="n">so</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">OK</span><span class="o">.</span> <span class="o">*/</span>
<span class="c1"># define CONN_EVENTS_RESUME_TIMER CONN_EVENTS_WRITE</span>
<span class="c1">#endif</span>

<span class="n">static</span> <span class="n">void</span> <span class="n">update_epoll_flags</span><span class="p">(</span><span class="nb">int</span> <span class="n">fd</span><span class="p">,</span>
                               <span class="n">struct</span> <span class="n">lwan_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
                               <span class="nb">int</span> <span class="n">epoll_fd</span><span class="p">,</span>
                               <span class="n">enum</span> <span class="n">lwan_connection_coro_yield</span> <span class="n">yield_result</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">enum</span> <span class="n">lwan_connection_flags</span> <span class="n">or_mask</span><span class="p">[</span><span class="n">CONN_CORO_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">CONN_CORO_YIELD</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_WANT_READ_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONN_EVENTS_READ_WRITE</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_WANT_READ</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONN_EVENTS_READ</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_WANT_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONN_EVENTS_WRITE</span><span class="p">,</span>

        <span class="o">/*</span> <span class="n">While</span> <span class="n">the</span> <span class="n">coro</span> <span class="ow">is</span> <span class="n">suspended</span><span class="p">,</span> <span class="n">we</span><span class="s1">'re not interested in either EPOLLIN</span>
         <span class="o">*</span> <span class="ow">or</span> <span class="n">EPOLLOUT</span> <span class="n">events</span><span class="o">.</span>  <span class="n">We</span> <span class="n">still</span> <span class="n">want</span> <span class="n">to</span> <span class="n">track</span> <span class="n">this</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">epoll</span><span class="p">,</span> <span class="n">though</span><span class="p">,</span>
         <span class="o">*</span> <span class="n">so</span> <span class="n">unset</span> <span class="n">both</span> <span class="n">so</span> <span class="n">that</span> <span class="n">only</span> <span class="n">EPOLLRDHUP</span> <span class="p">(</span><span class="n">plus</span> <span class="n">the</span> <span class="n">implicitly</span><span class="o">-</span><span class="nb">set</span> <span class="n">ones</span><span class="p">)</span>
         <span class="o">*</span> <span class="n">are</span> <span class="nb">set</span><span class="o">.</span> <span class="o">*/</span>
        <span class="p">[</span><span class="n">CONN_CORO_SUSPEND_TIMER</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONN_SUSPENDED_TIMER</span><span class="p">,</span>

        <span class="o">/*</span> <span class="n">Either</span> <span class="n">EPOLLIN</span> <span class="ow">or</span> <span class="n">EPOLLOUT</span> <span class="n">have</span> <span class="n">to</span> <span class="n">be</span> <span class="nb">set</span> <span class="n">here</span><span class="o">.</span>  <span class="n">There</span><span class="s1">'s no need to</span>
         <span class="o">*</span> <span class="n">know</span> <span class="n">which</span> <span class="n">event</span><span class="p">,</span> <span class="n">because</span> <span class="n">they</span> <span class="n">were</span> <span class="n">both</span> <span class="n">cleared</span> <span class="n">when</span> <span class="n">the</span> <span class="n">coro</span> <span class="n">was</span>
         <span class="o">*</span> <span class="n">suspended</span><span class="o">.</span> <span class="n">So</span> <span class="nb">set</span> <span class="n">both</span> <span class="n">flags</span> <span class="n">here</span><span class="o">.</span> <span class="n">This</span> <span class="n">works</span> <span class="n">because</span> <span class="n">EPOLLET</span> <span class="n">isn</span><span class="s1">'t</span>
         <span class="o">*</span> <span class="n">used</span><span class="o">.</span> <span class="o">*/</span>
        <span class="p">[</span><span class="n">CONN_CORO_RESUME_TIMER</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONN_EVENTS_RESUME_TIMER</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">enum</span> <span class="n">lwan_connection_flags</span> <span class="n">and_mask</span><span class="p">[</span><span class="n">CONN_CORO_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">CONN_CORO_YIELD</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_WANT_READ_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_WANT_READ</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">CONN_EVENTS_WRITE</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_WANT_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">CONN_EVENTS_READ</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_SUSPEND_TIMER</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">CONN_EVENTS_READ_WRITE</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_RESUME_TIMER</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">CONN_SUSPENDED_TIMER</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="n">enum</span> <span class="n">lwan_connection_flags</span> <span class="n">prev_flags</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

    <span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">or_mask</span><span class="p">[</span><span class="n">yield_result</span><span class="p">];</span>
    <span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">and_mask</span><span class="p">[</span><span class="n">yield_result</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">==</span> <span class="n">prev_flags</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">struct</span> <span class="n">epoll_event</span> <span class="n">event</span> <span class="o">=</span> <span class="p">{</span>
        <span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">conn_flags_to_epoll_events</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">),</span>
        <span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">conn</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">lwan_status_perror</span><span class="p">(</span><span class="s2">"epoll_ctl"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With the crusty, buggy, old approach that only worked by chance (and was
the source of a lot of headache):</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/>static void update_epoll_flags(struct death_queue *dq,
                               struct lwan_connection *conn,
                               int epoll_fd,
                               enum lwan_connection_coro_yield yield_result)
{
    uint32_t events = 0;
    bool write_events;

    if (UNLIKELY(conn-&gt;flags &amp; CONN_RESUMED_FROM_TIMER)) {
        conn-&gt;flags &amp;= ~(CONN_RESUMED_FROM_TIMER | CONN_WRITE_EVENTS);
        write_events = false;
    } else if (UNLIKELY(conn-&gt;flags &amp; CONN_SUSPENDED_BY_TIMER)) {
        /* CONN_WRITE_EVENTS shouldn't be flipped in this case. */
        events = EPOLLERR | EPOLLRDHUP;
    } else if (conn-&gt;flags &amp; CONN_MUST_READ) {
        write_events = true;
    } else {
        bool should_resume_coro = (yield_result == CONN_CORO_MAY_RESUME);

        if (should_resume_coro)
            conn-&gt;flags |= CONN_SHOULD_RESUME_CORO;
        else
            conn-&gt;flags &amp;= ~CONN_SHOULD_RESUME_CORO;

        write_events = (conn-&gt;flags &amp; CONN_WRITE_EVENTS);
        if (should_resume_coro == write_events)
            return;
    }

    if (LIKELY(!events)) {
        events = events_by_write_flag[write_events];
        conn-&gt;flags ^= CONN_WRITE_EVENTS;
    }

    struct epoll_event event = {.events = events, .data.ptr = conn};

    int fd = lwan_connection_get_fd(dq-&gt;lwan, conn);
    if (UNLIKELY(epoll_ctl(epoll_fd, EPOLL_CTL_MOD, fd, &amp;event) &lt; 0))
        lwan_status_perror("epoll_ctl");
}
</pre></div>
</div>
</div>
<div class="section" id="changes-in-parsers">
<h1>Changes in parsers</h1>
<div class="section" id="rfc822-date-headers">
<h2>RFC822 (Date headers)</h2>
<p>Unhappy with the performance of <span class="docutils literal"><span class="pre">strptime()</span></span>, I came up with a parser
that fits the theme of the rest of the HTTP parser in Lwan quite well:
by using string switch statements, the <a class="reference external" href="https://gist.github.com/lpereira/4e09f5a038b740d61860488679427c4e">new time parser is faster by a
around 12x when compared with the generic one from the C
library</a>.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="nb">int</span> <span class="n">lwan_parse_rfc_time</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="ow">in</span><span class="p">[</span><span class="n">static</span> <span class="mi">30</span><span class="p">],</span> <span class="n">time_t</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">/*</span> <span class="n">This</span> <span class="n">function</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">strptime</span><span class="p">()</span> <span class="n">because</span> <span class="n">locale</span>
     <span class="o">*</span> <span class="n">information</span> <span class="n">can</span> <span class="n">affect</span> <span class="n">the</span> <span class="n">parsing</span><span class="o">.</span>  <span class="n">Instead</span> <span class="n">of</span> <span class="n">defining</span>
     <span class="o">*</span> <span class="n">the</span> <span class="n">locale</span> <span class="n">to</span> <span class="s2">"C"</span><span class="p">,</span> <span class="n">use</span> <span class="n">hardcoded</span> <span class="n">constants</span><span class="o">.</span> <span class="o">*/</span>
    <span class="n">struct</span> <span class="n">tm</span> <span class="n">tm</span><span class="p">;</span>
    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">str</span> <span class="o">=</span> <span class="ow">in</span><span class="p">;</span>

    <span class="n">STRING_SWITCH</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'S'</span><span class="p">,</span><span class="s1">'u'</span><span class="p">,</span><span class="s1">'n'</span><span class="p">,</span><span class="s1">','</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'M'</span><span class="p">,</span><span class="s1">'o'</span><span class="p">,</span><span class="s1">'n'</span><span class="p">,</span><span class="s1">','</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'T'</span><span class="p">,</span><span class="s1">'u'</span><span class="p">,</span><span class="s1">'e'</span><span class="p">,</span><span class="s1">','</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'W'</span><span class="p">,</span><span class="s1">'e'</span><span class="p">,</span><span class="s1">'d'</span><span class="p">,</span><span class="s1">','</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'T'</span><span class="p">,</span><span class="s1">'h'</span><span class="p">,</span><span class="s1">'u'</span><span class="p">,</span><span class="s1">','</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'F'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">,</span><span class="s1">'i'</span><span class="p">,</span><span class="s1">','</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'S'</span><span class="p">,</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'t'</span><span class="p">,</span><span class="s1">','</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">default</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nb">str</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="n">tm</span><span class="o">.</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="n">parse_2_digit_num</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="s1">' '</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">tm_mday</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="nb">str</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="n">STRING_SWITCH</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'J'</span><span class="p">,</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'n'</span><span class="p">,</span><span class="s1">' '</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'F'</span><span class="p">,</span><span class="s1">'e'</span><span class="p">,</span><span class="s1">'b'</span><span class="p">,</span><span class="s1">' '</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'M'</span><span class="p">,</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">,</span><span class="s1">' '</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'A'</span><span class="p">,</span><span class="s1">'p'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">,</span><span class="s1">' '</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'M'</span><span class="p">,</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'y'</span><span class="p">,</span><span class="s1">' '</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'J'</span><span class="p">,</span><span class="s1">'u'</span><span class="p">,</span><span class="s1">'n'</span><span class="p">,</span><span class="s1">' '</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'J'</span><span class="p">,</span><span class="s1">'u'</span><span class="p">,</span><span class="s1">'l'</span><span class="p">,</span><span class="s1">' '</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'A'</span><span class="p">,</span><span class="s1">'u'</span><span class="p">,</span><span class="s1">'g'</span><span class="p">,</span><span class="s1">' '</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'S'</span><span class="p">,</span><span class="s1">'e'</span><span class="p">,</span><span class="s1">'p'</span><span class="p">,</span><span class="s1">' '</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'O'</span><span class="p">,</span><span class="s1">'c'</span><span class="p">,</span><span class="s1">'t'</span><span class="p">,</span><span class="s1">' '</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'N'</span><span class="p">,</span><span class="s1">'o'</span><span class="p">,</span><span class="s1">'v'</span><span class="p">,</span><span class="s1">' '</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'D'</span><span class="p">,</span><span class="s1">'e'</span><span class="p">,</span><span class="s1">'c'</span><span class="p">,</span><span class="s1">' '</span><span class="p">):</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">default</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nb">str</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="n">tm</span><span class="o">.</span><span class="n">tm_year</span> <span class="o">=</span> <span class="n">parse_int</span><span class="p">(</span><span class="n">strndupa</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">tm_year</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">tm_year</span> <span class="o">-=</span> <span class="mi">1900</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">tm_year</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tm</span><span class="o">.</span><span class="n">tm_year</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="nb">str</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="n">tm</span><span class="o">.</span><span class="n">tm_hour</span> <span class="o">=</span> <span class="n">parse_2_digit_num</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="s1">':'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
    <span class="nb">str</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">tm_min</span> <span class="o">=</span> <span class="n">parse_2_digit_num</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="s1">':'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">59</span><span class="p">);</span>
    <span class="nb">str</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">tm_sec</span> <span class="o">=</span> <span class="n">parse_2_digit_num</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="s1">' '</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">59</span><span class="p">);</span>
    <span class="nb">str</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="n">STRING_SWITCH</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="s1">'G'</span><span class="p">,</span><span class="s1">'M'</span><span class="p">,</span><span class="s1">'T'</span><span class="p">,</span><span class="s1">'</span><span class="se">\0</span><span class="s1">'</span><span class="p">):</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">tm_isdst</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">timegm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="o">*</span><span class="n">out</span> <span class="o">==</span> <span class="p">(</span><span class="n">time_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">default</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference external" href="http://0x80.pl/">Wojciech Muła</a> wrote a better version using <a class="reference external" href="https://github.com/WojciechMula/toys/tree/master/parse_rfc_date">SIMD
instructions</a>
after they learned about this routine; it was then improved by <a class="reference external" href="https://twitter.com/kendallwillets">Kendall
Willets</a> to use a different
technique (a perfect hash table). Both are faster than the version used
in Lwan, but I decided to keep my version because not only it is fast
enough, it’s also more maintainable; it also serves as a pretty good
example for the <a class="reference external" href="https://tia.mat.br/posts/2018/02/01/more_on_string_switch_in_c.html">string switch
trick</a>.</p>
<p>(As a complement to this change, the function that converts a time_t
into the same string that <span class="docutils literal"><span class="pre">lwan_parse_rfc_time()</span></span> parses has been
written as well, and it’s as efficient as I could make it, even going to
the effort of reducing the number of divisions to convert integers into
strings from 6 to just 1.)</p>
</div>
<div class="section" id="configuration-parser-template-parser">
<h2>Configuration parser &amp; Template parser</h2>
<p>Both the configuration file parser and the template parser were written
without paying attention to anything related to compiler theory; just an
ad-hoc parser without a proper lexer, looking at a line at a time. Both
had a lot of workarounds and were generally hard to extend and debug.
They needed to be rewritten, but I really didn’t want to use a parser
generator (I really don’t like them).</p>
<p>For both of these parsers, used the same technique in the <a class="reference external" href="https://tia.mat.br/posts/2017/03/01/parsing_json.html">JSON parser I
wrote for the Zephyr
project</a>: a
state machine (where the variable that holds the state actually holds a
pointer to a function that handles that state), and a ring buffer. I
really like this technique, as it’s often easier to grasp than many of
the parser generators out there. (There’s the added benefit that no new
build dependencies or build system changes is required.)</p>
<p>Here’s how one of these functions might look; this one doesn’t use the
ring buffer, only consumes bytes from the input:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="n">static</span> <span class="n">void</span> <span class="o">*</span><span class="n">lex_comment</span><span class="p">(</span><span class="n">struct</span> <span class="n">lexer</span> <span class="o">*</span><span class="n">lexer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">/*</span> <span class="n">lex_config</span><span class="p">()</span> <span class="n">returns</span> <span class="s1">'lex_comment'</span> <span class="n">when</span> <span class="s1">'next(lexer)'</span> <span class="n">returns</span> <span class="s1">'#'</span> <span class="o">*/</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">iscomment</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">lexer</span><span class="p">)))</span>
        <span class="p">;</span>

    <span class="o">/*</span> <span class="n">Current</span> <span class="n">character</span> <span class="n">isn</span><span class="s1">'t a comment, back it up: next state should be</span>
     <span class="o">*</span> <span class="n">able</span> <span class="n">to</span> <span class="n">read</span> <span class="n">it</span> <span class="ow">and</span> <span class="n">determine</span> <span class="n">which</span> <span class="n">state</span> <span class="ow">is</span> <span class="n">going</span> <span class="n">to</span> <span class="n">process</span> <span class="n">the</span>
     <span class="o">*</span> <span class="nb">next</span> <span class="n">token</span><span class="o">.</span> <span class="o">*/</span>
    <span class="n">backup</span><span class="p">(</span><span class="n">lexer</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">lex_config</span><span class="p">()</span> <span class="n">handles</span> <span class="n">the</span> <span class="n">main</span> <span class="n">state</span> <span class="o">*/</span>
    <span class="k">return</span> <span class="n">lex_config</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And here’s how the function that handles the “get me a new token”
function that the parser calls looks:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="n">static</span> <span class="nb">bool</span> <span class="n">lex_next</span><span class="p">(</span><span class="n">struct</span> <span class="n">lexer</span> <span class="o">*</span><span class="n">lexer</span><span class="p">,</span> <span class="n">struct</span> <span class="n">lexeme</span> <span class="o">**</span><span class="n">lexeme</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">/*</span> <span class="n">To</span> <span class="n">end</span> <span class="n">the</span> <span class="n">state</span> <span class="n">machine</span><span class="p">,</span> <span class="n">a</span> <span class="n">state</span><span class="o">-</span><span class="n">handling</span> <span class="n">function</span> <span class="n">returns</span> <span class="n">NULL</span><span class="p">,</span>
     <span class="o">*</span> <span class="n">ending</span> <span class="n">this</span> <span class="n">loop</span><span class="o">.</span>  <span class="o">*/</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">lexer</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">/*</span> <span class="n">If</span> <span class="n">a</span> <span class="n">state</span> <span class="n">handling</span> <span class="n">function</span> <span class="n">emits</span> <span class="n">one</span> <span class="ow">or</span> <span class="n">more</span> <span class="n">tokens</span><span class="p">,</span> <span class="k">for</span> <span class="k">as</span>
         <span class="o">*</span> <span class="n">long</span> <span class="k">as</span> <span class="n">lex_next</span><span class="p">()</span> <span class="ow">is</span> <span class="n">called</span><span class="p">,</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">calling</span> <span class="n">the</span> <span class="n">function</span> <span class="n">to</span>
         <span class="o">*</span> <span class="n">handle</span> <span class="n">the</span> <span class="n">current</span> <span class="n">state</span><span class="p">,</span> <span class="n">items</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">ring</span> <span class="n">buffer</span> <span class="n">are</span> <span class="n">popped</span>
         <span class="o">*</span> <span class="n">instead</span><span class="o">.</span>  <span class="o">*/</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lexeme_buffer_consume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lexer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">lexeme</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">true</span><span class="p">;</span>

        <span class="o">/*</span> <span class="n">Run</span> <span class="n">the</span> <span class="n">state</span> <span class="n">machine</span> <span class="k">for</span> <span class="n">the</span> <span class="n">current</span> <span class="n">state</span><span class="p">,</span> <span class="ow">and</span> <span class="n">update</span> <span class="n">it</span> <span class="k">if</span>
         <span class="o">*</span> <span class="n">necessary</span><span class="o">.</span>  <span class="o">*/</span>
        <span class="n">lexer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">lexer</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">(</span><span class="n">lexer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">/*</span> <span class="n">Exhaust</span> <span class="n">the</span> <span class="n">ring</span> <span class="n">buffer</span> <span class="n">until</span> <span class="n">there</span><span class="s1">'s nothing left. */</span>
    <span class="k">return</span> <span class="n">lexeme_buffer_consume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lexer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">lexeme</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The configuration file parser got a few nice features, like the ability
to expand environment variables (or use a default value provided in the
configuration file), multiline strings, and other minor changes and
bugfixes that would be too complicated to implement in the previous
bespoke one-line-at-a-time thing that was in place.</p>
<p>The template parser also got significantly more robust, handling some
corner cases that were just impossible before. (No new significant
changes have been performed in the runtime portion, though, although a
few tweaks here and there were made over the years.) Unrelated to the
parser changes, a template can be “compiled” with an option that won’t
allocate and copy a new string for each text fragment, but use text
that’s in memory somewhere; this is useful for things such as the file
serving module or the default response generator, when a template has
not been supplied by the user in the configuration file, where
<span class="docutils literal"><span class="pre">strbuf</span></span> structs used by the template mechanism can just point into
somewhere in <span class="docutils literal"><span class="pre">rodata</span></span>.</p>
</div>
</div>
<div class="section" id="readahead-madvise">
<h1>Readahead &amp; Madvise</h1>
<p>The Linux system call <span class="docutils literal"><span class="pre">sendfile()</span></span> doesn’t take flags like the FreeBSD
variant, so it’s impossible to tell it not to block if data isn’t in the
core yet. The best one can do, as far as I can tell, is to make sure
that the data is already there when it is invoked. That’s why Lwan now
has a low-priority thread (which has also low-priority I/O thread on
Linux) that will call <span class="docutils literal"><span class="pre">readahead()</span></span> on file chunks as they’re being
served.</p>
<p>This thread takes commands through a pipe, where only the write side is
non-blocking. (Failure to write to that socket isn’t an issue, as this
is merely an optimization, so this is one of the rare cases in Lwan
where a syscall error isn’t handled.) As commands are received, that
thread is free to block (or, more specifically, wait for as much as
necessary) to load the contents into core, so that hopefully the thread
calling <span class="docutils literal"><span class="pre">sendfile()</span></span> won’t block. This optimization was only possible
because the cache in the file serving module keeps the files open.</p>
<p>For the cases where files are served with a memory-mapped blob of
memory, the problems can be even more apparent; there’s no way to say
“dereference this memory but please don’t block” in any of the supported
platforms. Your only bet is to memory map it, give a hint to the OS to
pre-fault the pages, and lock it in memory. But the <span class="docutils literal"><span class="pre">madvise()</span></span> and
<span class="docutils literal"><span class="pre">mlock()</span></span> combo used for this will eventually encounter similar
problems as with the <span class="docutils literal"><span class="pre">readahead()</span></span> syscall, in which while they might
not exactly block, they’ll take some time to process whatever they need
to process. So the same thread that performs <span class="docutils literal"><span class="pre">readahead()</span></span> will also
try to bring stuff to the core and keep in there for as long as it’s in
the file serving cache instance.</p>
<p>Even with a thread performing <span class="docutils literal"><span class="pre">readahead()</span></span>, it’s possible for the I/O
thread to block (or be stuck in an operation that takes more time than
absolutely necessary), increasing latency when handling other
connections assigned to them. This why I’ve been thinking for quite a
while now on how to introduce a work-stealing scheduler to Lwan, with a
watchdog thread to determine if worker threads are not making any kind
of progress; but this is something for the future, I guess.</p>
<p>(Recent advancements in things like <span class="docutils literal"><span class="pre">io_uring</span></span> and the AIO subsystem
may change how these things are used in Lwan.
<a class="reference external" href="https://www.kernel.org/doc/html/latest/accounting/psi.html">PSI</a> can
be used to avoid doing things if the system is under pressure. I have
not investigated those in depth so far.)</p>
</div>
<div class="section" id="coroutine-changes">
<h1>Coroutine changes</h1>
<p>There has been a few minor tweaks in the coroutine implementation.
Nothing groundbreaking, but worth mentioning anyway.</p>
<p>The <span class="docutils literal"><span class="pre">data</span></span> pointer has been removed from the coro structure, as it can
be simply passed as parameter to the function implementing the
coroutine. This required the trampoline function for x86-64 to be
written in assembly since one of the registers used for parameter
passing are not in the list of caller-saved registers (and thus not
saved/restored by the context swapping routine), but otherwise,
everything seems to be working as expected.</p>
<p>Deferred callbacks are now stored in an array rather than using a linked
list. This makes it cheaper to use defer (less calls to <span class="docutils literal"><span class="pre">malloc()</span></span> for
each <span class="docutils literal"><span class="pre">coro_defer()</span></span> call), which has become an important aspect in how
resources are cleaned up in Lwan. In order to reduce heap memory
allocations, the array is allocated initially inline with the coroutine
struct and moves to the heap if necessary; this cuts two round trips to
the memory allocator per connection in the usual case (this optimization
is available for all array structs if desired; more on this below).</p>
<p>The following table shows the number of <span class="docutils literal"><span class="pre">malloc()</span></span> calls for 100,000
requests to a “Hello, World” handler and the impact of inlining deferred
calls, for both keep-alive and close connections (with 1000 concurrent
connections):</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%"/>
<col width="40%"/>
<col width="38%"/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Connection</th>
<th class="head">Malloc Calls Before</th>
<th class="head">Malloc Calls After</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Keep-Alive</td>
<td>1,031</td>
<td>931</td>
</tr>
<tr class="row-odd"><td>Close</td>
<td>300,731</td>
<td>200,728</td>
</tr>
</tbody>
</table>
<p>An embarassing fix in the coroutine implementation has been in how the
stack is aligned on x86-64. In some situations, Lwan was crashing (with
a SIGSEGV no less) on instructions that were not meant to cause this
kind of signal (e.g. it would crash when Lua was converting a number
into string). Tools such as Valgrind, sanitizers, and debuggers weren’t
that helpful to pinpoint the location. It turns out that how the stack
pointer for coroutines were aligned was incorrect: had <span class="docutils literal"><span class="pre">sprintf()</span></span>
(what Lua uses to convert floating point numbers to strings) been
implemented using x87, this would work fine; however, SSE requires
aligned memory to work, so things were crashing on such a trivial
operation. It’s now aligned on a 16-byte boundary, adjusted to be
aligned on an 8-byte boundary right before the trampoline routine is
called. This one-line change took me a lot more hours than I care to
admit, but it’s now finally fixed. It was the first time I used
<a class="reference external" href="https://rr-project.org/">rr</a>, and it’s now an integral part of my
toolbelt.</p>
</div>
<div class="section" id="sending-responses">
<h1>Sending responses</h1>
<p>For some responses, the <span class="docutils literal"><span class="pre">writev()</span></span> system call was used, so that the
response headers and body could be sent to the wire with a single
syscall. However, the kernel has to copy the I/O vector array, validate
it, and then perform the write operation; this has a relatively high
cost, and if one is trying to send a small response, this cost might not
pay off. I haven’t considered this and always wondered why that was the
case when <span class="docutils literal"><span class="pre">writev()</span></span> was used to build responses (e.g. using multiple
<span class="docutils literal"><span class="pre">struct</span> <span class="pre">iovec</span></span> elements pointing to header names and values instead of
building the response header in memory and sending that). I was
surprised, then, to learn that by reusing the buffer designated for the
response headers and writing the body there (given there was enough
space), and using <span class="docutils literal"><span class="pre">send()</span></span> instead, the RPS rate increased by ~10%.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="n">void</span> <span class="n">lwan_response</span><span class="p">(</span><span class="n">struct</span> <span class="n">lwan_request</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span> <span class="n">enum</span> <span class="n">lwan_http_status</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">/*</span> <span class="o">...</span> <span class="o">*/</span>
    <span class="n">char</span> <span class="n">headers</span><span class="p">[</span><span class="n">DEFAULT_HEADERS_SIZE</span><span class="p">];</span>

    <span class="o">/*</span> <span class="o">...</span> <span class="o">*/</span>

    <span class="n">char</span> <span class="o">*</span><span class="n">resp_buf</span> <span class="o">=</span> <span class="n">lwan_strbuf_get_buffer</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
    <span class="n">const</span> <span class="n">size_t</span> <span class="n">resp_len</span> <span class="o">=</span> <span class="n">lwan_strbuf_get_length</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span> <span class="o">-</span> <span class="n">header_len</span> <span class="o">&gt;</span> <span class="n">resp_len</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">/*</span> <span class="n">writev</span><span class="p">()</span> <span class="n">has</span> <span class="n">to</span> <span class="n">allocate</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="ow">and</span> <span class="n">validate</span> <span class="n">the</span> <span class="n">response</span> <span class="n">vector</span><span class="p">,</span>
         <span class="o">*</span> <span class="n">so</span> <span class="n">use</span> <span class="n">send</span><span class="p">()</span> <span class="k">for</span> <span class="n">responses</span> <span class="n">small</span> <span class="n">enough</span> <span class="n">to</span> <span class="n">fit</span> <span class="n">the</span> <span class="n">headers</span>
         <span class="o">*</span> <span class="n">buffer</span><span class="o">.</span>  <span class="n">On</span> <span class="n">Linux</span><span class="p">,</span> <span class="n">this</span> <span class="ow">is</span> <span class="o">~</span><span class="mi">10</span><span class="o">%</span> <span class="n">faster</span><span class="o">.</span>  <span class="o">*/</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">headers</span> <span class="o">+</span> <span class="n">header_len</span><span class="p">,</span> <span class="n">resp_buf</span><span class="p">,</span> <span class="n">resp_len</span><span class="p">);</span>
        <span class="n">lwan_send</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">header_len</span> <span class="o">+</span> <span class="n">resp_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">struct</span> <span class="n">iovec</span> <span class="n">response_vec</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">{</span><span class="o">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">headers</span><span class="p">,</span> <span class="o">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">header_len</span><span class="p">},</span>
            <span class="p">{</span><span class="o">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">resp_buf</span><span class="p">,</span> <span class="o">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">resp_len</span><span class="p">},</span>
        <span class="p">};</span>

        <span class="n">lwan_writev</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">response_vec</span><span class="p">,</span> <span class="n">N_ELEMENTS</span><span class="p">(</span><span class="n">response_vec</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In order to increase the performance of pipelined requests, Lwan will
also call <span class="docutils literal"><span class="pre">send()</span></span> with the <span class="docutils literal"><span class="pre">MSG_MORE</span></span> flag. This should cause in
less TCP segments being sent over the wire, significantly improving the
RPS rate (~20% higher if I’m not mistaken). This is akin to setting the
<span class="docutils literal"><span class="pre">TCP_CORK</span></span> socket flag, but not only this is more portable, system
calls are saved; nonetheless, the flag that controls if the I/O wrappers
will set that flag still mentions the cork flag. (Linux has TCP
autocorking, which in theory should make this optimization useless, but
in my limited testing it didn’t help that much.) The <span class="docutils literal"><span class="pre">writev()</span></span> system
call, which is still used for those responses that are larger than it
would fit in the response headers buffer, doesn’t take a flags
parameter; however, it’s possible to use <span class="docutils literal"><span class="pre">sendmsg()</span></span> to the same
effect (it also takes the same I/O vector and has the same behavior as
<span class="docutils literal"><span class="pre">writev()</span></span> when it comes to short writes due to non-blocking sockets.)</p>
<p>Adding to the “I’ve been adopting lookup tables whenever I can” comment
above: in order to determine if a response has a body, instead of a
table, the actual flags in the request struct that are used to determine
the HTTP verb encodes this information: if their least-significant-bit
is set, then the response should contain a body; otherwise, only headers
will be sent. Went from an array lookup to a mere mask. Still a table,
just encoded differently.</p>
</div>
<div class="section" id="cpu-topology-aware-thread-pinning-scheduling">
<h1>CPU topology aware thread pinning / scheduling</h1>
<p>One of the things that Lwan has been doing since the beginning was to
allocate a big chunk of memory to containing information about client
connections. Indexed by the file descriptor, looking up the element is
quick and efficient; however also makes it possible for false sharing to
happen (the struct is exactly 32 bytes on x86-64, so that two fit in a
cache line), so connections are scheduled to threads in such a way that
this is avoided.</p>
<p>Previously, however, this would only consider that the CPU topology for
my personal laptop was the gold standard. Anything different and it
would mean that it would probably make the problem even worse. (I’m not
kidding when I say that this project is but a toy.)</p>
<p>Now, Lwan, at least on x86_64 Linux (as it relies on information exposed
by sysfs rather than messing around with <span class="docutils literal"><span class="pre">cpuid</span></span> and the likes), reads
the CPU topology and uses that information to not only pre-schedule all
connections correctly (minimizing a little bit of the work necessary
whenever one is accepted), but to also pin the threads to the correct
logical CPU.</p>
</div>
<div class="section" id="continuous-fuzz-testing">
<h1>Continuous Fuzz-Testing</h1>
<p>Writing your own parser, especially when it comes to something that’s
connected to a network socket, always should raise suspicions. Parsers
can be tricky to get right, and it’s very easy to accidentally trigger a
footgun when doing so in a language like C.</p>
<p>Nevertheless, I still do it; this project is but a hobby to me, and
running with scissors is part of why it’s enjoyable to me. As careful as
I am with it (or would like to think I am), it’s still developed while
I’m tired from work or when I had a few beers; in other words, I needed
to test the project methodically. I had used fuzz-testers before, but
never let them running overnight or over extended periods of time; my
main machine is a laptop, and overheating is an issue.</p>
<p>It was much to my surprise, then, when the folks at Google accepted my
weekend project on <a class="reference external" href="https://github.com/google/oss-fuzz/">OSS-Fuzz</a>.
So far, it has <a class="reference external" href="https://bugs.chromium.org/p/oss-fuzz/issues/list?can=1&amp;q=lwan">found a few issues, which were promptly
fixed</a>;
however, although it’s still hard at work, generating some heat
somewhere, the parser proved to be pretty resilient. I’m pretty happy
with the results.</p>
<p>This of course is only testing the request parser, and there’s more to a
web server than that; some of which aren’t that easy to fuzz-test (at
least not in an automated way). Most of the code being fuzzed is the
more important (and network-facing) request parsing code; coverage for
this is around 15%, which is pretty decent all things considered. The
configuration file parser is also being fuzzed, although the work has
just recently started (I don’t have a lot of information on this yet).
Time permitting, I’ll add more fuzzers to the mix.</p>
<p>As I write this, over 56 trillion tests in the past 30 days (counting only
the tests with <a class="reference external" href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a>,
although <a class="reference external" href="http://lcamtuf.coredump.cx/afl/">AFL</a> is also used), which is
nothing short of amazing.</p>
</div>
<div class="section" id="portability">
<h1>Portability</h1>
<p>The astute reader, or at least one that has been following Lwan for a
while, might have noticed that portability has been mentioned a few
times in this article. This was not a concern a few years ago, but since
then, Lwan has been ported to work on BSD systems as well (mostly by
implementing epoll on top of kqueue, and providing a sendfile I/O
wrapper that works regardless of the underlying system), although it has
been only tested on FreeBSD, macOS, and OpenBSD. (Recent OpenBSDs might
require some tinkering, as they enforce the stack pointer to be within
pages mapped with a specific flag.)</p>
<p>You can read more about how portability has been achieved by reading my
<a class="reference external" href="https://tia.mat.br/posts/2018/06/28/include_next_and_portability.html">blog post on using the non-standard #include_next preprocessor
directive</a>,
which saved me from writing abstraction layers.</p>
</div>
<div class="section" id="declaring-new-lua-metamethods">
<h1>Declaring new Lua metamethods</h1>
<p>Another change that might improve the comfort of people using Lwan with
Lua scripts is that it’s easier to add new metamethods to the request
table.</p>
<p>One just declares a new C function with the <span class="docutils literal"><span class="pre">LWAN_LUA_METHOD</span></span> macro,
and, during startup, Lwan will attach that function to the request
metatable as a metamethod. (One can call
<span class="docutils literal"><span class="pre">lwan_lua_get_request_from_userdata()</span></span> to obtain a
<span class="docutils literal"><span class="pre">struct</span> <span class="pre">lwan_request</span> <span class="pre">*</span></span> from the first parameter in the C
implementation of one of these metamethods.)</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="n">LWAN_LUA_METHOD</span><span class="p">(</span><span class="n">say</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">struct</span> <span class="n">lwan_request</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="n">lwan_lua_get_request_from_userdata</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
    <span class="n">size_t</span> <span class="n">response_str_len</span><span class="p">;</span>
    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">response_str</span> <span class="o">=</span> <span class="n">lua_tolstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">response_str_len</span><span class="p">);</span>

    <span class="n">lwan_strbuf_set_static</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">response</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">response_str</span><span class="p">,</span>
                           <span class="n">response_str_len</span><span class="p">);</span>
    <span class="n">lwan_response_send_chunk</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This macro works by adding a struct to a certain section in the
executable, so new application-specific metamethods can be linked
together with Lwan without having to modify Lwan itself.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="c1">#define LWAN_LUA_METHOD(name_)                                                 \</span>
    <span class="n">static</span> <span class="nb">int</span> <span class="n">lwan_lua_method_</span><span class="c1">##name_(lua_State *L);                          \</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">struct</span> <span class="n">lwan_lua_method_info</span>                                   \
        <span class="n">__attribute__</span><span class="p">((</span><span class="n">used</span><span class="p">,</span> <span class="n">section</span><span class="p">(</span><span class="n">LWAN_SECTION_NAME</span><span class="p">(</span><span class="n">lwan_lua_method</span><span class="p">))))</span>     \
            <span class="n">lwan_lua_method_info_</span><span class="c1">##name_ = {.name = #name_,                    \</span>
                                            <span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">lwan_lua_method_</span><span class="c1">##name_};  \</span>
    <span class="n">static</span> <span class="nb">int</span> <span class="n">lwan_lua_method_</span><span class="c1">##name_(lua_State *L)</span>
</pre></div>
</div>
<p>All functions in <span class="docutils literal"><span class="pre">lwan-lua.c</span></span> are now implemented this way to serve as
an example on how to use this feature.</p>
</div>
<div class="section" id="declaring-handlers-and-modules">
<h1>Declaring Handlers and Modules</h1>
<p>In order to make it more portable, safer, and easier to declare a
handler function in Lwan, a macro similar to <span class="docutils literal"><span class="pre">LWAN_LUA_METHOD()</span></span> has
been provided: <span class="docutils literal"><span class="pre">LWAN_HANDLER()</span></span>. It will declare a handler function
and a <span class="docutils literal"><span class="pre">struct</span> <span class="pre">lwan_handler_info</span></span> in a specific section in the
executable, making it easier for the configuration file reader to find
it every time, regardless of how that platform exports symbols, make it
impossible to refer to any exported symbol as a handler from the
configuration file, and slightly simplifies declaring a handler function
(without requiring, for instance, changing tables to make the
configuration file reader happy).</p>
<p>Defining a handler with this macro is trivial:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="n">LWAN_HANDLER</span><span class="p">(</span><span class="n">brew_coffee</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">/*</span> <span class="n">Placeholder</span> <span class="n">handler</span> <span class="n">to</span> <span class="n">force</span> <span class="n">the</span> <span class="n">linker</span> <span class="n">to</span> <span class="n">define</span> <span class="n">__start_lwan_handler</span> <span class="ow">and</span>
     <span class="o">*</span> <span class="n">__stop_lwan_handler</span><span class="o">.</span>  <span class="o">*/</span>
    <span class="k">return</span> <span class="n">HTTP_I_AM_A_TEAPOT</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As is looking it up (the linker does the job of registering each
handler):</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="n">__attribute__</span><span class="p">((</span><span class="n">no_sanitize_address</span><span class="p">))</span>
<span class="n">static</span> <span class="n">void</span> <span class="o">*</span><span class="n">find_handler</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">extern</span> <span class="n">const</span> <span class="n">struct</span> <span class="n">lwan_handler_info</span> <span class="n">SECTION_START</span><span class="p">(</span><span class="n">lwan_handler</span><span class="p">);</span>
    <span class="n">extern</span> <span class="n">const</span> <span class="n">struct</span> <span class="n">lwan_handler_info</span> <span class="n">SECTION_END</span><span class="p">(</span><span class="n">lwan_handler</span><span class="p">);</span>
    <span class="n">const</span> <span class="n">struct</span> <span class="n">lwan_handler_info</span> <span class="o">*</span><span class="n">handler</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">handler</span> <span class="o">=</span> <span class="n">__start_lwan_handler</span><span class="p">;</span> <span class="n">handler</span> <span class="o">&lt;</span> <span class="n">__stop_lwan_handler</span><span class="p">;</span>
         <span class="n">handler</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">streq</span><span class="p">(</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A similar feature has been provided for modules, making it even possible
to list them from the Lwan command-line (<span class="docutils literal"><span class="pre">lwan</span> <span class="pre">-m</span></span> and <span class="docutils literal"><span class="pre">lwan</span> <span class="pre">-H</span></span> to
list modules and handlers, respectively). However, instead of specifying
a function as with <span class="docutils literal"><span class="pre">LWAN_HANDLER()</span></span>, one specifies a
<span class="docutils literal"><span class="pre">struct</span> <span class="pre">lwan_module</span></span> with <span class="docutils literal"><span class="pre">LWAN_REGISTER_MODULE()</span></span>.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="n">static</span> <span class="n">const</span> <span class="n">struct</span> <span class="n">lwan_module</span> <span class="n">module</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">serve_files_create</span><span class="p">,</span>
    <span class="o">.</span><span class="n">create_from_hash</span> <span class="o">=</span> <span class="n">serve_files_create_from_hash</span><span class="p">,</span>
    <span class="o">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">serve_files_destroy</span><span class="p">,</span>
    <span class="o">.</span><span class="n">handle_request</span> <span class="o">=</span> <span class="n">serve_files_handle_request</span><span class="p">,</span>
    <span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">HANDLER_PARSE_ACCEPT_ENCODING</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">LWAN_REGISTER_MODULE</span><span class="p">(</span><span class="n">serve_files</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">module</span><span class="p">);</span>
</pre></div>
</div>
<p>In all cases, the only symbol that ends up being visible is the
associated <span class="docutils literal"><span class="pre">_info</span></span> struct; the handler function and module struct are
not exported.</p>
</div>
<div class="section" id="changes-to-the-string-buffer">
<h1>Changes to the String Buffer</h1>
<p>A HTTP/1.x server is essentially a program that transforms strings into
strings over a network connection, so some sort of facility to create
them efficiently is often desired. In Lwan, this is <span class="docutils literal"><span class="pre">struct</span> <span class="pre">strbuf</span></span>,
which has seen some trivial changes over the years, mainly to reduce the
amount of memory they need to work with (as every request struct has to
carry one of them).</p>
<p>It initially had two fields, <span class="docutils literal"><span class="pre">used</span></span> and <span class="docutils literal"><span class="pre">capacity</span></span>, where
<span class="docutils literal"><span class="pre">capacity</span></span> would be always the next power of two after <span class="docutils literal"><span class="pre">used</span></span> (and
the buffer would be reallocated accordingly). The <span class="docutils literal"><span class="pre">capacity</span></span> field has
now been removed; it’s now derived from <span class="docutils literal"><span class="pre">used</span></span>, as it’s cheap to align
to the next power of two to calculate it whenever needed.</p>
<p>Each connection triggered the allocation of a buffer for its associated
request <span class="docutils literal"><span class="pre">struct</span> <span class="pre">strbuf</span></span>, even if it might not be used (e.g. for
streaming requests, such as file serving). A <span class="docutils literal"><span class="pre">strbuf</span></span> is now
initialized pointing to an empty static string (with the <span class="docutils literal"><span class="pre">STATIC</span></span> flag
set); that’ll delay the allocation for when it’s truly needed. The
following table builds on the results from the coroutine optimizations,
optimizing the base case even further:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%"/>
<col width="40%"/>
<col width="38%"/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Connection</th>
<th class="head">Malloc Calls Before</th>
<th class="head">Malloc Calls After</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Keep-Alive</td>
<td>931</td>
<td>831</td>
</tr>
<tr class="row-odd"><td>Close</td>
<td>200,731</td>
<td>100,728</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="hash-table-changes">
<h1>Hash Table Changes</h1>
<p>The hash table has also seen some changes, most notably the ability to
rehash (although the heuristic to determine if rehashing is required
might need some work). The hash value is kept alongside each bucket
element, slightlyy alleviating the cost.</p>
<p>Another simple change that has been implemented is that, when an entry
is removed from a bucket, instead of defragmenting that bucket, the last
element is copied on top of the element being removed. Since order in a
bucket isn’t important, this made removing elements quite a bit more
efficient (and given that the hash table is an integral part of the
cache subsystem, this is important to keep the write lock locked for the
minimum amount of time.)</p>
<p>I’ve experimented with other techniques to implement a hash table,
including using robin-hood hashing, but I’m keeping it this way for the
moment. It’s something I want to revisit someday. (Also played with
hashing functions, including using AES-NI instructions instead of the
CRC32C from SSE4.2, but never got as far as integrating the experiments
in Lwan.)</p>
</div>
<div class="section" id="gracefully-closing-sockets">
<h1>Gracefully Closing Sockets</h1>
<p>The other day I received a bug report where pages served by Lwan and
loaded by W3M would take a long time to load. Not only this is unusual
because someone is actually using Lwan, but also because someone is
actually using W3M in 2019. Nevertheless, this was an interesting bug
with a simple fix: W3M implements only HTTP/1.0, and until the server
closes the connection, it won’t start parsing and displaying the results
(the connection would be closed after the keep-alive timeout was
reached, which is roughly 15s); now Lwan closes the connection as soon
as it’s done processing it, if it’s not marked as keep-alive. Easy to
spot using something like <span class="docutils literal"><span class="pre">strace</span></span>.</p>
<p>Closing a TCP socket, however, isn’t as simple as just calling
<span class="docutils literal"><span class="pre">close()</span></span>: there might be some enqueued packets not yet acknowledged
by the peer, so the usual solution to this is to call
<span class="docutils literal"><span class="pre">shutdown(fd,</span> <span class="pre">SHUT_WR)</span></span> to stop any kind of transmission and wait on a
loop calling <span class="docutils literal"><span class="pre">read()</span></span> until it returns <span class="docutils literal"><span class="pre">0</span></span> (signaling that the peer
has closed the connection), at which point it’s safe to just call
<span class="docutils literal"><span class="pre">close()</span></span> and consider that the connection has been closed.</p>
<p>However, from my testing, the scenario where one actually needs to wait
on a <span class="docutils literal"><span class="pre">read()</span></span> loop isn’t that common, especially with the big fat
pipes that are common these days; so, in order to minimize the number of
system calls made in the happy path, Lwan now checks if there are any
pending bytes to be sent/acknowledged by the peer before proceeding with
the usual method. This should equate to 2 system calls to close a
connection (the <span class="docutils literal"><span class="pre">ioctl()</span></span> and <span class="docutils literal"><span class="pre">close()</span></span>), rather than at least 3
(<span class="docutils literal"><span class="pre">shutdown()</span></span> + <span class="docutils literal"><span class="pre">read()</span></span> + <span class="docutils literal"><span class="pre">close()</span></span>) in the happy path.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/>static void graceful_close(struct lwan *l,
                           struct lwan_connection *conn,
                           char buffer[static DEFAULT_BUFFER_SIZE])
{
    int fd = lwan_connection_get_fd(l, conn);

    while (TIOCOUTQ) {
        /* This ioctl isn't probably doing what it says on the tin; the details
         * are subtle, but it seems to do the trick to allow gracefully closing
         * the connection in some cases with minimal system calls. */
        int bytes_waiting;
        int r = ioctl(fd, TIOCOUTQ, &amp;bytes_waiting);

        if (!r &amp;&amp; !bytes_waiting) /* See note about close(2) below. */
            return;
        if (r &lt; 0 &amp;&amp; errno == EINTR)
            continue;

        break;
    }

    if (UNLIKELY(shutdown(fd, SHUT_WR) &lt; 0)) {
        if (UNLIKELY(errno == ENOTCONN))
            return;
    }

    for (int tries = 0; tries &lt; 20; tries++) {
        ssize_t r = read(fd, buffer, DEFAULT_BUFFER_SIZE);

        if (!r)
            break;

        if (r &lt; 0) {
            switch (errno) {
            case EINTR:
                continue;
            case EAGAIN:
                coro_yield(conn-&gt;coro, CONN_CORO_WANT_READ);
                continue;
            default:
                return;
            }
        }

        coro_yield(conn-&gt;coro, CONN_CORO_YIELD);
    }

    /* close(2) will be called when the coroutine yields with CONN_CORO_ABORT */
}
</pre></div>
</div>
<p>(On platforms where that <span class="docutils literal"><span class="pre">ioctl()</span></span> isn’t available, the usual method
is used instead. <span class="docutils literal"><span class="pre">TIOCOUTQ</span></span> is Linux-specific, but it’s defined to
<span class="docutils literal"><span class="pre">0</span></span> or the equivalent value in other OSes with some <span class="docutils literal"><span class="pre">#include_next</span></span>
magic, so that the <span class="docutils literal"><span class="pre">while()</span></span> loop there works as a loop to both handle
the <span class="docutils literal"><span class="pre">ioctl()</span></span> call being interrupted and check if that <span class="docutils literal"><span class="pre">ioctl</span></span> is
available on that platform.)</p>
</div>
<div class="section" id="mime-type-table-improvements">
<h1>MIME Type table improvements</h1>
<p>Lwan contains an internal MIME Type table based on the public domain
table made for the Apache httpd project. The same file is used by
<span class="docutils literal"><span class="pre">mimegen</span></span>, a program built and used only during build time, that
generates a header file containing data suitable to be searched with
<span class="docutils literal"><span class="pre">bsearch()</span></span>. (The data in the header file is also compressed, saving a
few dozen kilobytes in the final executable.)</p>
<p>The table was initially laid out as an array of
<span class="docutils literal"><span class="pre">struct</span> <span class="pre">{</span> <span class="pre">const</span> <span class="pre">char</span> <span class="pre">*extension;</span> <span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mime_type;</span> <span class="pre">}</span></span>, all
pointing to different positions within a character array. In other
words, not only only 4 entries could fit in a cache line (assuming
x86-64 here, with 8-byte pointers and 64-byte cache lines), each access
would mean that other cache lines had to be used to proxy the character
array.</p>
<p>With some trivial changes, this has been significantly improved: instead
of having a single table with extension+type, two (in-sync) tables are
provided. Search happens only in the first table; once an item is found
there, its position within the first table is used as an index in the
second table. This greatly reduces the cache pressure (each item in the
first table is fixed at 8 characters, so double the cache density for
<span class="docutils literal"><span class="pre">bsearch()</span></span> to breeze through quickly).</p>
<p>The change in the function to look up a MIME type given a file name
didn’t change much from 2014:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/>const char *
lwan_determine_mime_type_for_file_name(const char *file_name)
{
    char *last_dot = strrchr(file_name, '.');
    if (UNLIKELY(!last_dot))
        goto fallback;

    STRING_SWITCH_L(last_dot) {
    case STR4_INT_L('.','j','p','g'):  return "image/jpeg";
    case STR4_INT_L('.','p','n','g'):  return "image/png";
    case STR4_INT_L('.','h','t','m'):  return "text/html";
    case STR4_INT_L('.','c','s','s'):  return "text/css";
    case STR4_INT_L('.','t','x','t'):  return "text/plain";
    case STR4_INT_L('.','j','s',0x20): return "application/javascript";
    }

    if (LIKELY(*last_dot)) {
        char *extension, *key = last_dot + 1;

        extension = bsearch(key, uncompressed_mime_entries, MIME_ENTRIES, 8,
                            compare_mime_entry);
        if (LIKELY(extension))
            return mime_types[(extension - (char*)uncompressed_mime_entries) / 8];
    }

fallback:
    return "application/octet-stream";
}
</pre></div>
</div>
<p>This idea is far from novel; in fact, it’s common in video-game
development and is known as <a class="reference external" href="https://en.wikipedia.org/wiki/Data-oriented_design">data-oriented
design</a>.</p>
<p>(I investigated the possibility of using
<a class="reference external" href="https://www.gnu.org/software/gperf/">gperf</a> here instead, but
decided against it as this would require two build-time programs instead
of one for this feature.)</p>
</div>
<div class="section" id="accepting-clients">
<h1>Accepting Clients</h1>
<p>While it’s possible to wake a worker thread blocked on <span class="docutils literal"><span class="pre">epoll_wait()</span></span>
by adding a file descriptor to its watched set (by watching <span class="docutils literal"><span class="pre">EPOLLOUT</span></span>
instead of <span class="docutils literal"><span class="pre">EPOLLIN</span></span>, even though you want to read from the socket
before sending a response, as counter-intuitive as this might sound), I
found that this isn’t the best approach. (Don’t know why yet, though.)</p>
<p>Until recently, Lwan was using a pipe to send the file descriptor number
from the main thread (which accepts the connection) to the worker thread
that would forever own it. This worked well, but meant that every new
connection would require at least two system calls that were unrelated
to actually handling the connections: <span class="docutils literal"><span class="pre">accept4()</span></span> and <span class="docutils literal"><span class="pre">write()</span></span>.
While pipes aren’t exactly slow (they’re just buffers in the kernel
anyway), it’s still a lot of overhead to write 4 bytes to another thread
in the same process.</p>
<p>Recent versions of Lwan uses a different approach: a lock-free
single-producer-single-consumer queue and an <span class="docutils literal"><span class="pre">eventfd</span></span>, are used to
queue file descriptors until the “horde” has passed (or the queue got
full). (While the main thread is accepting connections, it’s handling a
“horde”; once <span class="docutils literal"><span class="pre">accept4()</span></span> returns a <span class="docutils literal"><span class="pre">EAGAIN</span></span> error, the horde is
gone and the main thread can proceed.) The eventfd is then used to wake
up the worker thread (“nudging” in Lwan jargon), at which point it
proceeds to add the file descriptors to the sets, creates the associated
coroutines, and stuff like this.</p>
<p>In <span class="docutils literal"><span class="pre">lwan-thread.c</span></span>, we define a function that tries adding a new
client to a worker thread a few times, dropping the connection if that
worker thread is somehow hosed even after repeated attempts at nudging
it:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/>void lwan_thread_add_client(struct lwan_thread *t, int fd)
{
    for (int i = 0; i &lt; 10; i++) {
        bool pushed = spsc_queue_push(&amp;t-&gt;pending_fds, fd);

        if (LIKELY(pushed))
            return;

        /* Queue is full; nudge the thread to consume it. */
        lwan_thread_nudge(t);
    }

    lwan_status_error("Dropping connection %d", fd);
    /* FIXME: send "busy" response now, even without receiving request? */
    close(fd);
}
</pre></div>
</div>
<p>And in <span class="docutils literal"><span class="pre">lwan.c</span></span>, you can see how the coroutine that handles incoming
connections batches each incoming herd and minimizes the amount of
nudges to wake up the worker threads:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="n">static</span> <span class="n">ALWAYS_INLINE</span> <span class="nb">int</span> <span class="n">schedule_client</span><span class="p">(</span><span class="n">struct</span> <span class="n">lwan</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="nb">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">struct</span> <span class="n">lwan_thread</span> <span class="o">*</span><span class="n">thread</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">conns</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="o">.</span><span class="n">thread</span><span class="p">;</span>

    <span class="n">lwan_thread_add_client</span><span class="p">(</span><span class="n">thread</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">Connections</span> <span class="n">are</span> <span class="n">pre</span><span class="o">-</span><span class="n">scheduled</span><span class="p">,</span> <span class="n">but</span> <span class="n">we</span> <span class="n">need</span> <span class="n">a</span> <span class="n">thread</span> <span class="n">index</span><span class="p">,</span> <span class="ow">not</span> <span class="n">a</span>
     <span class="o">*</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">lwan_thread</span><span class="o">.</span> <span class="o">*/</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">thread</span> <span class="o">-</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">thread</span><span class="o">.</span><span class="n">threads</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">/*</span> <span class="n">Using</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="ow">and</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">enumeration</span> <span class="n">values</span> <span class="n">allows</span> <span class="n">you</span> <span class="n">to</span> <span class="n">test</span> <span class="n">them</span>
 <span class="o">*</span> <span class="n">using</span> <span class="n">only</span> <span class="n">comparisons</span> <span class="k">with</span> <span class="mf">0.</span>  <span class="o">*/</span>
<span class="n">enum</span> <span class="n">herd_accept</span> <span class="p">{</span> <span class="n">HERD_MORE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HERD_GONE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">HERD_SHUTDOWN</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>

<span class="n">struct</span> <span class="n">core_bitmap</span> <span class="p">{</span>
    <span class="n">uint64_t</span> <span class="n">bitmap</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="o">/*</span> <span class="mi">256</span> <span class="n">processors</span> <span class="n">should</span> <span class="n">be</span> <span class="n">enough</span> <span class="k">for</span> <span class="n">everybody</span> <span class="o">*/</span>
<span class="p">};</span>

<span class="n">static</span> <span class="n">ALWAYS_INLINE</span> <span class="n">enum</span> <span class="n">herd_accept</span>
<span class="n">accept_one</span><span class="p">(</span><span class="n">struct</span> <span class="n">lwan</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">struct</span> <span class="n">core_bitmap</span> <span class="o">*</span><span class="n">cores</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">accept4</span><span class="p">((</span><span class="nb">int</span><span class="p">)</span><span class="n">main_socket</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">SOCK_NONBLOCK</span> <span class="o">|</span> <span class="n">SOCK_CLOEXEC</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="nb">int</span> <span class="n">core</span> <span class="o">=</span> <span class="n">schedule_client</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>

        <span class="n">cores</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">[</span><span class="n">core</span> <span class="o">/</span> <span class="mi">64</span><span class="p">]</span> <span class="o">|=</span> <span class="n">UINT64_C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">core</span> <span class="o">%</span> <span class="mi">64</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">HERD_MORE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">switch</span> <span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">case</span> <span class="n">EAGAIN</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">HERD_GONE</span><span class="p">;</span>

    <span class="n">case</span> <span class="n">EBADF</span><span class="p">:</span>
    <span class="n">case</span> <span class="n">ECONNABORTED</span><span class="p">:</span>
    <span class="n">case</span> <span class="n">EINVAL</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">main_socket</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">lwan_status_info</span><span class="p">(</span><span class="s2">"Signal 2 (Interrupt) received"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">lwan_status_info</span><span class="p">(</span><span class="s2">"Main socket closed for unknown reasons"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">HERD_SHUTDOWN</span><span class="p">;</span>

    <span class="n">default</span><span class="p">:</span>
        <span class="n">lwan_status_perror</span><span class="p">(</span><span class="s2">"accept"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">HERD_MORE</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">static</span> <span class="nb">int</span> <span class="n">accept_connection_coro</span><span class="p">(</span><span class="n">struct</span> <span class="n">coro</span> <span class="o">*</span><span class="n">coro</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">struct</span> <span class="n">lwan</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">core_bitmap</span> <span class="n">cores</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">coro_yield</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">EPOLLHUP</span> <span class="o">|</span> <span class="n">EPOLLRDHUP</span> <span class="o">|</span> <span class="n">EPOLLERR</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">enum</span> <span class="n">herd_accept</span> <span class="n">ha</span><span class="p">;</span>

        <span class="n">do</span> <span class="p">{</span>
            <span class="n">ha</span> <span class="o">=</span> <span class="n">accept_one</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cores</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ha</span> <span class="o">==</span> <span class="n">HERD_MORE</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">ha</span> <span class="o">&gt;</span> <span class="n">HERD_MORE</span><span class="p">))</span>
            <span class="k">break</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">A</span> <span class="n">thread</span> <span class="n">bitmap</span> <span class="ow">is</span> <span class="n">maintained</span><span class="p">:</span> <span class="n">accept_one</span><span class="p">()</span> <span class="n">will</span> <span class="nb">set</span> <span class="n">the</span> <span class="n">nth</span> <span class="n">bit</span>
     <span class="o">*</span> <span class="n">to</span> <span class="n">signify</span> <span class="n">that</span> <span class="n">the</span> <span class="n">nth</span> <span class="n">thread</span> <span class="n">needs</span> <span class="n">to</span> <span class="n">be</span> <span class="n">nudged</span><span class="o">.</span>  <span class="n">This</span> <span class="n">loop</span>
     <span class="o">*</span> <span class="n">will</span> <span class="n">then</span> <span class="n">quickly</span> <span class="n">go</span> <span class="n">through</span> <span class="n">every</span> <span class="nb">set</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">that</span> <span class="n">bitmap</span> <span class="ow">and</span>
     <span class="o">*</span> <span class="n">nudge</span> <span class="n">the</span> <span class="n">appropriate</span> <span class="n">thread</span><span class="o">.</span> <span class="o">*/</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_ELEMENTS</span><span class="p">(</span><span class="n">cores</span><span class="o">.</span><span class="n">bitmap</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cores</span><span class="o">.</span><span class="n">bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">c</span><span class="p">;</span> <span class="n">c</span> <span class="o">^=</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">size_t</span> <span class="n">core</span> <span class="o">=</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span><span class="n">__builtin_ctzl</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                <span class="n">lwan_thread_nudge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">thread</span><span class="o">.</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">64</span> <span class="o">+</span> <span class="n">core</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cores</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">cores</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>On any other platform other than Linux, a pipe is used for the same
effect; it just doesn’t scale as well (requires two file descriptors per
worker thread instead of just one, allocates a larger kernel buffer for
no purpose whatsoever, etc.).</p>
<p>Weirdly enough, as much as the approach of adding the client sockets
directly to the worker thread’s epoll set with an <span class="docutils literal"><span class="pre">EPOLLOUT</span></span> event
rather than using this queue+eventfd mechanism reduced the amount of
system calls, the throughput when using non-keeepalive connections has
been measurably reduced (and not just in the noise). I don’t know why,
and haven’t investigated this yet.</p>
<p>(The current approach limits the number of worker threads that Lwan can
spawn, as threads are only nudged when connections have been assigned to
them. Currently it’s at 256 threads, which is fine for many systems
today – and certainly way better than any machine I have access to.)</p>
</div>
<div class="section" id="sample-programs">
<h1>Sample programs</h1>
<div class="section" id="freegeoip">
<h2>FreeGeoIP</h2>
<p>One of the first sample applications that I’ve written for Lwan was an
implementation of the <span class="docutils literal"><span class="pre">freegeoip.net</span></span> service. It’s been working fine
so far, serving a few hundred thousands requests per day (down from a
few million per day), using around 3MB of memory. It’s also pretty
stable: the server has been recently rebooted to update the kernel, and
before this happened, I observed that the service was chugging along for
over a year.</p>
<p>I’m pretty pleased with this, especially if one considers that the
original service that this has been cloned from caused a lot of
maintenance headache and was eventually abandoned.</p>
<p>There’s a <a class="reference external" href="https://freegeoip.lwan.ws">live version of this application running
here</a>.</p>
</div>
<div class="section" id="clock">
<h2>Clock</h2>
<p>A newer sample is the clock application. This generates a never-ending
GIF file, served with chunked encoding, that draws the current time in a
variety of styles: something that resembles a 7-segment display;
<a class="reference external" href="https://www.jwz.org/xdaliclock/">xdaliclock</a>; and a Tetris-like
animation (where falling blocks are rotated until they fit and form
digits).</p>
<p>This is but a hack, so it doesn’t work in all browsers (it’s known to be
broken on Safari for instance), but in supported ones, it’s a cheap way
to make animations without JavaScript, or to stream content from a
server.</p>
<div class="figure align-center" id="id1">
<img alt="xdaliclock rendered on-the-fly" src="https://time.lwan.ws/dali.gif"/>
<p class="caption"><span class="caption-text">Look at those melting digits! No JavaScript or CSS required.</span></p>
</div>
<p>(And, of course, the “never-ending” aspect isn’t actually correct. Bots
would try to download the GIFs, without any kind of timeout. I’ve seen
bots trying to download those for days. It now forces the page to be
reloaded every hour and limits each GIF to a little bit more than that.
Implement timeouts when writing crawlers, people.)</p>
<p>There’s a <a class="reference external" href="https://time.lwan.ws">live version of this application running
here</a>.</p>
</div>
</div>
<div class="section" id="proxy-protocol">
<h1>Proxy Protocol</h1>
<p>Putting Lwan behind a proxy is a common scenario to workaround the lack
of two features: virtual hosts and TLS. Both are somewhat trivial to
implement, but I haven’t gotten around supporting any of them because,
in my use case, I’m perfectly happy to stick a
<a class="reference external" href="https://www.varnish-cache.org">Varnish</a> cache and a <a class="reference external" href="https://hitch-tls.org/">TLS
terminator</a> in front of it. In order to allow
functions such as <span class="docutils literal"><span class="pre">lwan_request_get_remote_address()</span></span> to return the
correct client address (instead of, say, <span class="docutils literal"><span class="pre">::1</span></span>), Lwan has to be aware
that it’s being proxied.</p>
<p>A popular protocol for this, pioneered by
<a class="reference external" href="http://www.haproxy.org/">HAProxy</a>, is aptly named <a class="reference external" href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt">PROXY
protocol</a>.
An implementation for both versions 1 and 2 has been contributed to Lwan
by Malthe Borch as one of the first open source contributions to Lwan;
thank you very much! (This is disabled by default because it should only
be used if Lwan is known to be behind a reverse proxy. Inadvertently
enabling it would allow anyone to easily spoof the client IP address to
request handlers.)</p>
<p>(I did investigate using
<a class="reference external" href="https://netdevconf.info/1.2/papers/ktls.pdf">kTLS</a>, but didn’t go
that far at the time as it wasn’t part of mainline Linux kernel. I might
give it a try someday now that it is, though.)</p>
</div>
<div class="section" id="websockets">
<h1>WebSockets</h1>
<p>Lwan has also gained the ability to function as a WebSockets server. The
protocol is trivial to implement (wonky handshaking and unoptimal
framing notwithstanding), but defining an API that’s usable from C is
quite challenging. I’ve tried a few combinations but never got to the
point where I could find something I liked; I have some ideas to try but
they’re still pretty fuzzy in my head.</p>
<p>The program below illustrates the current state of the API: while it
seems straightforward enough for an endpoint to check if a WebSocket
connection upgrade was requested by the client, and trivial to send
stuff over the wire, there are a few drawbacks with the current
situation:</p>
<ul class="simple">
<li>PING requests will only be processed by
<span class="docutils literal"><span class="pre">lwan_response_websocket_read()</span></span>; this example will never respond
to a PING packet and might be disconnected by a client.</li>
<li>Both the read and the write primitives are blocking; it’s not
possible to write something that can both wait for commands and
occasionally send data over the wire. It should be possible to, for
instance, write an echo server, but it’s not possible to implement
<a class="reference external" href="https://socket.io">socket.io</a> for instance.</li>
<li>There are currently no tests for WebSockets as well; testing is
performed manually by using the WebSockets inspection tool in web
browsers, but automated tests would be preferred. I suspect that
reading from a WebSocket is broken after a lot of unrelated changes
in the main loop.</li>
</ul>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="n">LWAN_HANDLER</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">/*</span> <span class="n">Requesting</span> <span class="n">an</span> <span class="n">upgrade</span> <span class="n">will</span> <span class="n">send</span> <span class="n">an</span> <span class="n">appropriate</span> <span class="n">response</span> <span class="k">if</span> <span class="n">the</span>
     <span class="o">*</span> <span class="n">request</span> <span class="n">contained</span> <span class="n">a</span> <span class="n">valid</span> <span class="n">handshake</span><span class="p">,</span> <span class="n">returning</span> <span class="n">HTTP</span> <span class="n">code</span> <span class="mi">101</span> <span class="ow">in</span> <span class="n">that</span>
     <span class="o">*</span> <span class="n">case</span><span class="o">.</span> <span class="n">Any</span> <span class="n">other</span> <span class="n">error</span> <span class="n">code</span> <span class="n">won</span><span class="s1">'t generate a default response,</span>
     <span class="o">*</span> <span class="n">so</span> <span class="n">the</span> <span class="n">handler</span> <span class="n">can</span> <span class="k">return</span> <span class="n">at</span> <span class="n">this</span> <span class="n">point</span><span class="o">.</span>
     <span class="o">*</span>
     <span class="o">*</span> <span class="n">Having</span> <span class="n">a</span> <span class="n">separate</span> <span class="n">function</span> <span class="n">to</span> <span class="n">upgrade</span> <span class="n">a</span> <span class="n">WebSocket</span> <span class="n">connection</span>
     <span class="o">*</span> <span class="p">(</span><span class="k">as</span> <span class="n">opposed</span> <span class="n">to</span> <span class="n">having</span> <span class="n">a</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">handler</span> <span class="n">that</span> <span class="n">would</span> <span class="k">try</span> <span class="n">to</span> <span class="n">do</span>
     <span class="o">*</span> <span class="n">this</span> <span class="n">automatically</span><span class="p">)</span> <span class="ow">is</span> <span class="n">useful</span> <span class="n">to</span> <span class="n">allow</span> <span class="n">people</span> <span class="n">to</span> <span class="n">write</span><span class="p">,</span> <span class="k">for</span> <span class="n">instance</span><span class="p">,</span>
     <span class="o">*</span> <span class="n">authorization</span> <span class="n">code</span> <span class="n">to</span> <span class="n">explicitly</span> <span class="n">upgrade</span> <span class="n">a</span> <span class="n">connection</span> <span class="n">only</span> <span class="k">if</span>
     <span class="o">*</span> <span class="n">certain</span> <span class="n">checks</span> <span class="n">passes</span><span class="o">.</span> <span class="o">*/</span>
    <span class="n">enum</span> <span class="n">lwan_http_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">lwan_request_websocket_upgrade</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">HTTP_SWITCHING_PROTOCOLS</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">/*</span> <span class="n">Similar</span> <span class="n">to</span> <span class="n">chunked</span> <span class="n">encoding</span> <span class="ow">and</span> <span class="n">server</span><span class="o">-</span><span class="n">sent</span> <span class="n">events</span><span class="p">,</span> <span class="n">the</span> <span class="n">response</span>
         <span class="o">*</span> <span class="n">string</span> <span class="n">buffer</span> <span class="n">contains</span> <span class="n">the</span> <span class="n">data</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">going</span> <span class="n">to</span> <span class="n">the</span> <span class="n">wire</span><span class="p">,</span> <span class="ow">or</span>
         <span class="o">*</span> <span class="n">data</span> <span class="n">that</span> <span class="n">was</span> <span class="n">received</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">wire</span><span class="o">.</span>  <span class="n">The</span> <span class="n">strbuf</span> <span class="ow">is</span> <span class="n">reset</span> <span class="n">every</span>
         <span class="o">*</span> <span class="n">time</span> <span class="n">a</span> <span class="n">response</span> <span class="ow">is</span> <span class="n">sent</span> <span class="ow">or</span> <span class="n">received</span><span class="o">.</span> <span class="o">*/</span>
        <span class="n">lwan_strbuf_printf</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s2">"Some random integer: </span><span class="si">%d</span><span class="s2">"</span><span class="p">,</span> <span class="n">rand</span><span class="p">());</span>
        <span class="n">lwan_response_websocket_write</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
        <span class="n">lwan_request_sleep</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">HTTP_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rewrite-module">
<h1>Rewrite Module</h1>
<p>Inspired by Apache httpd’s <span class="docutils literal"><span class="pre">mod_rewrite</span></span>, a module with similar
functionality has been implemented in Lwan. Instead of a bespoke syntax,
though, it can be set up using the same configuration file syntax;
albeit more verbose, it’s significantly easier to understand.</p>
<p>Based on <a class="reference external" href="https://www.lua.org/manual/5.3/manual.html#6.4.1">Lua’s pattern matching
engine</a>, which were
chosen because they’re not only powerful enough, but it’s also a
<a class="reference external" href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">DFA</a>,
which makes it a lot harder for an unbounded backreference to DoS the
server (as it doesn’t support any).</p>
<p>This is how it looks in the configuration file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/># Instantiate the "rewrite" module to respond in "/pattern".
rewrite /pattern {
    # Match /patternfoo..., and redirect to a new URL.
        pattern foo/(%d+)(%a)(%d+) {
                redirect to = /hello?name=pre%2middle%3othermiddle%1post
        }
    # Match /patternbar/... and rewrite as /hello...
        pattern bar/(%d+)/test {
                rewrite as = /hello?name=rewritten%1
        }
    # Use Lua to determine where the client should redirect to
        pattern lua/redir/(%d+)x(%d+) {
                expand_with_lua = true
                redirect to = '''
                    function handle_rewrite(req, captures)
                        local r = captures[1] * captures[2]
                        return '/hello?name=redirected' .. r
                    end
                '''
        }
    # Use Lua to determine how to rewrite the request
        pattern lua/rewrite/(%d+)x(%d+) {
                expand_with_lua = true
                rewrite as = """function handle_rewrite(req, captures)
                        local r = captures[1] * captures[2]
                        return '/hello?name=rewritten' .. r
                    end"""
        }
}
</pre></div>
</div>
<p>Without <span class="docutils literal"><span class="pre">expand_with_lua</span></span> set (or set to <span class="docutils literal"><span class="pre">false</span></span>), the expansion
rule is trivial: <span class="docutils literal"><span class="pre">%n</span></span> will expand to the n-th capture; everything else
will be copied verbatim. When set, a <span class="docutils literal"><span class="pre">handle_rewrite()</span></span> function has
to be defined; the <span class="docutils literal"><span class="pre">req</span></span> parameter contains the same metamethods
available for handlers in the <span class="docutils literal"><span class="pre">lua</span></span> module, and <span class="docutils literal"><span class="pre">captures</span></span> is a
table containing the pattern matches.</p>
<p>As a measure against bad configuration, URLs can’t be rewritten over 4
times (otherwise, a 500 Internal Error response is generated instead).</p>
<p>(This module prompted a change in the configuration file parser that
allows a section to be “isolated”: while the file is being read, if it’s
in a start section line, one can ask the configuration reader to isolate
the section. What this does is that it creates a proxy configuration
struct that has a view of only that particular section. This isolated
configuration object is passed to a module, that can read as usual
without having to worry about overreading the main configuration.)</p>
</div>
<div class="section" id="snippets">
<h1>Snippets</h1>
<div class="section" id="non-boolean-predicates">
<h2>Non-boolean predicates</h2>
<p>C lacks option types, but sometimes you can get creative with what you have.
For instance, I like how elegant this small piece of code that determines
the temporary directory turned out:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/>static const char *is_dir(const char *v)
{
    struct stat st;

    if (!v)
        return NULL;

    if (*v != '/')
        return NULL;

    if (stat(v, &amp;st) &lt; 0)
        return NULL;

    if (!S_ISDIR(st.st_mode))
        return NULL;

    if (!(st.st_mode &amp; S_ISVTX)) {
        lwan_status_warning(
            "Using %s as temporary directory, but it doesn't have "
            "the sticky bit set.",
            v);
    }

    return v;
}

static const char *
get_temp_dir(void)
{
    const char *tmpdir;

    tmpdir = is_dir(secure_getenv("TMPDIR"));
    if (tmpdir)
        return tmpdir;

    tmpdir = is_dir(secure_getenv("TMP"));
    if (tmpdir)
        return tmpdir;

    tmpdir = is_dir(secure_getenv("TEMP"));
    if (tmpdir)
        return tmpdir;

    tmpdir = is_dir("/var/tmp");
    if (tmpdir)
        return tmpdir;

    tmpdir = is_dir(P_tmpdir);
    if (tmpdir)
        return tmpdir;

    return NULL;
}
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">is_dir()</span></span> predicate returns the same input parameter if it turns
that its condition holds (or <span class="docutils literal"><span class="pre">NULL</span></span> if it doesn’t), and it is used to
drive the conditions in <span class="docutils literal"><span class="pre">get_temp_dir()</span></span> as well as the return value
for that function. I don’t think that this could get any cleaner.</p>
<p>(I was actually going to write a blog post on how to create temporary
files safely – which these funcions are part of – but <a class="reference external" href="https://systemd.io/TEMPORARY_DIRECTORIES">Lennart
Poettering</a> beat me to it.)</p>
</div>
<div class="section" id="boolean-flags-to-bitmask-without-branching">
<h2>Boolean flags to bitmask without branching</h2>
<p>Sometimes, it’s necessary to convert one set of bitwise mask into
another set of bitwise mask. Something like this:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="n">flag1</span><span class="p">)</span> <span class="n">flags</span> <span class="o">|=</span> <span class="n">SOME_BIT_MASK1</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">flag2</span><span class="p">)</span> <span class="n">flags</span> <span class="o">|=</span> <span class="n">SOME_BIT_MASK2</span><span class="p">;</span>
</pre></div>
</div>
<p>In order to get rid of those branches, one can extend the <span class="docutils literal"><span class="pre">bool</span></span> type
into <span class="docutils literal"><span class="pre">typeof(flags)</span></span>, and shift it by <span class="docutils literal"><span class="pre">log2(mask)</span></span>. Lwan does this
with some flags:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="c1">#define REQUEST_FLAG(bool_, name_)                                             \</span>
    <span class="p">((</span><span class="n">enum</span> <span class="n">lwan_request_flags</span><span class="p">)(((</span><span class="n">uint32_t</span><span class="p">)</span><span class="n">lwan</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>                  \
                               <span class="o">&lt;&lt;</span> <span class="n">REQUEST_</span><span class="c1">##name_##_SHIFT))</span>
<span class="n">static_assert</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">enum</span> <span class="n">lwan_request_flags</span><span class="p">)</span> <span class="o">==</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">uint32_t</span><span class="p">),</span>
              <span class="s2">"lwan_request_flags has the same size as uint32_t"</span><span class="p">);</span>
</pre></div>
</div>
<p>Which is then used like so:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span/><span class="n">enum</span> <span class="n">lwan_request_flags</span> <span class="n">flags</span> <span class="o">=</span>
        <span class="n">REQUEST_FLAG</span><span class="p">(</span><span class="n">proxy_protocol</span><span class="p">,</span> <span class="n">ALLOW_PROXY_REQS</span><span class="p">)</span> <span class="o">|</span>
        <span class="n">REQUEST_FLAG</span><span class="p">(</span><span class="n">allow_cors</span><span class="p">,</span> <span class="n">ALLOW_CORS</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        <div class="categories">
            <span>
                Filed under:
                <a href="categories/programming.html">programming</a></span>
        </div>
        <div class="tags">
            <span>
                Tags:
                <a href="tags/lwan.html">lwan</a></span>
        </div>
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>June 28, 2018</span>
        </div>
        <div class="section">
            <h1><a href="2018/06/28/include_next_and_portability.html">include_next and portability</a></h1>
<p>One of the decisions I took early on while writing Lwan was to only support
Linux, and think about portability later; this decision was influenced by the
way the <a class="reference external" href="https://www.openbsd.org/papers/portability.pdf">OpenBSD project approaches portability</a>.</p>
<p>In retrospect, this was a good decision: this avoided many of the pitfalls
associated in <a class="reference external" href="http://wiki.c2.com/?PrematureAbstraction">writing abstractions too early in the game</a>.  It also made the code cleaner:
the abundance of C preprocessor usage, common in some portable code, hinders
legibility and maintainability.  Of course, this decision made it
challenging to port it to other operating systems.</p>
<p>I was content with this decision – until people began asking for BSD and Mac
ports.  With the exception of some system calls (e.g.  epoll, or the Linux
<a class="reference external" href="http://man7.org/linux/man-pages/man2/sendfile.2.html">sendfile</a> variant), porting shouldn’t be surprising.  Ideally, having the code
largely <span class="docutils literal"><span class="pre">#ifdef</span></span> free would be ideal, so I had to find a way to make this happen.</p>
<p>While reading the GCC manual, I found out about an extension – that also
happens to be <a class="reference external" href="https://clang.llvm.org/docs/LanguageExtensions.html">implemented by Clang</a> – that fit perfectly
this scenario: <a class="reference external" href="https://gcc.gnu.org/onlinedocs/cpp/Wrapper-Headers.html">wrapper headers</a>.  It’s a C
preprocessor extension that includes the next file in the include lookup
path.  With this extension, it’s possible to write our own substitute header
files, named after standard header files:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span><span class="cpf">_next &lt;stdlib.h&gt; /* Include stdlib.h from system includes */</span><span class="cp"/>

<span class="cp">#ifndef MISSING_STDLIB_H_</span>
<span class="cp">#define MISSING_STDLIB_H_</span>

<span class="cp">#if !defined(HAVE_MKOSTEMP)</span>
<span class="kt">int</span> <span class="nf">mkostemp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(HAVE_REALLOCARRAY)</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">reallocarray</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">optr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* MISSING_STDLIB_H_ */</span><span class="cp"/>
</pre></div>
</div>
<p>Have it in a directory named, say, “missing”, and modify the header lookup path
so it is looked up first by the compiler.  This is easily accomplished in CMake
by specifying an include directory with the <span class="docutils literal"><span class="pre">BEFORE</span></span> option:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">include_directories</span><span class="p">(</span><span class="n">BEFORE</span> <span class="n">src</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">missing</span><span class="p">)</span>
</pre></div>
</div>
<p>(This just ensures that <span class="docutils literal"><span class="pre">src/lib/missing</span></span> will be passed before any other <span class="docutils literal"><span class="pre">-I</span></span>
argument to the compiler, regardless of the order any other
<span class="docutils literal"><span class="pre">include_directories()</span></span> macro is invoked.  Your build system might differ, this
is copied straight from Lwan’s.)</p>
<img alt="missing directory tree" class="align-right" src="https://i.imgur.com/c3ntvJL.png"/>
<p>Then it’s just the matter of implementing these functions in terms of other
functions available in the system, and code using it will be none the wise: a
<span class="docutils literal"><span class="pre">#include</span> <span class="pre">&lt;stdlib.h&gt;</span></span> line will include our wrapper header, which in turn will
include the system’s <span class="docutils literal"><span class="pre">stdlib.h</span></span> header; it then might define, in this example,
additional prototypes, based on what the build system could determine during the
configuration phase.</p>
<p>This way, most <span class="docutils literal"><span class="pre">#ifdefs</span></span> are hidden away in a single file, making it a lot easier
to maintain and read the code.  No application-specific abstraction layer with
quirky semantics; just the familiar quirkiness from POSIX.</p>
<p>One of the things I’m particular proud of is the miniature <a class="reference external" href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a> implementation on top
of <a class="reference external" href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2">kqueue</a>
(available in BSD systems).  I considered moving Lwan to use an abstraction
library (such as <a class="reference external" href="http://libevent.org/">libevent</a> or <a class="reference external" href="https://libuv.org/">libuv</a>) just for this, but was able to keep using its
event-handling loop as is.  Not only I understand 100% of it, it was a
worthwhile learning experience.  With ~120 lines of C code, this epoll
implementation is easier to wrap my head around than the thousands of lines
of code from those libraries.</p>

        </div>
        <div class="postmeta">
        
        
        
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>February 01, 2018</span>
        </div>
        <div class="section">
            <h1><a href="2018/02/01/more_on_string_switch_in_c.html">More on string switch in C</a></h1>
<p>Talking about uncommon programming tricks the other day, the subject of
switching on strings in C appeared on the table.</p>
<p>If you follow this blog, you know it’s something <a class="reference external" href="/posts/2012/08/09/string_switch_in_c.html">actually possible to do
with a little bit of ingenuity</a>; in fact, it’s one of the
things that I use in Lwan to parse the HTTP requests.  I didn’t spend too
much time in that blog post to explain why it is faster, so I’m rectifying
this now.</p>
<p>In order to understand why it’s so fast, let me step aside for a moment and
show a function every C programmer should be able to write: <span class="docutils literal"><span class="pre">strlen()</span></span>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span><span class="o">++</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Style issues aside, this is pretty much the simplest way to implement this
function.  And, maybe the one that generates the slowest code.  There are
many reasons here, so let’s explore some of them.</p>
<p>One of them is that CPUs are able to fetch more than a single byte at a time
from memory (or cache).  And it takes roughly the same time for it to fetch
8 bits than it takes to fetch 32 bits.  People that write C libraries know
about this fact, so that the version that your operating system provides is
most likely going to exploit this.  Let’s rewrite the <span class="docutils literal"><span class="pre">strlen()</span></span> function,
then:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>

        <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a big issue in this code: it is invoking undefined behavior.  The
explanation of why this is illegal in C will follow, but for now, let’s just
assume that the integer cast from a character pointer is valid.</p>
<p>With that assumption in mind, what this program is doing is in fact very
simple: it is reducing the amount of expensive operations (fetching things
from memory), and is increasing the amount of cheap operations (masking bits
and comparing integers).  In fact, that’s a recurring theme whenever you’re
trying to optimize any algorithm: the computer can’t run a piece of code faster,
but you can make the computer run smarter code that produces the same output.</p>
<p>This program, however, will most likely crash on some platforms, or be
really slow on others.  The reason is that it is trying to read a pointer
that is not aligned.  Some CPU designers decided to increase the complexity
and perform more work behind the scenes to make this work, and some decided
it wasn’t worth the trouble and will just generate an exception.  The major
problem, however, is that this is precisely the undefined behavior I was talking
about.  So, let’s fix this function, by modifying it slightly so that the fast
path operates on aligned pointers:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_ptr_aligned</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uintptr_t</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

    <span class="cm">/* Assuming a 32-bit machine with 4-byte alignment for</span>
<span class="cm">     * integers.  Executing "AND (n - 1)" is equivalent to "MOD</span>
<span class="cm">     * (n)", without an expensive division operation; this is</span>
<span class="cm">     * true for every (n), as long as (n) is a power of 2.</span>
<span class="cm">     * Compilers can do this optimization on constant values,</span>
<span class="cm">     * but I prefer to be explicit. */</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Read one byte at a time until the pointer is aligned. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_ptr_aligned</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
        <span class="n">len</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Pointer is aligned, try the faster version now. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>

        <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is still an even faster way, that is to improve the way the NUL byte
is found in a word.  The excellent (and one of my favorite websites) “<a class="reference external" href="https://graphics.stanford.edu/~seander/bithacks.html#ZeroInWord">Bit
Twiddling Hacks</a>” web
page has a method to find out if a word contains a NUL byte; it doesn’t tell
which byte is the NUL byte, but we don’t need to know that in the fast path:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">v</span><span class="p">;</span>

    <span class="cm">/* Read one byte at a time until the pointer is aligned. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_ptr_aligned</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
        <span class="n">len</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Pointer is aligned, try the faster version now. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>

        <span class="cm">/* Use a fast bit twiddling hack to find if the</span>
<span class="cm">         * next 4 bytes in the string has a 0 byte. If</span>
<span class="cm">         * it does, find out which byte it is. */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">-</span> <span class="mh">0x01010101</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0x80808080</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Another thing to consider in these functions is that they’re not endian
neutral.  A decent implementation would ensure that it would work both on
little-endian and on big-endian machines.  A decent programmer would even
build and test these; I didn’t.</p>
<p>Yet another thing to consider is that hand-tuned assembly versions, most
likely written to make use of vector instructions, are the ones that your
computer are executing at this very instant; but they all draw from these
very same ideas: read memory less often, compare in bulk.</p>
<p>Also, there are most likely better ways to write these functions, even without
vector instructions.  But this is besides the point of explaining why the
string switch trick works so well.</p>
<p>Now, this kind of optimization happens on pratically all string handling functions
in the C standard library.  And functions that perform substring comparison,
such as <span class="docutils literal"><span class="pre">strncmp()</span></span>, are no exception.</p>
<p>When faced with the necessity to check for a bunch of strings, the idiomatic
C way of doing so would be the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"GET "</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_GET</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"POST "</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_POST</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"DELETE "</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_DELETE</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"HEAD "</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_HEAD</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="k">return</span> <span class="n">HTTP_METHOD_UNKNOWN</span><span class="p">;</span>
</pre></div>
</div>
<p>It’s not difficult to imagine that each invocation of <span class="docutils literal"><span class="pre">strncmp()</span></span> would have to
do things that are similar to what our toy <span class="docutils literal"><span class="pre">strlen()</span></span> implementation had to do:
align the pointer (which is slow) before it could start the fast path.  But, in
this case, things are even worse, because, if the pointer isn’t aligned, it
might not even get to the point where the fast path will make sense, because the
strings it is comparing against are very close to the alignment of the word
size for this computer!</p>
<p>So, to recap, what the string switch does is the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">string_to_uint32</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">v</span><span class="p">;</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define STRING_SWITCH(s) switch (string_to_uint32(s))</span>
<span class="cp">#define MCC(a, b, c, d) ((a) &lt;&lt; 24 | (b) &lt;&lt; 16 | (c) &lt;&lt; 8 | (d))</span>
<span class="k">enum</span> <span class="p">{</span>
    <span class="n">METHOD_GET</span> <span class="o">=</span> <span class="n">MCC</span><span class="p">(</span><span class="sc">'G'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="sc">'T'</span><span class="p">,</span> <span class="sc">' '</span><span class="p">),</span>
    <span class="n">METHOD_POST</span> <span class="o">=</span> <span class="n">MCC</span><span class="p">(</span><span class="sc">'P'</span><span class="p">,</span> <span class="sc">'O'</span><span class="p">,</span> <span class="sc">'S'</span><span class="p">,</span> <span class="sc">'T'</span><span class="p">),</span>
    <span class="n">METHOD_DELETE</span> <span class="o">=</span> <span class="n">MCC</span><span class="p">(</span><span class="sc">'D'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="sc">'L'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">),</span>
    <span class="n">METHOD_HEAD</span> <span class="o">=</span> <span class="n">MCC</span><span class="p">(</span><span class="sc">'H'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">,</span> <span class="sc">'D'</span><span class="p">),</span>
    <span class="cm">/* ... */</span>
<span class="p">};</span>

<span class="n">STRING_SWITCH</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="nl">METHOD_GET</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_GET</span><span class="p">;</span>
<span class="k">case</span> <span class="nl">METHOD_POST</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_POST</span><span class="p">;</span>
<span class="k">case</span> <span class="nl">METHOD_DELETE</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_DELETE</span><span class="p">;</span>
<span class="k">case</span> <span class="nl">METHOD_HEAD</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_HEAD</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="k">default</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_UNKNOWN</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The good thing about the switch statement in C is that it is maybe the
highest level statement in the language: the compiler can get really
creative in how its code is generated.  It’s not uncommon for it to generate
jump tables or even binary searches.  So this implementation would actually
be faster than the various calls to <span class="docutils literal"><span class="pre">strncmp()</span></span> because:</p>
<ol class="arabic simple">
<li>Comparing integers is dirt cheap.</li>
<li>The compiler knows what <span class="docutils literal"><span class="pre">memcpy()</span></span> does, so it’s very likely that on
architectures where unaligned memory access is fine and there’s no
performance penalty (any Intel Core CPU after Sandy Bridge for instance),
it’ll be just a regular old MOV instruction when the size is small
and known at compile time.</li>
<li>Even if the compiler didn’t know what <span class="docutils literal"><span class="pre">memcpy()</span></span> does, it would only
fill a register once, by doing potentially expensive byte-by-byte copies
because of unaligned pointer access, and then proceed to just compare
integers.</li>
<li>There is less function call overhead; specially nice since this is
most likely not going through the PLT.</li>
<li>The compiler can reorder the comparisons as it see fit, often producing
very tight code.</li>
</ol>
<p>These kinds of micro-optimizations don’t necessarily have to be completely
unreadable and full of magical constants.</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        
        <div class="tags">
            <span>
                Tags:
                <a href="tags/lwan.html">lwan</a>, <a href="tags/programming.html">programming</a>, <a href="tags/trick.html">trick</a>, <a href="tags/c.html">C</a></span>
        </div>
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>May 08, 2017</span>
        </div>
        <div class="section">
            <h1><a href="2017/05/08/coreboot_luks.html">Coreboot &amp; LUKS</a></h1>
<p>My laptop is a 6-year old <a class="reference external" href="http://www.thinkwiki.org/wiki/Category:X220">ThinkPad X220</a>.  Although it’s almost
falling apart from years of constant abuse, I don’t see myself replacing it
anytime soon: it’s easy to repair, has a great keyboard, and is a very
dependable machine.</p>
<p>And it’s supported by <a class="reference external" href="https://en.wikipedia.org/wiki/Coreboot">Coreboot</a>.
Substituting the proprietary firmware with it is very trivial: I followed
the instructions on <a class="reference external" href="https://tylercipriani.com/blog/2016/11/13/coreboot-on-the-thinkpad-x220-with-a-raspberry-pi/">this blog post</a>
and they worked out of the box.  (I also went the extra mile and flashed the
firmware after passing it through <a class="reference external" href="https://github.com/corna/me_cleaner">me_cleaner</a>.)</p>
<div class="figure align-center" id="id1">
<img alt="flashing X220 bios" src="https://i.imgur.com/97rTiZH.jpg"/>
<p class="caption"><span class="caption-text">Flashing the serial flash using a Raspberry Pi 3. Yes, I need to clean
up this computer.</span></p>
</div>
<p>The major difference from my previous setup is that my SSD had
<a class="reference external" href="https://en.wikipedia.org/wiki/Hardware-based_full_disk_encryption">hardware-based full disk encryption</a>.  I
ended up disabling this for two reasons: first, this isn’t very secure (the
key will remain in the disk RAM for as long as power is supplied); second, I
was not sure if Coreboot supported this.  So I disabled encryption prior to
flashing the new firmware.</p>
<p>But keeping a hard drive unencrypted on a laptop isn’t good practice.  I
decided to use <a class="reference external" href="https://en.wikipedia.org/wiki/Linux_Unified_Key_Setup">LUKS</a>
instead.</p>
<p>However, instead of using <a class="reference external" href="https://en.wikipedia.org/wiki/SeaBIOS">SeaBIOS</a>
as the payload and have a standard bootloader, I opted to go through a
slightly different route: have a custom-built Linux inside the ROM, open the
<span class="docutils literal"><span class="pre">/boot</span></span> partition with LUKS, and
<a class="reference external" href="http://man7.org/linux/man-pages/man2/kexec_load.2.html">kexec</a> the current
vmlinuz/initrd.</p>
<p>Compared to the usual setup of using SeaBIOS as a payload, this setup
reduces boot time by cutting the middlemen.  With the ability to boot from
external devices removed, it’s also arguably more secure.  The in-ROM Linux
has only the bare minimum: no network subsystem, only necessary filesystems,
bare minimum drivers are built-in, USB is limited to HID devices, etc; the
compressed kernel has ~1.7MiB with room to shrink.  The in-ROM initrd is
also quite minimal, containing just one file.</p>
<p>The only file is a <a class="reference external" href="https://gist.github.com/lpereira/845fe060ba68a5db95827cbc5496bb6d">hacked version</a> of
cryptsetup that acts as a primitive init, creating <span class="docutils literal"><span class="pre">/proc</span></span>, <span class="docutils literal"><span class="pre">/dev</span></span> (and mounting
these two), and <span class="docutils literal"><span class="pre">/boot</span></span>, decrypting <span class="docutils literal"><span class="pre">/boot</span></span>, and performing kexec.  It’s
statically linked with <a class="reference external" href="https://www.musl-libc.org/">musl libc</a>.</p>
<p>Flashing this requires opening the laptop, and I’m planning to do this next
weekend when replacing the USB ports.  However, the setup works very well
under <a class="reference external" href="http://www.qemu.org/">QEMU</a>.</p>
<p>This blog post isn’t meant as a tutorial – feel free to contact me if you
have questions or ideas on how to improve this.  If you end up using
something similar to this idea, I’d love to know as well.</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Leandro Pereira</span>
        </div>
        <div class="categories">
            <span>
                Filed under:
                <a href="categories/linux.html">linux</a>, <a href="categories/x220.html">x220</a>, <a href="categories/hack.html">hack</a></span>
        </div>
        
        </div><div class="archive_link">
        <a href="archive.html"> &mdash; Blog Archive &mdash; </a>
    </div><ul class="related clearfix">
            <li class="left"></li>
            <li class="right"><a href="page2.html">Older</a> &raquo; </li>
        </ul></article><aside class="sidebar"><section><div class="widget" id="searchbox" role="search">
    <h1><a href="#searchbox">Search</a></h1>
    <form action="search.html" method="get">
        <input type="text" name="q" />
        <button type="submit"><span class="fa fa-search"></span></button>
    </form>
</div></section><section><div class="widget">
    <h1>Recent Posts</h1>
    <ul><li>
            <a href="2020/02/10/optimizing_a_json_serializer.html">Optimizing a JSON serializer (part 1)</a>
        </li><li>
            <a href="2019/10/24/lwan_5_years_in_snippets.html">Lwan: 5 years in snippets</a>
        </li><li>
            <a href="2018/06/28/include_next_and_portability.html">include_next and portability</a>
        </li><li>
            <a href="2018/02/01/more_on_string_switch_in_c.html">More on string switch in C</a>
        </li><li>
            <a href="2017/05/08/coreboot_luks.html">Coreboot & LUKS</a>
        </li><li>
            <a href="2017/03/01/parsing_json.html">Parsing JSON</a>
        </li><li>
            <a href="2016/11/08/infect_to_protect.html">Infect to Protect</a>
        </li><li>
            <a href="2015/05/01/initializing_a_heap_allocated_structure_in_c.html">Initializing a heap-allocated structure in C</a>
        </li><li>
            <a href="2014/11/02/hybrid_c_pascal_strings.html">Hybrid C/Pascal Strings</a>
        </li><li>
            <a href="2014/10/06/life_of_a_http_request.html">Life of a HTTP request, as seen by my toy web server</a>
        </li></ul>
</div>
</section><section><div class="widget">
    <h1>Tags Cloud</h1>
      <a href="tags/arduino.html" style="font-size: 8pt">arduino</a>&nbsp;&nbsp;
      <a href="tags/assembly.html" style="font-size: 8pt">assembly</a>&nbsp;&nbsp;
      <a href="tags/bpf.html" style="font-size: 8pt">bpf</a>&nbsp;&nbsp;
      <a href="tags/c.html" style="font-size: 16pt">C</a>&nbsp;&nbsp;
      <a href="tags/c.html" style="font-size: 8pt">c</a>&nbsp;&nbsp;
      <a href="tags/conferences.html" style="font-size: 8pt">conferences</a>&nbsp;&nbsp;
      <a href="tags/container.html" style="font-size: 8pt">container</a>&nbsp;&nbsp;
      <a href="tags/data_structure.html" style="font-size: 8pt">data-structure</a>&nbsp;&nbsp;
      <a href="tags/efl.html" style="font-size: 8pt">efl</a>&nbsp;&nbsp;
      <a href="tags/enlightenment.html" style="font-size: 8pt">enlightenment</a>&nbsp;&nbsp;
      <a href="tags/finf.html" style="font-size: 8pt">finf</a>&nbsp;&nbsp;
      <a href="tags/javascript.html" style="font-size: 8pt">javascript</a>&nbsp;&nbsp;
      <a href="tags/json.html" style="font-size: 8pt">json</a>&nbsp;&nbsp;
      <a href="tags/linux.html" style="font-size: 9pt">linux</a>&nbsp;&nbsp;
      <a href="tags/lwan.html" style="font-size: 17pt">lwan</a>&nbsp;&nbsp;
      <a href="tags/optimization.html" style="font-size: 8pt">optimization</a>&nbsp;&nbsp;
      <a href="tags/parser.html" style="font-size: 8pt">parser</a>&nbsp;&nbsp;
      <a href="tags/profusion.html" style="font-size: 9pt">profusion</a>&nbsp;&nbsp;
      <a href="tags/programming.html" style="font-size: 20pt">programming</a>&nbsp;&nbsp;
      <a href="tags/strace.html" style="font-size: 8pt">strace</a>&nbsp;&nbsp;
      <a href="tags/template.html" style="font-size: 8pt">template</a>&nbsp;&nbsp;
      <a href="tags/tizen.html" style="font-size: 8pt">tizen</a>&nbsp;&nbsp;
      <a href="tags/trick.html" style="font-size: 14pt">trick</a>&nbsp;&nbsp;
      <a href="tags/tricks.html" style="font-size: 8pt">tricks</a>&nbsp;&nbsp;
      <a href="tags/zephyr.html" style="font-size: 8pt">zephyr</a>
</div></section></aside></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><footer class="wrapper">&copy; Copyright 2012—2019, Leandro Pereira. Powered by <a href="http://www.tinkerer.me/">Tinkerer</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.</footer></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>