<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>Leandro Pereira</title>
        <link>http://tia.mat.br/blog/html/</link>
        <description></description>
        <language>en-us</language>
        <pubDate>Thu, 24 Oct 2019 00:00:00 -0700</pubDate>
        
        <item>
            <link>http://tia.mat.br/blog/html/2019/10/24/lwan_5_years_in_snippets.html</link>
            <guid>http://tia.mat.br/blog/html/2019/10/24/lwan_5_years_in_snippets.html</guid>
            <title><![CDATA[Lwan: 5 years in snippets]]></title>
            <description><![CDATA[<div class="section" id="lwan-5-years-in-snippets">
<h1>Lwan: 5 years in snippets</h1>
<p>Around five years ago, I wrote a blog post that went though the
life-cycle of a HTTP request, as seen by my toy web server, Lwan. It was
a surprisingly popular article, not only raising visibility for my toy
project, but also generating some discussions on link aggregator web
sites and personal emails. (<a class="reference external" href="https://tia.mat.br/posts/2014/10/06/life_of_a_http_request.html">You can read the blog
post</a>
if you haven’t already or need some refreshing.)</p>
<p>While I haven’t been working on it with the vigor I had in its first few
years, a few things changed nonetheless; this article is a follow-up
article on that. (Which I recommend reading, as out-of-date as it is:
most things in the server didn’t change.)</p>
<p>Items in this article aren’t in any particular order; it’s just a
collection of changes that happened since the original article was
written. Not everything is mentioned here, of course, but should give an
idea of the kind of work that kept me busy during some lazy Sundays.</p>
</div>
<div class="section" id="main-loop-changes">
<h1>Main Loop Changes</h1>
<p>The main loop was designed to either wait indefinitely, or time out
every second, depending on how many file descriptors are being watched
by a worker thread. This made it quite hard to implement something that
was required for some use cases I wanted to use Lwan for: the ability
for a request handler to pause the execution for a specified amount of
time.</p>
<p>Request handlers, being executed in a coroutine, are subject to a
cooperative scheduler, so they can’t just use system calls like
<code class="docutils literal notranslate"><span class="pre">usleep()</span></code>; instead, many changes in the main loop were performed to
support timers, paving the way for other potential enhancements in the
future (e.g.  non-client file descriptor watching, for instance).</p>
<p>Each thread has a timer wheel data structure, which can be thought of a
efficient priority queue that has the sole purpose of maintaining a set
of timers. Usually, I’d just implement one from the scratch; however,
while looking for implementations for inspiration, I ended up stumbling
over
<a class="reference external" href="https://25thandclement.com/~william/projects/timeout.c.html">timeout.c</a>,
which has a decent API and has seen some abuse in programs like TOR. I
performed a few minor tweaks when importing the library to the tree, and
am now using it to control how much time <code class="docutils literal notranslate"><span class="pre">epoll_wait()</span></code> will block
waiting for file descriptor events; and, if none were returned, timers
are processed, and coroutines are marked as “ready to be resumed”.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">thread_io_loop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* This is the entry point for the worker threads.  The infinite loop</span>
<span class="cm">     * below is the meat of event handling in Lwan.  Everything passes</span>
<span class="cm">     * through this loop.  */</span>

    <span class="cm">/* (Initialization omitted for brevity.) */</span>

    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="cm">/* Turning the timer wheel will also process pending timers,</span>
<span class="cm">         * including the one that moves the timeout queue and updates the</span>
<span class="cm">         * date/time cache.  It then returns how much time epoll_wait()</span>
<span class="cm">         * has to wait in ms. */</span>
        <span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">turn_timer_wheel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dq</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">epoll_fd</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">n_fds</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">max_events</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

    <span class="cm">/* To quit Lwan, all epoll file descriptors are closed, and the</span>
<span class="cm">     * threads are nudged.  This wakes up epoll_wait(), and the next</span>
<span class="cm">     * time it's called, it's going to probably return EBADF. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">n_fds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EBADF</span> <span class="o">||</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EINVAL</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">events</span><span class="p">;</span> <span class="n">n_fds</span><span class="o">--</span><span class="p">;</span> <span class="n">event</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">accept_nudge</span><span class="p">(</span><span class="n">read_pipe_fd</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">lwan</span><span class="o">-&gt;</span><span class="n">conns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">switcher</span><span class="p">,</span>
                             <span class="n">epoll_fd</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">struct</span> <span class="n">lwan_connection</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EPOLLRDHUP</span> <span class="o">|</span> <span class="n">EPOLLHUP</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">death_queue_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dq</span><span class="p">,</span> <span class="n">conn</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">resume_coro</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dq</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">epoll_fd</span><span class="p">);</span>
            <span class="n">death_queue_move_to_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dq</span><span class="p">,</span> <span class="n">conn</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* (Cleanup omitted for brevity.) */</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While coroutines are sleeping, their file descriptor is still tracked by
epoll, in case the connection is dropped by the peer. Awaking a
coroutine is essentially just the matter of listening to the events that
it was listening before it went on to sleep. (At the moment, this means
both read and write events, as it was easier to implement – although
different on kqueue systems, where reading/writing are not events but
filters, which can’t be combined in a single throw.)</p>
<p>A coroutine expresses their desire to sleep to the main loop by yielding
with a special value. (Previously, it could only say ‘yield, but resume
me later’ or ‘yield, but destroy me whenever you can’; this changed in
the recent months.)</p>
<p>With all the infrastructure work, the API entry point to suspend the
corroutine for an specified amount of time becomes trivial:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_sleep</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">timeouts</span> <span class="o">*</span><span class="n">wheel</span> <span class="o">=</span> <span class="n">data1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timeout</span> <span class="o">*</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">data2</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">lwan_request</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span>
        <span class="n">container_of</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lwan_request</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CONN_SUSPENDED_TIMER</span><span class="p">)</span>
        <span class="n">timeouts_del</span><span class="p">(</span><span class="n">wheel</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

    <span class="n">request</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CONN_HAS_REMOVE_SLEEP_DEFER</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">lwan_request_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lwan_request</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">lwan_connection</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timeouts</span> <span class="o">*</span><span class="n">wheel</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">wheel</span><span class="p">;</span>

    <span class="n">request</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{};</span>
    <span class="n">timeouts_add</span><span class="p">(</span><span class="n">wheel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CONN_HAS_REMOVE_SLEEP_DEFER</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">coro_defer2</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">coro</span><span class="p">,</span> <span class="n">remove_sleep</span><span class="p">,</span> <span class="n">wheel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
        <span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CONN_HAS_REMOVE_SLEEP_DEFER</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* The meaning of CONN_CORO_SUSPEND_TIMER will become clear in the next</span>
<span class="cm">     * section. */</span>
    <span class="n">coro_yield</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">coro</span><span class="p">,</span> <span class="n">CONN_CORO_SUSPEND_TIMER</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(The next section explains a little bit more of how the infrastructure
works.)</p>
<p>Due to the nature of the hashed timer wheel, when <code class="docutils literal notranslate"><span class="pre">epoll_wait()</span></code> wakes
up every second to update the time cache and process the timeout queue,
it may wake up a few more times with intervals smaller than 1 second. In
practice, this ends up being slightly more accurate, as the system’s
monotonic clock source is used to offset any time between
<code class="docutils literal notranslate"><span class="pre">epoll_wait()</span></code> invocations, avoiding timer drift. (It’s slightly more
accurate because the coarse monotonic clock is used if available, and
the timeout in <code class="docutils literal notranslate"><span class="pre">epoll_wait()</span></code> uses the fine-grained variant instead.
Maybe a <code class="docutils literal notranslate"><span class="pre">EPOLL_COARSE_CLOCKSOURCE</span></code> flag to <code class="docutils literal notranslate"><span class="pre">epoll_create1()</span></code> would
be worthwhile investigating?)</p>
</div>
<div class="section" id="changing-connection-coroutine-yield-values">
<h1>Changing Connection Coroutine Yield Values</h1>
<p>One of the trickiest bits in Lwan was its main loop and how it
determined which epoll events mask to choose depending on the connection
state. It was often the case that a connection would stall indefinitely
for no reason, which was often caused when it had declared that it
wanted to be resumed only when the socket was ready to read, when it
wanted to write instead. The code responsible for this was very brittle
and didn’t make much sense, although it worked most of the time. It
really needed a big overhaul (which turned out to not be big, line-count
wise.)</p>
<p>The main idea behind the changes here was to add new values that
coroutines could use to inform the scheduler what it was interested in:
reading from the socket, writing to the socket, sleeping, this sort of
stuff. This is mostly hidden from most of the code, though, being
necessary to be aware of only by the I/O wrappers (a coroutine now
yields automatically, for instance, if <code class="docutils literal notranslate"><span class="pre">lwan_read()</span></code> detects that
read() failed with a <code class="docutils literal notranslate"><span class="pre">EAGAIN</span></code> <code class="docutils literal notranslate"><span class="pre">errno</span></code>, to change the coroutine
intent to be resumed whenever the socket can be read again).</p>
<p>The nice thing about this change is that it changed a bunch of branches
and operations with straightforward table lookups. In the past few
years, I’ve been moving towards using lookup tables a whole lot more;
it’s sometimes difficult to express a rat’s nest of branches in a way
that’s efficient to look it up on a table, but it’s a satisfying feeling
when all that crud is gone and all you’re left with are a few array
accesses.</p>
<p>Contrast the new, shiny, table-based approach:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="n">ALWAYS_INLINE</span> <span class="kt">uint32_t</span>
<span class="nf">conn_flags_to_epoll_events</span><span class="p">(</span><span class="k">enum</span> <span class="n">lwan_connection_flags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">map</span><span class="p">[</span><span class="n">CONN_EVENTS_MASK</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">[</span><span class="mi">0</span> <span class="cm">/* Suspended by timer */</span><span class="p">]</span> <span class="o">=</span> <span class="n">EPOLLRDHUP</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_EVENTS_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="n">EPOLLOUT</span> <span class="o">|</span> <span class="n">EPOLLRDHUP</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_EVENTS_READ</span><span class="p">]</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLRDHUP</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_EVENTS_READ_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLOUT</span> <span class="o">|</span> <span class="n">EPOLLRDHUP</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">return</span> <span class="n">map</span><span class="p">[</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CONN_EVENTS_MASK</span><span class="p">];</span>
<span class="p">}</span>

<span class="cp">#if defined(__linux__)</span>
<span class="cp"># define CONN_EVENTS_RESUME_TIMER CONN_EVENTS_READ_WRITE</span>
<span class="cp">#else</span>
<span class="cm">/* Kqueue doesn't like when you filter on both read and write, so</span>
<span class="cm"> * wait only on write when resuming a coro suspended by a timer.</span>
<span class="cm"> * The I/O wrappers should yield if trying to read without anything</span>
<span class="cm"> * in the buffer, changing the filter to only read, so this is OK. */</span>
<span class="cp"># define CONN_EVENTS_RESUME_TIMER CONN_EVENTS_WRITE</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_epoll_flags</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>
                               <span class="k">struct</span> <span class="n">lwan_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
                               <span class="kt">int</span> <span class="n">epoll_fd</span><span class="p">,</span>
                               <span class="k">enum</span> <span class="n">lwan_connection_coro_yield</span> <span class="n">yield_result</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="k">enum</span> <span class="n">lwan_connection_flags</span> <span class="n">or_mask</span><span class="p">[</span><span class="n">CONN_CORO_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">CONN_CORO_YIELD</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_WANT_READ_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONN_EVENTS_READ_WRITE</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_WANT_READ</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONN_EVENTS_READ</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_WANT_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONN_EVENTS_WRITE</span><span class="p">,</span>

        <span class="cm">/* While the coro is suspended, we're not interested in either EPOLLIN</span>
<span class="cm">         * or EPOLLOUT events.  We still want to track this fd in epoll, though,</span>
<span class="cm">         * so unset both so that only EPOLLRDHUP (plus the implicitly-set ones)</span>
<span class="cm">         * are set. */</span>
        <span class="p">[</span><span class="n">CONN_CORO_SUSPEND_TIMER</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONN_SUSPENDED_TIMER</span><span class="p">,</span>

        <span class="cm">/* Either EPOLLIN or EPOLLOUT have to be set here.  There's no need to</span>
<span class="cm">         * know which event, because they were both cleared when the coro was</span>
<span class="cm">         * suspended. So set both flags here. This works because EPOLLET isn't</span>
<span class="cm">         * used. */</span>
        <span class="p">[</span><span class="n">CONN_CORO_RESUME_TIMER</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONN_EVENTS_RESUME_TIMER</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">static</span> <span class="k">const</span> <span class="k">enum</span> <span class="n">lwan_connection_flags</span> <span class="n">and_mask</span><span class="p">[</span><span class="n">CONN_CORO_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">CONN_CORO_YIELD</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_WANT_READ_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_WANT_READ</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">CONN_EVENTS_WRITE</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_WANT_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">CONN_EVENTS_READ</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_SUSPEND_TIMER</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">CONN_EVENTS_READ_WRITE</span><span class="p">,</span>
        <span class="p">[</span><span class="n">CONN_CORO_RESUME_TIMER</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">CONN_SUSPENDED_TIMER</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">enum</span> <span class="n">lwan_connection_flags</span> <span class="n">prev_flags</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

    <span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">or_mask</span><span class="p">[</span><span class="n">yield_result</span><span class="p">];</span>
    <span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">and_mask</span><span class="p">[</span><span class="n">yield_result</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">==</span> <span class="n">prev_flags</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">conn_flags_to_epoll_events</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">),</span>
        <span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">conn</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">lwan_status_perror</span><span class="p">(</span><span class="s">"epoll_ctl"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With the crusty, buggy, old approach that only worked by chance (and was
the source of a lot of headache):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_epoll_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">death_queue</span> <span class="o">*</span><span class="n">dq</span><span class="p">,</span>
                               <span class="k">struct</span> <span class="n">lwan_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
                               <span class="kt">int</span> <span class="n">epoll_fd</span><span class="p">,</span>
                               <span class="k">enum</span> <span class="n">lwan_connection_coro_yield</span> <span class="n">yield_result</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">write_events</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CONN_RESUMED_FROM_TIMER</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CONN_RESUMED_FROM_TIMER</span> <span class="o">|</span> <span class="n">CONN_WRITE_EVENTS</span><span class="p">);</span>
        <span class="n">write_events</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CONN_SUSPENDED_BY_TIMER</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* CONN_WRITE_EVENTS shouldn't be flipped in this case. */</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLERR</span> <span class="o">|</span> <span class="n">EPOLLRDHUP</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CONN_MUST_READ</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">write_events</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">should_resume_coro</span> <span class="o">=</span> <span class="p">(</span><span class="n">yield_result</span> <span class="o">==</span> <span class="n">CONN_CORO_MAY_RESUME</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">should_resume_coro</span><span class="p">)</span>
            <span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CONN_SHOULD_RESUME_CORO</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CONN_SHOULD_RESUME_CORO</span><span class="p">;</span>

        <span class="n">write_events</span> <span class="o">=</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CONN_WRITE_EVENTS</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">should_resume_coro</span> <span class="o">==</span> <span class="n">write_events</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="o">!</span><span class="n">events</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">events_by_write_flag</span><span class="p">[</span><span class="n">write_events</span><span class="p">];</span>
        <span class="n">conn</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">^=</span> <span class="n">CONN_WRITE_EVENTS</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span> <span class="o">=</span> <span class="p">{.</span><span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">,</span> <span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">conn</span><span class="p">};</span>

    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">lwan_connection_get_fd</span><span class="p">(</span><span class="n">dq</span><span class="o">-&gt;</span><span class="n">lwan</span><span class="p">,</span> <span class="n">conn</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">lwan_status_perror</span><span class="p">(</span><span class="s">"epoll_ctl"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="changes-in-parsers">
<h1>Changes in parsers</h1>
<div class="section" id="rfc822-date-headers">
<h2>RFC822 (Date headers)</h2>
<p>Unhappy with the performance of <code class="docutils literal notranslate"><span class="pre">strptime()</span></code>, I came up with a parser
that fits the theme of the rest of the HTTP parser in Lwan quite well:
by using string switch statements, the <a class="reference external" href="https://gist.github.com/lpereira/4e09f5a038b740d61860488679427c4e">new time parser is faster by a
around 12x when compared with the generic one from the C
library</a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">lwan_parse_rfc_time</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">in</span><span class="p">[</span><span class="k">static</span> <span class="mi">30</span><span class="p">],</span> <span class="kt">time_t</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* This function is used instead of strptime() because locale</span>
<span class="cm">     * information can affect the parsing.  Instead of defining</span>
<span class="cm">     * the locale to "C", use hardcoded constants. */</span>
    <span class="k">struct</span> <span class="n">tm</span> <span class="n">tm</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>

    <span class="n">STRING_SWITCH</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'S'</span><span class="p">,</span><span class="sc">'u'</span><span class="p">,</span><span class="sc">'n'</span><span class="p">,</span><span class="sc">','</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'M'</span><span class="p">,</span><span class="sc">'o'</span><span class="p">,</span><span class="sc">'n'</span><span class="p">,</span><span class="sc">','</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'T'</span><span class="p">,</span><span class="sc">'u'</span><span class="p">,</span><span class="sc">'e'</span><span class="p">,</span><span class="sc">','</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span><span class="sc">'e'</span><span class="p">,</span><span class="sc">'d'</span><span class="p">,</span><span class="sc">','</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'T'</span><span class="p">,</span><span class="sc">'h'</span><span class="p">,</span><span class="sc">'u'</span><span class="p">,</span><span class="sc">','</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'F'</span><span class="p">,</span><span class="sc">'r'</span><span class="p">,</span><span class="sc">'i'</span><span class="p">,</span><span class="sc">','</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'S'</span><span class="p">,</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'t'</span><span class="p">,</span><span class="sc">','</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">str</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="n">tm</span><span class="p">.</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="n">parse_2_digit_num</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">' '</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">tm</span><span class="p">.</span><span class="n">tm_mday</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="n">str</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="n">STRING_SWITCH</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'J'</span><span class="p">,</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'n'</span><span class="p">,</span><span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'F'</span><span class="p">,</span><span class="sc">'e'</span><span class="p">,</span><span class="sc">'b'</span><span class="p">,</span><span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'M'</span><span class="p">,</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'r'</span><span class="p">,</span><span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'A'</span><span class="p">,</span><span class="sc">'p'</span><span class="p">,</span><span class="sc">'r'</span><span class="p">,</span><span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'M'</span><span class="p">,</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'y'</span><span class="p">,</span><span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'J'</span><span class="p">,</span><span class="sc">'u'</span><span class="p">,</span><span class="sc">'n'</span><span class="p">,</span><span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'J'</span><span class="p">,</span><span class="sc">'u'</span><span class="p">,</span><span class="sc">'l'</span><span class="p">,</span><span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'A'</span><span class="p">,</span><span class="sc">'u'</span><span class="p">,</span><span class="sc">'g'</span><span class="p">,</span><span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'S'</span><span class="p">,</span><span class="sc">'e'</span><span class="p">,</span><span class="sc">'p'</span><span class="p">,</span><span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'O'</span><span class="p">,</span><span class="sc">'c'</span><span class="p">,</span><span class="sc">'t'</span><span class="p">,</span><span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'N'</span><span class="p">,</span><span class="sc">'o'</span><span class="p">,</span><span class="sc">'v'</span><span class="p">,</span><span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'D'</span><span class="p">,</span><span class="sc">'e'</span><span class="p">,</span><span class="sc">'c'</span><span class="p">,</span><span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">str</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="n">tm</span><span class="p">.</span><span class="n">tm_year</span> <span class="o">=</span> <span class="n">parse_int</span><span class="p">(</span><span class="n">strndupa</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">tm</span><span class="p">.</span><span class="n">tm_year</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="n">tm</span><span class="p">.</span><span class="n">tm_year</span> <span class="o">-=</span> <span class="mi">1900</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">tm</span><span class="p">.</span><span class="n">tm_year</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_year</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="n">str</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="n">tm</span><span class="p">.</span><span class="n">tm_hour</span> <span class="o">=</span> <span class="n">parse_2_digit_num</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">':'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
    <span class="n">str</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">tm</span><span class="p">.</span><span class="n">tm_min</span> <span class="o">=</span> <span class="n">parse_2_digit_num</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">':'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">59</span><span class="p">);</span>
    <span class="n">str</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">tm</span><span class="p">.</span><span class="n">tm_sec</span> <span class="o">=</span> <span class="n">parse_2_digit_num</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">' '</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">59</span><span class="p">);</span>
    <span class="n">str</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="n">STRING_SWITCH</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">STR4_INT</span><span class="p">(</span><span class="sc">'G'</span><span class="p">,</span><span class="sc">'M'</span><span class="p">,</span><span class="sc">'T'</span><span class="p">,</span><span class="sc">'\0'</span><span class="p">)</span><span class="o">:</span>
        <span class="n">tm</span><span class="p">.</span><span class="n">tm_isdst</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">timegm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="o">*</span><span class="n">out</span> <span class="o">==</span> <span class="p">(</span><span class="kt">time_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference external" href="http://0x80.pl/">Wojciech Muła</a> wrote a better version using <a class="reference external" href="https://github.com/WojciechMula/toys/tree/master/parse_rfc_date">SIMD
instructions</a>
after they learned about this routine; it was then improved by <a class="reference external" href="https://twitter.com/kendallwillets">Kendall
Willets</a> to use a different
technique (a perfect hash table). Both are faster than the version used
in Lwan, but I decided to keep my version because not only it is fast
enough, it’s also more maintainable; it also serves as a pretty good
example for the <a class="reference external" href="https://tia.mat.br/posts/2018/02/01/more_on_string_switch_in_c.html">string switch
trick</a>.</p>
<p>(As a complement to this change, the function that converts a time_t
into the same string that <code class="docutils literal notranslate"><span class="pre">lwan_parse_rfc_time()</span></code> parses has been
written as well, and it’s as efficient as I could make it, even going to
the effort of reducing the number of divisions to convert integers into
strings from 6 to just 1.)</p>
</div>
<div class="section" id="configuration-parser-template-parser">
<h2>Configuration parser &amp; Template parser</h2>
<p>Both the configuration file parser and the template parser were written
without paying attention to anything related to compiler theory; just an
ad-hoc parser without a proper lexer, looking at a line at a time. Both
had a lot of workarounds and were generally hard to extend and debug.
They needed to be rewritten, but I really didn’t want to use a parser
generator (I really don’t like them).</p>
<p>For both of these parsers, used the same technique in the <a class="reference external" href="https://tia.mat.br/posts/2017/03/01/parsing_json.html">JSON parser I
wrote for the Zephyr
project</a>: a
state machine (where the variable that holds the state actually holds a
pointer to a function that handles that state), and a ring buffer. I
really like this technique, as it’s often easier to grasp than many of
the parser generators out there. (There’s the added benefit that no new
build dependencies or build system changes is required.)</p>
<p>Here’s how one of these functions might look; this one doesn’t use the
ring buffer, only consumes bytes from the input:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">lex_comment</span><span class="p">(</span><span class="k">struct</span> <span class="n">lexer</span> <span class="o">*</span><span class="n">lexer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* lex_config() returns 'lex_comment' when 'next(lexer)' returns '#' */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">iscomment</span><span class="p">(</span><span class="n">next</span><span class="p">(</span><span class="n">lexer</span><span class="p">)))</span>
        <span class="p">;</span>

    <span class="cm">/* Current character isn't a comment, back it up: next state should be</span>
<span class="cm">     * able to read it and determine which state is going to process the</span>
<span class="cm">     * next token. */</span>
    <span class="n">backup</span><span class="p">(</span><span class="n">lexer</span><span class="p">);</span>

    <span class="cm">/* lex_config() handles the main state */</span>
    <span class="k">return</span> <span class="n">lex_config</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And here’s how the function that handles the “get me a new token”
function that the parser calls looks:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">bool</span> <span class="nf">lex_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">lexer</span> <span class="o">*</span><span class="n">lexer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lexeme</span> <span class="o">**</span><span class="n">lexeme</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* To end the state machine, a state-handling function returns NULL,</span>
<span class="cm">     * ending this loop.  */</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">lexer</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* If a state handling function emits one or more tokens, for as</span>
<span class="cm">         * long as lex_next() is called, instead of calling the function to</span>
<span class="cm">         * handle the current state, items from the ring buffer are popped</span>
<span class="cm">         * instead.  */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lexeme_buffer_consume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lexer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">lexeme</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="cm">/* Run the state machine for the current state, and update it if</span>
<span class="cm">         * necessary.  */</span>
        <span class="n">lexer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">lexer</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">(</span><span class="n">lexer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Exhaust the ring buffer until there's nothing left. */</span>
    <span class="k">return</span> <span class="n">lexeme_buffer_consume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lexer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">lexeme</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The configuration file parser got a few nice features, like the ability
to expand environment variables (or use a default value provided in the
configuration file), multiline strings, and other minor changes and
bugfixes that would be too complicated to implement in the previous
bespoke one-line-at-a-time thing that was in place.</p>
<p>The template parser also got significantly more robust, handling some
corner cases that were just impossible before. (No new significant
changes have been performed in the runtime portion, though, although a
few tweaks here and there were made over the years.) Unrelated to the
parser changes, a template can be “compiled” with an option that won’t
allocate and copy a new string for each text fragment, but use text
that’s in memory somewhere; this is useful for things such as the file
serving module or the default response generator, when a template has
not been supplied by the user in the configuration file, where
<code class="docutils literal notranslate"><span class="pre">strbuf</span></code> structs used by the template mechanism can just point into
somewhere in <code class="docutils literal notranslate"><span class="pre">rodata</span></code>.</p>
</div>
</div>
<div class="section" id="readahead-madvise">
<h1>Readahead &amp; Madvise</h1>
<p>The Linux system call <code class="docutils literal notranslate"><span class="pre">sendfile()</span></code> doesn’t take flags like the FreeBSD
variant, so it’s impossible to tell it not to block if data isn’t in the
core yet. The best one can do, as far as I can tell, is to make sure
that the data is already there when it is invoked. That’s why Lwan now
has a low-priority thread (which has also low-priority I/O thread on
Linux) that will call <code class="docutils literal notranslate"><span class="pre">readahead()</span></code> on file chunks as they’re being
served.</p>
<p>This thread takes commands through a pipe, where only the write side is
non-blocking. (Failure to write to that socket isn’t an issue, as this
is merely an optimization, so this is one of the rare cases in Lwan
where a syscall error isn’t handled.) As commands are received, that
thread is free to block (or, more specifically, wait for as much as
necessary) to load the contents into core, so that hopefully the thread
calling <code class="docutils literal notranslate"><span class="pre">sendfile()</span></code> won’t block. This optimization was only possible
because the cache in the file serving module keeps the files open.</p>
<p>For the cases where files are served with a memory-mapped blob of
memory, the problems can be even more apparent; there’s no way to say
“dereference this memory but please don’t block” in any of the supported
platforms. Your only bet is to memory map it, give a hint to the OS to
pre-fault the pages, and lock it in memory. But the <code class="docutils literal notranslate"><span class="pre">madvise()</span></code> and
<code class="docutils literal notranslate"><span class="pre">mlock()</span></code> combo used for this will eventually encounter similar
problems as with the <code class="docutils literal notranslate"><span class="pre">readahead()</span></code> syscall, in which while they might
not exactly block, they’ll take some time to process whatever they need
to process. So the same thread that performs <code class="docutils literal notranslate"><span class="pre">readahead()</span></code> will also
try to bring stuff to the core and keep in there for as long as it’s in
the file serving cache instance.</p>
<p>Even with a thread performing <code class="docutils literal notranslate"><span class="pre">readahead()</span></code>, it’s possible for the I/O
thread to block (or be stuck in an operation that takes more time than
absolutely necessary), increasing latency when handling other
connections assigned to them. This why I’ve been thinking for quite a
while now on how to introduce a work-stealing scheduler to Lwan, with a
watchdog thread to determine if worker threads are not making any kind
of progress; but this is something for the future, I guess.</p>
<p>(Recent advancements in things like <code class="docutils literal notranslate"><span class="pre">io_uring</span></code> and the AIO subsystem
may change how these things are used in Lwan.
<a class="reference external" href="https://www.kernel.org/doc/html/latest/accounting/psi.html">PSI</a> can
be used to avoid doing things if the system is under pressure. I have
not investigated those in depth so far.)</p>
</div>
<div class="section" id="coroutine-changes">
<h1>Coroutine changes</h1>
<p>There has been a few minor tweaks in the coroutine implementation.
Nothing groundbreaking, but worth mentioning anyway.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">data</span></code> pointer has been removed from the coro structure, as it can
be simply passed as parameter to the function implementing the
coroutine. This required the trampoline function for x86-64 to be
written in assembly since one of the registers used for parameter
passing are not in the list of caller-saved registers (and thus not
saved/restored by the context swapping routine), but otherwise,
everything seems to be working as expected.</p>
<p>Deferred callbacks are now stored in an array rather than using a linked
list. This makes it cheaper to use defer (less calls to <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> for
each <code class="docutils literal notranslate"><span class="pre">coro_defer()</span></code> call), which has become an important aspect in how
resources are cleaned up in Lwan. In order to reduce heap memory
allocations, the array is allocated initially inline with the coroutine
struct and moves to the heap if necessary; this cuts two round trips to
the memory allocator per connection in the usual case (this optimization
is available for all array structs if desired; more on this below).</p>
<p>The following table shows the number of <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> calls for 100,000
requests to a “Hello, World” handler and the impact of inlining deferred
calls, for both keep-alive and close connections (with 1000 concurrent
connections):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%"/>
<col style="width: 40%"/>
<col style="width: 38%"/>
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Connection</p></th>
<th class="head"><p>Malloc Calls Before</p></th>
<th class="head"><p>Malloc Calls After</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Keep-Alive</p></td>
<td><p>1,031</p></td>
<td><p>931</p></td>
</tr>
<tr class="row-odd"><td><p>Close</p></td>
<td><p>300,731</p></td>
<td><p>200,728</p></td>
</tr>
</tbody>
</table>
<p>An embarassing fix in the coroutine implementation has been in how the
stack is aligned on x86-64. In some situations, Lwan was crashing (with
a SIGSEGV no less) on instructions that were not meant to cause this
kind of signal (e.g. it would crash when Lua was converting a number
into string). Tools such as Valgrind, sanitizers, and debuggers weren’t
that helpful to pinpoint the location. It turns out that how the stack
pointer for coroutines were aligned was incorrect: had <code class="docutils literal notranslate"><span class="pre">sprintf()</span></code>
(what Lua uses to convert floating point numbers to strings) been
implemented using x87, this would work fine; however, SSE requires
aligned memory to work, so things were crashing on such a trivial
operation. It’s now aligned on a 16-byte boundary, adjusted to be
aligned on an 8-byte boundary right before the trampoline routine is
called. This one-line change took me a lot more hours than I care to
admit, but it’s now finally fixed. It was the first time I used
<a class="reference external" href="https://rr-project.org/">rr</a>, and it’s now an integral part of my
toolbelt.</p>
</div>
<div class="section" id="sending-responses">
<h1>Sending responses</h1>
<p>For some responses, the <code class="docutils literal notranslate"><span class="pre">writev()</span></code> system call was used, so that the
response headers and body could be sent to the wire with a single
syscall. However, the kernel has to copy the I/O vector array, validate
it, and then perform the write operation; this has a relatively high
cost, and if one is trying to send a small response, this cost might not
pay off. I haven’t considered this and always wondered why that was the
case when <code class="docutils literal notranslate"><span class="pre">writev()</span></code> was used to build responses (e.g. using multiple
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iovec</span></code> elements pointing to header names and values instead of
building the response header in memory and sending that). I was
surprised, then, to learn that by reusing the buffer designated for the
response headers and writing the body there (given there was enough
space), and using <code class="docutils literal notranslate"><span class="pre">send()</span></code> instead, the RPS rate increased by ~10%.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">lwan_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">lwan_request</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lwan_http_status</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* ... */</span>
    <span class="kt">char</span> <span class="n">headers</span><span class="p">[</span><span class="n">DEFAULT_HEADERS_SIZE</span><span class="p">];</span>

    <span class="cm">/* ... */</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">resp_buf</span> <span class="o">=</span> <span class="n">lwan_strbuf_get_buffer</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">resp_len</span> <span class="o">=</span> <span class="n">lwan_strbuf_get_length</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span> <span class="o">-</span> <span class="n">header_len</span> <span class="o">&gt;</span> <span class="n">resp_len</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* writev() has to allocate, copy, and validate the response vector,</span>
<span class="cm">         * so use send() for responses small enough to fit the headers</span>
<span class="cm">         * buffer.  On Linux, this is ~10% faster.  */</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">headers</span> <span class="o">+</span> <span class="n">header_len</span><span class="p">,</span> <span class="n">resp_buf</span><span class="p">,</span> <span class="n">resp_len</span><span class="p">);</span>
        <span class="n">lwan_send</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">header_len</span> <span class="o">+</span> <span class="n">resp_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">iovec</span> <span class="n">response_vec</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">{.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">headers</span><span class="p">,</span> <span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">header_len</span><span class="p">},</span>
            <span class="p">{.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">resp_buf</span><span class="p">,</span> <span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">resp_len</span><span class="p">},</span>
        <span class="p">};</span>

        <span class="n">lwan_writev</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">response_vec</span><span class="p">,</span> <span class="n">N_ELEMENTS</span><span class="p">(</span><span class="n">response_vec</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In order to increase the performance of pipelined requests, Lwan will
also call <code class="docutils literal notranslate"><span class="pre">send()</span></code> with the <code class="docutils literal notranslate"><span class="pre">MSG_MORE</span></code> flag. This should cause in
less TCP segments being sent over the wire, significantly improving the
RPS rate (~20% higher if I’m not mistaken). This is akin to setting the
<code class="docutils literal notranslate"><span class="pre">TCP_CORK</span></code> socket flag, but not only this is more portable, system
calls are saved; nonetheless, the flag that controls if the I/O wrappers
will set that flag still mentions the cork flag. (Linux has TCP
autocorking, which in theory should make this optimization useless, but
in my limited testing it didn’t help that much.) The <code class="docutils literal notranslate"><span class="pre">writev()</span></code> system
call, which is still used for those responses that are larger than it
would fit in the response headers buffer, doesn’t take a flags
parameter; however, it’s possible to use <code class="docutils literal notranslate"><span class="pre">sendmsg()</span></code> to the same
effect (it also takes the same I/O vector and has the same behavior as
<code class="docutils literal notranslate"><span class="pre">writev()</span></code> when it comes to short writes due to non-blocking sockets.)</p>
<p>Adding to the “I’ve been adopting lookup tables whenever I can” comment
above: in order to determine if a response has a body, instead of a
table, the actual flags in the request struct that are used to determine
the HTTP verb encodes this information: if their least-significant-bit
is set, then the response should contain a body; otherwise, only headers
will be sent. Went from an array lookup to a mere mask. Still a table,
just encoded differently.</p>
</div>
<div class="section" id="cpu-topology-aware-thread-pinning-scheduling">
<h1>CPU topology aware thread pinning / scheduling</h1>
<p>One of the things that Lwan has been doing since the beginning was to
allocate a big chunk of memory to containing information about client
connections. Indexed by the file descriptor, looking up the element is
quick and efficient; however also makes it possible for false sharing to
happen (the struct is exactly 32 bytes on x86-64, so that two fit in a
cache line), so connections are scheduled to threads in such a way that
this is avoided.</p>
<p>Previously, however, this would only consider that the CPU topology for
my personal laptop was the gold standard. Anything different and it
would mean that it would probably make the problem even worse. (I’m not
kidding when I say that this project is but a toy.)</p>
<p>Now, Lwan, at least on x86_64 Linux (as it relies on information exposed
by sysfs rather than messing around with <code class="docutils literal notranslate"><span class="pre">cpuid</span></code> and the likes), reads
the CPU topology and uses that information to not only pre-schedule all
connections correctly (minimizing a little bit of the work necessary
whenever one is accepted), but to also pin the threads to the correct
logical CPU.</p>
</div>
<div class="section" id="continuous-fuzz-testing">
<h1>Continuous Fuzz-Testing</h1>
<p>Writing your own parser, especially when it comes to something that’s
connected to a network socket, always should raise suspicions. Parsers
can be tricky to get right, and it’s very easy to accidentally trigger a
footgun when doing so in a language like C.</p>
<p>Nevertheless, I still do it; this project is but a hobby to me, and
running with scissors is part of why it’s enjoyable to me. As careful as
I am with it (or would like to think I am), it’s still developed while
I’m tired from work or when I had a few beers; in other words, I needed
to test the project methodically. I had used fuzz-testers before, but
never let them running overnight or over extended periods of time; my
main machine is a laptop, and overheating is an issue.</p>
<p>It was much to my surprise, then, when the folks at Google accepted my
weekend project on <a class="reference external" href="https://github.com/google/oss-fuzz/">OSS-Fuzz</a>.
So far, it has <a class="reference external" href="https://bugs.chromium.org/p/oss-fuzz/issues/list?can=1&amp;q=lwan">found a few issues, which were promptly
fixed</a>;
however, although it’s still hard at work, generating some heat
somewhere, the parser proved to be pretty resilient. I’m pretty happy
with the results.</p>
<p>This of course is only testing the request parser, and there’s more to a
web server than that; some of which aren’t that easy to fuzz-test (at
least not in an automated way). Most of the code being fuzzed is the
more important (and network-facing) request parsing code; coverage for
this is around 15%, which is pretty decent all things considered. The
configuration file parser is also being fuzzed, although the work has
just recently started (I don’t have a lot of information on this yet).
Time permitting, I’ll add more fuzzers to the mix.</p>
<p>As I write this, over 56 trillion tests in the past 30 days (counting only
the tests with <a class="reference external" href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a>,
although <a class="reference external" href="http://lcamtuf.coredump.cx/afl/">AFL</a> is also used), which is
nothing short of amazing.</p>
</div>
<div class="section" id="portability">
<h1>Portability</h1>
<p>The astute reader, or at least one that has been following Lwan for a
while, might have noticed that portability has been mentioned a few
times in this article. This was not a concern a few years ago, but since
then, Lwan has been ported to work on BSD systems as well (mostly by
implementing epoll on top of kqueue, and providing a sendfile I/O
wrapper that works regardless of the underlying system), although it has
been only tested on FreeBSD, macOS, and OpenBSD. (Recent OpenBSDs might
require some tinkering, as they enforce the stack pointer to be within
pages mapped with a specific flag.)</p>
<p>You can read more about how portability has been achieved by reading my
<a class="reference external" href="https://tia.mat.br/posts/2018/06/28/include_next_and_portability.html">blog post on using the non-standard #include_next preprocessor
directive</a>,
which saved me from writing abstraction layers.</p>
</div>
<div class="section" id="declaring-new-lua-metamethods">
<h1>Declaring new Lua metamethods</h1>
<p>Another change that might improve the comfort of people using Lwan with
Lua scripts is that it’s easier to add new metamethods to the request
table.</p>
<p>One just declares a new C function with the <code class="docutils literal notranslate"><span class="pre">LWAN_LUA_METHOD</span></code> macro,
and, during startup, Lwan will attach that function to the request
metatable as a metamethod. (One can call
<code class="docutils literal notranslate"><span class="pre">lwan_lua_get_request_from_userdata()</span></code> to obtain a
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lwan_request</span> <span class="pre">*</span></code> from the first parameter in the C
implementation of one of these metamethods.)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">LWAN_LUA_METHOD</span><span class="p">(</span><span class="n">say</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">lwan_request</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="n">lwan_lua_get_request_from_userdata</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">response_str_len</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">response_str</span> <span class="o">=</span> <span class="n">lua_tolstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">response_str_len</span><span class="p">);</span>

    <span class="n">lwan_strbuf_set_static</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">response_str</span><span class="p">,</span>
                           <span class="n">response_str_len</span><span class="p">);</span>
    <span class="n">lwan_response_send_chunk</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This macro works by adding a struct to a certain section in the
executable, so new application-specific metamethods can be linked
together with Lwan without having to modify Lwan itself.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cp">#define LWAN_LUA_METHOD(name_)                                                 \</span>
<span class="cp">    static int lwan_lua_method_##name_(lua_State *L);                          \</span>
<span class="cp">    static const struct lwan_lua_method_info                                   \</span>
<span class="cp">        __attribute__((used, section(LWAN_SECTION_NAME(lwan_lua_method))))     \</span>
<span class="cp">            lwan_lua_method_info_##name_ = {.name = #name_,                    \</span>
<span class="cp">                                            .func = lwan_lua_method_##name_};  \</span>
<span class="cp">    static int lwan_lua_method_##name_(lua_State *L)</span>
</pre></div>
</div>
<p>All functions in <code class="docutils literal notranslate"><span class="pre">lwan-lua.c</span></code> are now implemented this way to serve as
an example on how to use this feature.</p>
</div>
<div class="section" id="declaring-handlers-and-modules">
<h1>Declaring Handlers and Modules</h1>
<p>In order to make it more portable, safer, and easier to declare a
handler function in Lwan, a macro similar to <code class="docutils literal notranslate"><span class="pre">LWAN_LUA_METHOD()</span></code> has
been provided: <code class="docutils literal notranslate"><span class="pre">LWAN_HANDLER()</span></code>. It will declare a handler function
and a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lwan_handler_info</span></code> in a specific section in the
executable, making it easier for the configuration file reader to find
it every time, regardless of how that platform exports symbols, make it
impossible to refer to any exported symbol as a handler from the
configuration file, and slightly simplifies declaring a handler function
(without requiring, for instance, changing tables to make the
configuration file reader happy).</p>
<p>Defining a handler with this macro is trivial:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">LWAN_HANDLER</span><span class="p">(</span><span class="n">brew_coffee</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Placeholder handler to force the linker to define __start_lwan_handler and</span>
<span class="cm">     * __stop_lwan_handler.  */</span>
    <span class="k">return</span> <span class="n">HTTP_I_AM_A_TEAPOT</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As is looking it up (the linker does the job of registering each
handler):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">__attribute__</span><span class="p">((</span><span class="n">no_sanitize_address</span><span class="p">))</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">find_handler</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">lwan_handler_info</span> <span class="n">SECTION_START</span><span class="p">(</span><span class="n">lwan_handler</span><span class="p">);</span>
    <span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">lwan_handler_info</span> <span class="nf">SECTION_END</span><span class="p">(</span><span class="n">lwan_handler</span><span class="p">);</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">lwan_handler_info</span> <span class="o">*</span><span class="n">handler</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">handler</span> <span class="o">=</span> <span class="n">__start_lwan_handler</span><span class="p">;</span> <span class="n">handler</span> <span class="o">&lt;</span> <span class="n">__stop_lwan_handler</span><span class="p">;</span>
         <span class="n">handler</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">streq</span><span class="p">(</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A similar feature has been provided for modules, making it even possible
to list them from the Lwan command-line (<code class="docutils literal notranslate"><span class="pre">lwan</span> <span class="pre">-m</span></code> and <code class="docutils literal notranslate"><span class="pre">lwan</span> <span class="pre">-H</span></code> to
list modules and handlers, respectively). However, instead of specifying
a function as with <code class="docutils literal notranslate"><span class="pre">LWAN_HANDLER()</span></code>, one specifies a
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lwan_module</span></code> with <code class="docutils literal notranslate"><span class="pre">LWAN_REGISTER_MODULE()</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">lwan_module</span> <span class="n">module</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">serve_files_create</span><span class="p">,</span>
    <span class="p">.</span><span class="n">create_from_hash</span> <span class="o">=</span> <span class="n">serve_files_create_from_hash</span><span class="p">,</span>
    <span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">serve_files_destroy</span><span class="p">,</span>
    <span class="p">.</span><span class="n">handle_request</span> <span class="o">=</span> <span class="n">serve_files_handle_request</span><span class="p">,</span>
    <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">HANDLER_PARSE_ACCEPT_ENCODING</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">LWAN_REGISTER_MODULE</span><span class="p">(</span><span class="n">serve_files</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">module</span><span class="p">);</span>
</pre></div>
</div>
<p>In all cases, the only symbol that ends up being visible is the
associated <code class="docutils literal notranslate"><span class="pre">_info</span></code> struct; the handler function and module struct are
not exported.</p>
</div>
<div class="section" id="changes-to-the-string-buffer">
<h1>Changes to the String Buffer</h1>
<p>A HTTP/1.x server is essentially a program that transforms strings into
strings over a network connection, so some sort of facility to create
them efficiently is often desired. In Lwan, this is <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">strbuf</span></code>,
which has seen some trivial changes over the years, mainly to reduce the
amount of memory they need to work with (as every request struct has to
carry one of them).</p>
<p>It initially had two fields, <code class="docutils literal notranslate"><span class="pre">used</span></code> and <code class="docutils literal notranslate"><span class="pre">capacity</span></code>, where
<code class="docutils literal notranslate"><span class="pre">capacity</span></code> would be always the next power of two after <code class="docutils literal notranslate"><span class="pre">used</span></code> (and
the buffer would be reallocated accordingly). The <code class="docutils literal notranslate"><span class="pre">capacity</span></code> field has
now been removed; it’s now derived from <code class="docutils literal notranslate"><span class="pre">used</span></code>, as it’s cheap to align
to the next power of two to calculate it whenever needed.</p>
<p>Each connection triggered the allocation of a buffer for its associated
request <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">strbuf</span></code>, even if it might not be used (e.g. for
streaming requests, such as file serving). A <code class="docutils literal notranslate"><span class="pre">strbuf</span></code> is now
initialized pointing to an empty static string (with the <code class="docutils literal notranslate"><span class="pre">STATIC</span></code> flag
set); that’ll delay the allocation for when it’s truly needed. The
following table builds on the results from the coroutine optimizations,
optimizing the base case even further:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%"/>
<col style="width: 40%"/>
<col style="width: 38%"/>
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Connection</p></th>
<th class="head"><p>Malloc Calls Before</p></th>
<th class="head"><p>Malloc Calls After</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Keep-Alive</p></td>
<td><p>931</p></td>
<td><p>831</p></td>
</tr>
<tr class="row-odd"><td><p>Close</p></td>
<td><p>200,731</p></td>
<td><p>100,728</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="hash-table-changes">
<h1>Hash Table Changes</h1>
<p>The hash table has also seen some changes, most notably the ability to
rehash (although the heuristic to determine if rehashing is required
might need some work). The hash value is kept alongside each bucket
element, slightlyy alleviating the cost.</p>
<p>Another simple change that has been implemented is that, when an entry
is removed from a bucket, instead of defragmenting that bucket, the last
element is copied on top of the element being removed. Since order in a
bucket isn’t important, this made removing elements quite a bit more
efficient (and given that the hash table is an integral part of the
cache subsystem, this is important to keep the write lock locked for the
minimum amount of time.)</p>
<p>I’ve experimented with other techniques to implement a hash table,
including using robin-hood hashing, but I’m keeping it this way for the
moment. It’s something I want to revisit someday. (Also played with
hashing functions, including using AES-NI instructions instead of the
CRC32C from SSE4.2, but never got as far as integrating the experiments
in Lwan.)</p>
</div>
<div class="section" id="gracefully-closing-sockets">
<h1>Gracefully Closing Sockets</h1>
<p>The other day I received a bug report where pages served by Lwan and
loaded by W3M would take a long time to load. Not only this is unusual
because someone is actually using Lwan, but also because someone is
actually using W3M in 2019. Nevertheless, this was an interesting bug
with a simple fix: W3M implements only HTTP/1.0, and until the server
closes the connection, it won’t start parsing and displaying the results
(the connection would be closed after the keep-alive timeout was
reached, which is roughly 15s); now Lwan closes the connection as soon
as it’s done processing it, if it’s not marked as keep-alive. Easy to
spot using something like <code class="docutils literal notranslate"><span class="pre">strace</span></code>.</p>
<p>Closing a TCP socket, however, isn’t as simple as just calling
<code class="docutils literal notranslate"><span class="pre">close()</span></code>: there might be some enqueued packets not yet acknowledged
by the peer, so the usual solution to this is to call
<code class="docutils literal notranslate"><span class="pre">shutdown(fd,</span> <span class="pre">SHUT_WR)</span></code> to stop any kind of transmission and wait on a
loop calling <code class="docutils literal notranslate"><span class="pre">read()</span></code> until it returns <code class="docutils literal notranslate"><span class="pre">0</span></code> (signaling that the peer
has closed the connection), at which point it’s safe to just call
<code class="docutils literal notranslate"><span class="pre">close()</span></code> and consider that the connection has been closed.</p>
<p>However, from my testing, the scenario where one actually needs to wait
on a <code class="docutils literal notranslate"><span class="pre">read()</span></code> loop isn’t that common, especially with the big fat
pipes that are common these days; so, in order to minimize the number of
system calls made in the happy path, Lwan now checks if there are any
pending bytes to be sent/acknowledged by the peer before proceeding with
the usual method. This should equate to 2 system calls to close a
connection (the <code class="docutils literal notranslate"><span class="pre">ioctl()</span></code> and <code class="docutils literal notranslate"><span class="pre">close()</span></code>), rather than at least 3
(<code class="docutils literal notranslate"><span class="pre">shutdown()</span></code> + <code class="docutils literal notranslate"><span class="pre">read()</span></code> + <code class="docutils literal notranslate"><span class="pre">close()</span></code>) in the happy path.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">void</span> <span class="nf">graceful_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">lwan</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span>
                           <span class="k">struct</span> <span class="n">lwan_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
                           <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="k">static</span> <span class="n">DEFAULT_BUFFER_SIZE</span><span class="p">])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">lwan_connection_get_fd</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">conn</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">TIOCOUTQ</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* This ioctl isn't probably doing what it says on the tin; the details</span>
<span class="cm">         * are subtle, but it seems to do the trick to allow gracefully closing</span>
<span class="cm">         * the connection in some cases with minimal system calls. */</span>
        <span class="kt">int</span> <span class="n">bytes_waiting</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">TIOCOUTQ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytes_waiting</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bytes_waiting</span><span class="p">)</span> <span class="cm">/* See note about close(2) below. */</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">shutdown</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">SHUT_WR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">ENOTCONN</span><span class="p">))</span>
            <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tries</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">tries</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">ssize_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">DEFAULT_BUFFER_SIZE</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nl">EINTR</span><span class="p">:</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">EAGAIN</span><span class="p">:</span>
                <span class="n">coro_yield</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">coro</span><span class="p">,</span> <span class="n">CONN_CORO_WANT_READ</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">coro_yield</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">coro</span><span class="p">,</span> <span class="n">CONN_CORO_YIELD</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* close(2) will be called when the coroutine yields with CONN_CORO_ABORT */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(On platforms where that <code class="docutils literal notranslate"><span class="pre">ioctl()</span></code> isn’t available, the usual method
is used instead. <code class="docutils literal notranslate"><span class="pre">TIOCOUTQ</span></code> is Linux-specific, but it’s defined to
<code class="docutils literal notranslate"><span class="pre">0</span></code> or the equivalent value in other OSes with some <code class="docutils literal notranslate"><span class="pre">#include_next</span></code>
magic, so that the <code class="docutils literal notranslate"><span class="pre">while()</span></code> loop there works as a loop to both handle
the <code class="docutils literal notranslate"><span class="pre">ioctl()</span></code> call being interrupted and check if that <code class="docutils literal notranslate"><span class="pre">ioctl</span></code> is
available on that platform.)</p>
</div>
<div class="section" id="mime-type-table-improvements">
<h1>MIME Type table improvements</h1>
<p>Lwan contains an internal MIME Type table based on the public domain
table made for the Apache httpd project. The same file is used by
<code class="docutils literal notranslate"><span class="pre">mimegen</span></code>, a program built and used only during build time, that
generates a header file containing data suitable to be searched with
<code class="docutils literal notranslate"><span class="pre">bsearch()</span></code>. (The data in the header file is also compressed, saving a
few dozen kilobytes in the final executable.)</p>
<p>The table was initially laid out as an array of
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">{</span> <span class="pre">const</span> <span class="pre">char</span> <span class="pre">*extension;</span> <span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mime_type;</span> <span class="pre">}</span></code>, all
pointing to different positions within a character array. In other
words, not only only 4 entries could fit in a cache line (assuming
x86-64 here, with 8-byte pointers and 64-byte cache lines), each access
would mean that other cache lines had to be used to proxy the character
array.</p>
<p>With some trivial changes, this has been significantly improved: instead
of having a single table with extension+type, two (in-sync) tables are
provided. Search happens only in the first table; once an item is found
there, its position within the first table is used as an index in the
second table. This greatly reduces the cache pressure (each item in the
first table is fixed at 8 characters, so double the cache density for
<code class="docutils literal notranslate"><span class="pre">bsearch()</span></code> to breeze through quickly).</p>
<p>The change in the function to look up a MIME type given a file name
didn’t change much from 2014:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">lwan_determine_mime_type_for_file_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file_name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">last_dot</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="sc">'.'</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="o">!</span><span class="n">last_dot</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>

    <span class="n">STRING_SWITCH_L</span><span class="p">(</span><span class="n">last_dot</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">STR4_INT_L</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span><span class="sc">'j'</span><span class="p">,</span><span class="sc">'p'</span><span class="p">,</span><span class="sc">'g'</span><span class="p">)</span><span class="o">:</span>  <span class="k">return</span> <span class="s">"image/jpeg"</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT_L</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span><span class="sc">'p'</span><span class="p">,</span><span class="sc">'n'</span><span class="p">,</span><span class="sc">'g'</span><span class="p">)</span><span class="o">:</span>  <span class="k">return</span> <span class="s">"image/png"</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT_L</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span><span class="sc">'h'</span><span class="p">,</span><span class="sc">'t'</span><span class="p">,</span><span class="sc">'m'</span><span class="p">)</span><span class="o">:</span>  <span class="k">return</span> <span class="s">"text/html"</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT_L</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span><span class="sc">'c'</span><span class="p">,</span><span class="sc">'s'</span><span class="p">,</span><span class="sc">'s'</span><span class="p">)</span><span class="o">:</span>  <span class="k">return</span> <span class="s">"text/css"</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT_L</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span><span class="sc">'t'</span><span class="p">,</span><span class="sc">'x'</span><span class="p">,</span><span class="sc">'t'</span><span class="p">)</span><span class="o">:</span>  <span class="k">return</span> <span class="s">"text/plain"</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">STR4_INT_L</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span><span class="sc">'j'</span><span class="p">,</span><span class="sc">'s'</span><span class="p">,</span><span class="mh">0x20</span><span class="p">)</span><span class="o">:</span> <span class="k">return</span> <span class="s">"application/javascript"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="o">*</span><span class="n">last_dot</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">extension</span><span class="p">,</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">last_dot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">extension</span> <span class="o">=</span> <span class="n">bsearch</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">uncompressed_mime_entries</span><span class="p">,</span> <span class="n">MIME_ENTRIES</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
                            <span class="n">compare_mime_entry</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">extension</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">mime_types</span><span class="p">[(</span><span class="n">extension</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">uncompressed_mime_entries</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>
    <span class="p">}</span>

<span class="nl">fallback</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"application/octet-stream"</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This idea is far from novel; in fact, it’s common in video-game
development and is known as <a class="reference external" href="https://en.wikipedia.org/wiki/Data-oriented_design">data-oriented
design</a>.</p>
<p>(I investigated the possibility of using
<a class="reference external" href="https://www.gnu.org/software/gperf/">gperf</a> here instead, but
decided against it as this would require two build-time programs instead
of one for this feature.)</p>
</div>
<div class="section" id="accepting-clients">
<h1>Accepting Clients</h1>
<p>While it’s possible to wake a worker thread blocked on <code class="docutils literal notranslate"><span class="pre">epoll_wait()</span></code>
by adding a file descriptor to its watched set (by watching <code class="docutils literal notranslate"><span class="pre">EPOLLOUT</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">EPOLLIN</span></code>, even though you want to read from the socket
before sending a response, as counter-intuitive as this might sound), I
found that this isn’t the best approach. (Don’t know why yet, though.)</p>
<p>Until recently, Lwan was using a pipe to send the file descriptor number
from the main thread (which accepts the connection) to the worker thread
that would forever own it. This worked well, but meant that every new
connection would require at least two system calls that were unrelated
to actually handling the connections: <code class="docutils literal notranslate"><span class="pre">accept4()</span></code> and <code class="docutils literal notranslate"><span class="pre">write()</span></code>.
While pipes aren’t exactly slow (they’re just buffers in the kernel
anyway), it’s still a lot of overhead to write 4 bytes to another thread
in the same process.</p>
<p>Recent versions of Lwan uses a different approach: a lock-free
single-producer-single-consumer queue and an <code class="docutils literal notranslate"><span class="pre">eventfd</span></code>, are used to
queue file descriptors until the “horde” has passed (or the queue got
full). (While the main thread is accepting connections, it’s handling a
“horde”; once <code class="docutils literal notranslate"><span class="pre">accept4()</span></code> returns a <code class="docutils literal notranslate"><span class="pre">EAGAIN</span></code> error, the horde is
gone and the main thread can proceed.) The eventfd is then used to wake
up the worker thread (“nudging” in Lwan jargon), at which point it
proceeds to add the file descriptors to the sets, creates the associated
coroutines, and stuff like this.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">lwan-thread.c</span></code>, we define a function that tries adding a new
client to a worker thread a few times, dropping the connection if that
worker thread is somehow hosed even after repeated attempts at nudging
it:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">lwan_thread_add_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">lwan_thread</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">pushed</span> <span class="o">=</span> <span class="n">spsc_queue_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending_fds</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">pushed</span><span class="p">))</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="cm">/* Queue is full; nudge the thread to consume it. */</span>
        <span class="n">lwan_thread_nudge</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">lwan_status_error</span><span class="p">(</span><span class="s">"Dropping connection %d"</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
    <span class="cm">/* FIXME: send "busy" response now, even without receiving request? */</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And in <code class="docutils literal notranslate"><span class="pre">lwan.c</span></code>, you can see how the coroutine that handles incoming
connections batches each incoming herd and minimizes the amount of
nudges to wake up the worker threads:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="n">ALWAYS_INLINE</span> <span class="kt">int</span> <span class="nf">schedule_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">lwan</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">lwan_thread</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">conns</span><span class="p">[</span><span class="n">fd</span><span class="p">].</span><span class="kr">thread</span><span class="p">;</span>

    <span class="n">lwan_thread_add_client</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>

    <span class="cm">/* Connections are pre-scheduled, but we need a thread index, not a</span>
<span class="cm">     * pointer to a struct lwan_thread. */</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kr">thread</span> <span class="o">-</span> <span class="n">l</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">threads</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Using -1, 0, and 1 for enumeration values allows you to test them</span>
<span class="cm"> * using only comparisons with 0.  */</span>
<span class="k">enum</span> <span class="n">herd_accept</span> <span class="p">{</span> <span class="n">HERD_MORE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HERD_GONE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">HERD_SHUTDOWN</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">core_bitmap</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">bitmap</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* 256 processors should be enough for everybody */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">ALWAYS_INLINE</span> <span class="k">enum</span> <span class="n">herd_accept</span>
<span class="nf">accept_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">lwan</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">core_bitmap</span> <span class="o">*</span><span class="n">cores</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">accept4</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">main_socket</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">SOCK_NONBLOCK</span> <span class="o">|</span> <span class="n">SOCK_CLOEXEC</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">core</span> <span class="o">=</span> <span class="n">schedule_client</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>

        <span class="n">cores</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">[</span><span class="n">core</span> <span class="o">/</span> <span class="mi">64</span><span class="p">]</span> <span class="o">|=</span> <span class="n">UINT64_C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">core</span> <span class="o">%</span> <span class="mi">64</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">HERD_MORE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">EAGAIN</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">HERD_GONE</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">EBADF</span><span class="p">:</span>
    <span class="k">case</span> <span class="nl">ECONNABORTED</span><span class="p">:</span>
    <span class="k">case</span> <span class="nl">EINVAL</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">main_socket</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">lwan_status_info</span><span class="p">(</span><span class="s">"Signal 2 (Interrupt) received"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">lwan_status_info</span><span class="p">(</span><span class="s">"Main socket closed for unknown reasons"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">HERD_SHUTDOWN</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
        <span class="n">lwan_status_perror</span><span class="p">(</span><span class="s">"accept"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">HERD_MORE</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">accept_connection_coro</span><span class="p">(</span><span class="k">struct</span> <span class="n">coro</span> <span class="o">*</span><span class="n">coro</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">lwan</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">core_bitmap</span> <span class="n">cores</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">coro_yield</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">EPOLLHUP</span> <span class="o">|</span> <span class="n">EPOLLRDHUP</span> <span class="o">|</span> <span class="n">EPOLLERR</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">enum</span> <span class="n">herd_accept</span> <span class="n">ha</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="n">ha</span> <span class="o">=</span> <span class="n">accept_one</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cores</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ha</span> <span class="o">==</span> <span class="n">HERD_MORE</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">ha</span> <span class="o">&gt;</span> <span class="n">HERD_MORE</span><span class="p">))</span>
            <span class="k">break</span><span class="p">;</span>

    <span class="cm">/* A thread bitmap is maintained: accept_one() will set the nth bit</span>
<span class="cm">     * to signify that the nth thread needs to be nudged.  This loop</span>
<span class="cm">     * will then quickly go through every set bit in that bitmap and</span>
<span class="cm">     * nudge the appropriate thread. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_ELEMENTS</span><span class="p">(</span><span class="n">cores</span><span class="p">.</span><span class="n">bitmap</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cores</span><span class="p">.</span><span class="n">bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">c</span><span class="p">;</span> <span class="n">c</span> <span class="o">^=</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">size_t</span> <span class="n">core</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">__builtin_ctzl</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                <span class="n">lwan_thread_nudge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">64</span> <span class="o">+</span> <span class="n">core</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cores</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cores</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>On any other platform other than Linux, a pipe is used for the same
effect; it just doesn’t scale as well (requires two file descriptors per
worker thread instead of just one, allocates a larger kernel buffer for
no purpose whatsoever, etc.).</p>
<p>Weirdly enough, as much as the approach of adding the client sockets
directly to the worker thread’s epoll set with an <code class="docutils literal notranslate"><span class="pre">EPOLLOUT</span></code> event
rather than using this queue+eventfd mechanism reduced the amount of
system calls, the throughput when using non-keeepalive connections has
been measurably reduced (and not just in the noise). I don’t know why,
and haven’t investigated this yet.</p>
<p>(The current approach limits the number of worker threads that Lwan can
spawn, as threads are only nudged when connections have been assigned to
them. Currently it’s at 256 threads, which is fine for many systems
today – and certainly way better than any machine I have access to.)</p>
</div>
<div class="section" id="sample-programs">
<h1>Sample programs</h1>
<div class="section" id="freegeoip">
<h2>FreeGeoIP</h2>
<p>One of the first sample applications that I’ve written for Lwan was an
implementation of the <code class="docutils literal notranslate"><span class="pre">freegeoip.net</span></code> service. It’s been working fine
so far, serving a few hundred thousands requests per day (down from a
few million per day), using around 3MB of memory. It’s also pretty
stable: the server has been recently rebooted to update the kernel, and
before this happened, I observed that the service was chugging along for
over a year.</p>
<p>I’m pretty pleased with this, especially if one considers that the
original service that this has been cloned from caused a lot of
maintenance headache and was eventually abandoned.</p>
<p>There’s a <a class="reference external" href="https://freegeoip.lwan.ws">live version of this application running
here</a>.</p>
</div>
<div class="section" id="clock">
<h2>Clock</h2>
<p>A newer sample is the clock application. This generates a never-ending
GIF file, served with chunked encoding, that draws the current time in a
variety of styles: something that resembles a 7-segment display;
<a class="reference external" href="https://www.jwz.org/xdaliclock/">xdaliclock</a>; and a Tetris-like
animation (where falling blocks are rotated until they fit and form
digits).</p>
<p>This is but a hack, so it doesn’t work in all browsers (it’s known to be
broken on Safari for instance), but in supported ones, it’s a cheap way
to make animations without JavaScript, or to stream content from a
server.</p>
<div class="figure align-center" id="id1">
<img alt="xdaliclock rendered on-the-fly" src="https://time.lwan.ws/dali.gif"/>
<p class="caption"><span class="caption-text">Look at those melting digits! No JavaScript or CSS required.</span></p>
</div>
<p>(And, of course, the “never-ending” aspect isn’t actually correct. Bots
would try to download the GIFs, without any kind of timeout. I’ve seen
bots trying to download those for days. It now forces the page to be
reloaded every hour and limits each GIF to a little bit more than that.
Implement timeouts when writing crawlers, people.)</p>
<p>There’s a <a class="reference external" href="https://time.lwan.ws">live version of this application running
here</a>.</p>
</div>
</div>
<div class="section" id="proxy-protocol">
<h1>Proxy Protocol</h1>
<p>Putting Lwan behind a proxy is a common scenario to workaround the lack
of two features: virtual hosts and TLS. Both are somewhat trivial to
implement, but I haven’t gotten around supporting any of them because,
in my use case, I’m perfectly happy to stick a
<a class="reference external" href="https://www.varnish-cache.org">Varnish</a> cache and a <a class="reference external" href="https://hitch-tls.org/">TLS
terminator</a> in front of it. In order to allow
functions such as <code class="docutils literal notranslate"><span class="pre">lwan_request_get_remote_address()</span></code> to return the
correct client address (instead of, say, <code class="docutils literal notranslate"><span class="pre">::1</span></code>), Lwan has to be aware
that it’s being proxied.</p>
<p>A popular protocol for this, pioneered by
<a class="reference external" href="http://www.haproxy.org/">HAProxy</a>, is aptly named <a class="reference external" href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt">PROXY
protocol</a>.
An implementation for both versions 1 and 2 has been contributed to Lwan
by Malthe Borch as one of the first open source contributions to Lwan;
thank you very much! (This is disabled by default because it should only
be used if Lwan is known to be behind a reverse proxy. Inadvertently
enabling it would allow anyone to easily spoof the client IP address to
request handlers.)</p>
<p>(I did investigate using
<a class="reference external" href="https://netdevconf.info/1.2/papers/ktls.pdf">kTLS</a>, but didn’t go
that far at the time as it wasn’t part of mainline Linux kernel. I might
give it a try someday now that it is, though.)</p>
</div>
<div class="section" id="websockets">
<h1>WebSockets</h1>
<p>Lwan has also gained the ability to function as a WebSockets server. The
protocol is trivial to implement (wonky handshaking and unoptimal
framing notwithstanding), but defining an API that’s usable from C is
quite challenging. I’ve tried a few combinations but never got to the
point where I could find something I liked; I have some ideas to try but
they’re still pretty fuzzy in my head.</p>
<p>The program below illustrates the current state of the API: while it
seems straightforward enough for an endpoint to check if a WebSocket
connection upgrade was requested by the client, and trivial to send
stuff over the wire, there are a few drawbacks with the current
situation:</p>
<ul class="simple">
<li><p>PING requests will only be processed by
<code class="docutils literal notranslate"><span class="pre">lwan_response_websocket_read()</span></code>; this example will never respond
to a PING packet and might be disconnected by a client.</p></li>
<li><p>Both the read and the write primitives are blocking; it’s not
possible to write something that can both wait for commands and
occasionally send data over the wire. It should be possible to, for
instance, write an echo server, but it’s not possible to implement
<a class="reference external" href="https://socket.io">socket.io</a> for instance.</p></li>
<li><p>There are currently no tests for WebSockets as well; testing is
performed manually by using the WebSockets inspection tool in web
browsers, but automated tests would be preferred. I suspect that
reading from a WebSocket is broken after a lot of unrelated changes
in the main loop.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">LWAN_HANDLER</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Requesting an upgrade will send an appropriate response if the</span>
<span class="cm">     * request contained a valid handshake, returning HTTP code 101 in that</span>
<span class="cm">     * case. Any other error code won't generate a default response,</span>
<span class="cm">     * so the handler can return at this point.</span>
<span class="cm">     *</span>
<span class="cm">     * Having a separate function to upgrade a WebSocket connection</span>
<span class="cm">     * (as opposed to having a flag in a handler that would try to do</span>
<span class="cm">     * this automatically) is useful to allow people to write, for instance,</span>
<span class="cm">     * authorization code to explicitly upgrade a connection only if</span>
<span class="cm">     * certain checks passes. */</span>
    <span class="k">enum</span> <span class="n">lwan_http_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">lwan_request_websocket_upgrade</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">HTTP_SWITCHING_PROTOCOLS</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Similar to chunked encoding and server-sent events, the response</span>
<span class="cm">         * string buffer contains the data that is going to the wire, or</span>
<span class="cm">         * data that was received from the wire.  The strbuf is reset every</span>
<span class="cm">         * time a response is sent or received. */</span>
        <span class="n">lwan_strbuf_printf</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"Some random integer: %d"</span><span class="p">,</span> <span class="n">rand</span><span class="p">());</span>
        <span class="n">lwan_response_websocket_write</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
        <span class="n">lwan_request_sleep</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">HTTP_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rewrite-module">
<h1>Rewrite Module</h1>
<p>Inspired by Apache httpd’s <code class="docutils literal notranslate"><span class="pre">mod_rewrite</span></code>, a module with similar
functionality has been implemented in Lwan. Instead of a bespoke syntax,
though, it can be set up using the same configuration file syntax;
albeit more verbose, it’s significantly easier to understand.</p>
<p>Based on <a class="reference external" href="https://www.lua.org/manual/5.3/manual.html#6.4.1">Lua’s pattern matching
engine</a>, which were
chosen because they’re not only powerful enough, but it’s also a
<a class="reference external" href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">DFA</a>,
which makes it a lot harder for an unbounded backreference to DoS the
server (as it doesn’t support any).</p>
<p>This is how it looks in the configuration file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/># Instantiate the "rewrite" module to respond in "/pattern".
rewrite /pattern {
    # Match /patternfoo..., and redirect to a new URL.
        pattern foo/(%d+)(%a)(%d+) {
                redirect to = /hello?name=pre%2middle%3othermiddle%1post
        }
    # Match /patternbar/... and rewrite as /hello...
        pattern bar/(%d+)/test {
                rewrite as = /hello?name=rewritten%1
        }
    # Use Lua to determine where the client should redirect to
        pattern lua/redir/(%d+)x(%d+) {
                expand_with_lua = true
                redirect to = '''
                    function handle_rewrite(req, captures)
                        local r = captures[1] * captures[2]
                        return '/hello?name=redirected' .. r
                    end
                '''
        }
    # Use Lua to determine how to rewrite the request
        pattern lua/rewrite/(%d+)x(%d+) {
                expand_with_lua = true
                rewrite as = """function handle_rewrite(req, captures)
                        local r = captures[1] * captures[2]
                        return '/hello?name=rewritten' .. r
                    end"""
        }
}
</pre></div>
</div>
<p>Without <code class="docutils literal notranslate"><span class="pre">expand_with_lua</span></code> set (or set to <code class="docutils literal notranslate"><span class="pre">false</span></code>), the expansion
rule is trivial: <code class="docutils literal notranslate"><span class="pre">%n</span></code> will expand to the n-th capture; everything else
will be copied verbatim. When set, a <code class="docutils literal notranslate"><span class="pre">handle_rewrite()</span></code> function has
to be defined; the <code class="docutils literal notranslate"><span class="pre">req</span></code> parameter contains the same metamethods
available for handlers in the <code class="docutils literal notranslate"><span class="pre">lua</span></code> module, and <code class="docutils literal notranslate"><span class="pre">captures</span></code> is a
table containing the pattern matches.</p>
<p>As a measure against bad configuration, URLs can’t be rewritten over 4
times (otherwise, a 500 Internal Error response is generated instead).</p>
<p>(This module prompted a change in the configuration file parser that
allows a section to be “isolated”: while the file is being read, if it’s
in a start section line, one can ask the configuration reader to isolate
the section. What this does is that it creates a proxy configuration
struct that has a view of only that particular section. This isolated
configuration object is passed to a module, that can read as usual
without having to worry about overreading the main configuration.)</p>
</div>
<div class="section" id="snippets">
<h1>Snippets</h1>
<div class="section" id="non-boolean-predicates">
<h2>Non-boolean predicates</h2>
<p>C lacks option types, but sometimes you can get creative with what you have.
For instance, I like how elegant this small piece of code that determines
the temporary directory turned out:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">is_dir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">v</span> <span class="o">!=</span> <span class="sc">'/'</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">st_mode</span> <span class="o">&amp;</span> <span class="n">S_ISVTX</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">lwan_status_warning</span><span class="p">(</span>
            <span class="s">"Using %s as temporary directory, but it doesn't have "</span>
            <span class="s">"the sticky bit set."</span><span class="p">,</span>
            <span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">get_temp_dir</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tmpdir</span><span class="p">;</span>

    <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">is_dir</span><span class="p">(</span><span class="n">secure_getenv</span><span class="p">(</span><span class="s">"TMPDIR"</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmpdir</span><span class="p">;</span>

    <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">is_dir</span><span class="p">(</span><span class="n">secure_getenv</span><span class="p">(</span><span class="s">"TMP"</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmpdir</span><span class="p">;</span>

    <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">is_dir</span><span class="p">(</span><span class="n">secure_getenv</span><span class="p">(</span><span class="s">"TEMP"</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmpdir</span><span class="p">;</span>

    <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">is_dir</span><span class="p">(</span><span class="s">"/var/tmp"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmpdir</span><span class="p">;</span>

    <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">is_dir</span><span class="p">(</span><span class="n">P_tmpdir</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmpdir</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">is_dir()</span></code> predicate returns the same input parameter if it turns
that its condition holds (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if it doesn’t), and it is used to
drive the conditions in <code class="docutils literal notranslate"><span class="pre">get_temp_dir()</span></code> as well as the return value
for that function. I don’t think that this could get any cleaner.</p>
<p>(I was actually going to write a blog post on how to create temporary
files safely – which these funcions are part of – but <a class="reference external" href="https://systemd.io/TEMPORARY_DIRECTORIES">Lennart
Poettering</a> beat me to it.)</p>
</div>
<div class="section" id="boolean-flags-to-bitmask-without-branching">
<h2>Boolean flags to bitmask without branching</h2>
<p>Sometimes, it’s necessary to convert one set of bitwise mask into
another set of bitwise mask. Something like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="n">flag1</span><span class="p">)</span> <span class="n">flags</span> <span class="o">|=</span> <span class="n">SOME_BIT_MASK1</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">flag2</span><span class="p">)</span> <span class="n">flags</span> <span class="o">|=</span> <span class="n">SOME_BIT_MASK2</span><span class="p">;</span>
</pre></div>
</div>
<p>In order to get rid of those branches, one can extend the <code class="docutils literal notranslate"><span class="pre">bool</span></code> type
into <code class="docutils literal notranslate"><span class="pre">typeof(flags)</span></code>, and shift it by <code class="docutils literal notranslate"><span class="pre">log2(mask)</span></code>. Lwan does this
with some flags:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cp">#define REQUEST_FLAG(bool_, name_)                                             \</span>
<span class="cp">    ((enum lwan_request_flags)(((uint32_t)lwan-&gt;config.bool_)                  \</span>
<span class="cp">                               &lt;&lt; REQUEST_##name_##_SHIFT))</span>
<span class="n">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">enum</span> <span class="n">lwan_request_flags</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">),</span>
              <span class="s">"lwan_request_flags has the same size as uint32_t"</span><span class="p">);</span>
</pre></div>
</div>
<p>Which is then used like so:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="n">lwan_request_flags</span> <span class="n">flags</span> <span class="o">=</span>
        <span class="n">REQUEST_FLAG</span><span class="p">(</span><span class="n">proxy_protocol</span><span class="p">,</span> <span class="n">ALLOW_PROXY_REQS</span><span class="p">)</span> <span class="o">|</span>
        <span class="n">REQUEST_FLAG</span><span class="p">(</span><span class="n">allow_cors</span><span class="p">,</span> <span class="n">ALLOW_CORS</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
]]></description>
            <category><![CDATA[ programming ]]></category>
             <pubDate>Thu, 24 Oct 2019 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2018/06/28/include_next_and_portability.html</link>
            <guid>http://tia.mat.br/blog/html/2018/06/28/include_next_and_portability.html</guid>
            <title><![CDATA[include_next and portability]]></title>
            <description><![CDATA[<h1>include_next and portability</h1>
<p>One of the decisions I took early on while writing Lwan was to only support
Linux, and think about portability later; this decision was influenced by the
way the <a class="reference external" href="https://www.openbsd.org/papers/portability.pdf">OpenBSD project approaches portability</a>.</p>
<p>In retrospect, this was a good decision: this avoided many of the pitfalls
associated in <a class="reference external" href="http://wiki.c2.com/?PrematureAbstraction">writing abstractions too early in the game</a>.  It also made the code cleaner:
the abundance of C preprocessor usage, common in some portable code, hinders
legibility and maintainability.  Of course, this decision made it
challenging to port it to other operating systems.</p>
<p>I was content with this decision – until people began asking for BSD and Mac
ports.  With the exception of some system calls (e.g.  epoll, or the Linux
<a class="reference external" href="http://man7.org/linux/man-pages/man2/sendfile.2.html">sendfile</a> variant), porting shouldn’t be surprising.  Ideally, having the code
largely <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code> free would be ideal, so I had to find a way to make this happen.</p>
<p>While reading the GCC manual, I found out about an extension – that also
happens to be <a class="reference external" href="https://clang.llvm.org/docs/LanguageExtensions.html">implemented by Clang</a> – that fit perfectly
this scenario: <a class="reference external" href="https://gcc.gnu.org/onlinedocs/cpp/Wrapper-Headers.html">wrapper headers</a>.  It’s a C
preprocessor extension that includes the next file in the include lookup
path.  With this extension, it’s possible to write our own substitute header
files, named after standard header files:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span><span class="cpf">_next &lt;stdlib.h&gt; /* Include stdlib.h from system includes */</span><span class="cp"/>

<span class="cp">#ifndef MISSING_STDLIB_H_</span>
<span class="cp">#define MISSING_STDLIB_H_</span>

<span class="cp">#if !defined(HAVE_MKOSTEMP)</span>
<span class="kt">int</span> <span class="nf">mkostemp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(HAVE_REALLOCARRAY)</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">reallocarray</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">optr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* MISSING_STDLIB_H_ */</span><span class="cp"/>
</pre></div>
</div>
<p>Have it in a directory named, say, “missing”, and modify the header lookup path
so it is looked up first by the compiler.  This is easily accomplished in CMake
by specifying an include directory with the <code class="docutils literal notranslate"><span class="pre">BEFORE</span></code> option:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">include_directories</span><span class="p">(</span><span class="n">BEFORE</span> <span class="n">src</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">missing</span><span class="p">)</span>
</pre></div>
</div>
<p>(This just ensures that <code class="docutils literal notranslate"><span class="pre">src/lib/missing</span></code> will be passed before any other <code class="docutils literal notranslate"><span class="pre">-I</span></code>
argument to the compiler, regardless of the order any other
<code class="docutils literal notranslate"><span class="pre">include_directories()</span></code> macro is invoked.  Your build system might differ, this
is copied straight from Lwan’s.)</p>
<img alt="missing directory tree" class="align-right" src="https://i.imgur.com/c3ntvJL.png"/>
<p>Then it’s just the matter of implementing these functions in terms of other
functions available in the system, and code using it will be none the wise: a
<code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;stdlib.h&gt;</span></code> line will include our wrapper header, which in turn will
include the system’s <code class="docutils literal notranslate"><span class="pre">stdlib.h</span></code> header; it then might define, in this example,
additional prototypes, based on what the build system could determine during the
configuration phase.</p>
<p>This way, most <code class="docutils literal notranslate"><span class="pre">#ifdefs</span></code> are hidden away in a single file, making it a lot easier
to maintain and read the code.  No application-specific abstraction layer with
quirky semantics; just the familiar quirkiness from POSIX.</p>
<p>One of the things I’m particular proud of is the miniature <a class="reference external" href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a> implementation on top
of <a class="reference external" href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2">kqueue</a>
(available in BSD systems).  I considered moving Lwan to use an abstraction
library (such as <a class="reference external" href="http://libevent.org/">libevent</a> or <a class="reference external" href="https://libuv.org/">libuv</a>) just for this, but was able to keep using its
event-handling loop as is.  Not only I understand 100% of it, it was a
worthwhile learning experience.  With ~120 lines of C code, this epoll
implementation is easier to wrap my head around than the thousands of lines
of code from those libraries.</p>
]]></description>
             <pubDate>Thu, 28 Jun 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2018/02/01/more_on_string_switch_in_c.html</link>
            <guid>http://tia.mat.br/blog/html/2018/02/01/more_on_string_switch_in_c.html</guid>
            <title><![CDATA[More on string switch in C]]></title>
            <description><![CDATA[<h1>More on string switch in C</h1>
<p>Talking about uncommon programming tricks the other day, the subject of
switching on strings in C appeared on the table.</p>
<p>If you follow this blog, you know it’s something <a class="reference external" href="/posts/2012/08/09/string_switch_in_c.html">actually possible to do
with a little bit of ingenuity</a>; in fact, it’s one of the
things that I use in Lwan to parse the HTTP requests.  I didn’t spend too
much time in that blog post to explain why it is faster, so I’m rectifying
this now.</p>
<p>In order to understand why it’s so fast, let me step aside for a moment and
show a function every C programmer should be able to write: <code class="docutils literal notranslate"><span class="pre">strlen()</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span><span class="o">++</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Style issues aside, this is pretty much the simplest way to implement this
function.  And, maybe the one that generates the slowest code.  There are
many reasons here, so let’s explore some of them.</p>
<p>One of them is that CPUs are able to fetch more than a single byte at a time
from memory (or cache).  And it takes roughly the same time for it to fetch
8 bits than it takes to fetch 32 bits.  People that write C libraries know
about this fact, so that the version that your operating system provides is
most likely going to exploit this.  Let’s rewrite the <code class="docutils literal notranslate"><span class="pre">strlen()</span></code> function,
then:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>

        <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a big issue in this code: it is invoking undefined behavior.  The
explanation of why this is illegal in C will follow, but for now, let’s just
assume that the integer cast from a character pointer is valid.</p>
<p>With that assumption in mind, what this program is doing is in fact very
simple: it is reducing the amount of expensive operations (fetching things
from memory), and is increasing the amount of cheap operations (masking bits
and comparing integers).  In fact, that’s a recurring theme whenever you’re
trying to optimize any algorithm: the computer can’t run a piece of code faster,
but you can make the computer run smarter code that produces the same output.</p>
<p>This program, however, will most likely crash on some platforms, or be
really slow on others.  The reason is that it is trying to read a pointer
that is not aligned.  Some CPU designers decided to increase the complexity
and perform more work behind the scenes to make this work, and some decided
it wasn’t worth the trouble and will just generate an exception.  The major
problem, however, is that this is precisely the undefined behavior I was talking
about.  So, let’s fix this function, by modifying it slightly so that the fast
path operates on aligned pointers:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_ptr_aligned</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uintptr_t</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

    <span class="cm">/* Assuming a 32-bit machine with 4-byte alignment for</span>
<span class="cm">     * integers.  Executing "AND (n - 1)" is equivalent to "MOD</span>
<span class="cm">     * (n)", without an expensive division operation; this is</span>
<span class="cm">     * true for every (n), as long as (n) is a power of 2.</span>
<span class="cm">     * Compilers can do this optimization on constant values,</span>
<span class="cm">     * but I prefer to be explicit. */</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Read one byte at a time until the pointer is aligned. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_ptr_aligned</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
        <span class="n">len</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Pointer is aligned, try the faster version now. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>

        <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is still an even faster way, that is to improve the way the NUL byte
is found in a word.  The excellent (and one of my favorite websites) “<a class="reference external" href="https://graphics.stanford.edu/~seander/bithacks.html#ZeroInWord">Bit
Twiddling Hacks</a>” web
page has a method to find out if a word contains a NUL byte; it doesn’t tell
which byte is the NUL byte, but we don’t need to know that in the fast path:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">v</span><span class="p">;</span>

    <span class="cm">/* Read one byte at a time until the pointer is aligned. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_ptr_aligned</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
        <span class="n">len</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Pointer is aligned, try the faster version now. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>

        <span class="cm">/* Use a fast bit twiddling hack to find if the</span>
<span class="cm">         * next 4 bytes in the string has a 0 byte. If</span>
<span class="cm">         * it does, find out which byte it is. */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">-</span> <span class="mh">0x01010101</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0x80808080</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Another thing to consider in these functions is that they’re not endian
neutral.  A decent implementation would ensure that it would work both on
little-endian and on big-endian machines.  A decent programmer would even
build and test these; I didn’t.</p>
<p>Yet another thing to consider is that hand-tuned assembly versions, most
likely written to make use of vector instructions, are the ones that your
computer are executing at this very instant; but they all draw from these
very same ideas: read memory less often, compare in bulk.</p>
<p>Also, there are most likely better ways to write these functions, even without
vector instructions.  But this is besides the point of explaining why the
string switch trick works so well.</p>
<p>Now, this kind of optimization happens on pratically all string handling functions
in the C standard library.  And functions that perform substring comparison,
such as <code class="docutils literal notranslate"><span class="pre">strncmp()</span></code>, are no exception.</p>
<p>When faced with the necessity to check for a bunch of strings, the idiomatic
C way of doing so would be the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"GET "</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_GET</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"POST "</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_POST</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"DELETE "</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_DELETE</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"HEAD "</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_HEAD</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="k">return</span> <span class="n">HTTP_METHOD_UNKNOWN</span><span class="p">;</span>
</pre></div>
</div>
<p>It’s not difficult to imagine that each invocation of <code class="docutils literal notranslate"><span class="pre">strncmp()</span></code> would have to
do things that are similar to what our toy <code class="docutils literal notranslate"><span class="pre">strlen()</span></code> implementation had to do:
align the pointer (which is slow) before it could start the fast path.  But, in
this case, things are even worse, because, if the pointer isn’t aligned, it
might not even get to the point where the fast path will make sense, because the
strings it is comparing against are very close to the alignment of the word
size for this computer!</p>
<p>So, to recap, what the string switch does is the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">string_to_uint32</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">v</span><span class="p">;</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define STRING_SWITCH(s) switch (string_to_uint32(s))</span>
<span class="cp">#define MCC(a, b, c, d) ((a) &lt;&lt; 24 | (b) &lt;&lt; 16 | (c) &lt;&lt; 8 | (d))</span>
<span class="k">enum</span> <span class="p">{</span>
    <span class="n">METHOD_GET</span> <span class="o">=</span> <span class="n">MCC</span><span class="p">(</span><span class="sc">'G'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="sc">'T'</span><span class="p">,</span> <span class="sc">' '</span><span class="p">),</span>
    <span class="n">METHOD_POST</span> <span class="o">=</span> <span class="n">MCC</span><span class="p">(</span><span class="sc">'P'</span><span class="p">,</span> <span class="sc">'O'</span><span class="p">,</span> <span class="sc">'S'</span><span class="p">,</span> <span class="sc">'T'</span><span class="p">),</span>
    <span class="n">METHOD_DELETE</span> <span class="o">=</span> <span class="n">MCC</span><span class="p">(</span><span class="sc">'D'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="sc">'L'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">),</span>
    <span class="n">METHOD_HEAD</span> <span class="o">=</span> <span class="n">MCC</span><span class="p">(</span><span class="sc">'H'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">,</span> <span class="sc">'D'</span><span class="p">),</span>
    <span class="cm">/* ... */</span>
<span class="p">};</span>

<span class="n">STRING_SWITCH</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="nl">METHOD_GET</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_GET</span><span class="p">;</span>
<span class="k">case</span> <span class="nl">METHOD_POST</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_POST</span><span class="p">;</span>
<span class="k">case</span> <span class="nl">METHOD_DELETE</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_DELETE</span><span class="p">;</span>
<span class="k">case</span> <span class="nl">METHOD_HEAD</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_HEAD</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="k">default</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">HTTP_METHOD_UNKNOWN</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The good thing about the switch statement in C is that it is maybe the
highest level statement in the language: the compiler can get really
creative in how its code is generated.  It’s not uncommon for it to generate
jump tables or even binary searches.  So this implementation would actually
be faster than the various calls to <code class="docutils literal notranslate"><span class="pre">strncmp()</span></code> because:</p>
<ol class="arabic simple">
<li><p>Comparing integers is dirt cheap.</p></li>
<li><p>The compiler knows what <code class="docutils literal notranslate"><span class="pre">memcpy()</span></code> does, so it’s very likely that on
architectures where unaligned memory access is fine and there’s no
performance penalty (any Intel Core CPU after Sandy Bridge for instance),
it’ll be just a regular old MOV instruction when the size is small
and known at compile time.</p></li>
<li><p>Even if the compiler didn’t know what <code class="docutils literal notranslate"><span class="pre">memcpy()</span></code> does, it would only
fill a register once, by doing potentially expensive byte-by-byte copies
because of unaligned pointer access, and then proceed to just compare
integers.</p></li>
<li><p>There is less function call overhead; specially nice since this is
most likely not going through the PLT.</p></li>
<li><p>The compiler can reorder the comparisons as it see fit, often producing
very tight code.</p></li>
</ol>
<p>These kinds of micro-optimizations don’t necessarily have to be completely
unreadable and full of magical constants.</p>
]]></description>
             <pubDate>Thu, 01 Feb 2018 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2017/05/08/coreboot_luks.html</link>
            <guid>http://tia.mat.br/blog/html/2017/05/08/coreboot_luks.html</guid>
            <title><![CDATA[Coreboot & LUKS]]></title>
            <description><![CDATA[<h1>Coreboot &amp; LUKS</h1>
<p>My laptop is a 6-year old <a class="reference external" href="http://www.thinkwiki.org/wiki/Category:X220">ThinkPad X220</a>.  Although it’s almost
falling apart from years of constant abuse, I don’t see myself replacing it
anytime soon: it’s easy to repair, has a great keyboard, and is a very
dependable machine.</p>
<p>And it’s supported by <a class="reference external" href="https://en.wikipedia.org/wiki/Coreboot">Coreboot</a>.
Substituting the proprietary firmware with it is very trivial: I followed
the instructions on <a class="reference external" href="https://tylercipriani.com/blog/2016/11/13/coreboot-on-the-thinkpad-x220-with-a-raspberry-pi/">this blog post</a>
and they worked out of the box.  (I also went the extra mile and flashed the
firmware after passing it through <a class="reference external" href="https://github.com/corna/me_cleaner">me_cleaner</a>.)</p>
<div class="figure align-center" id="id1">
<img alt="flashing X220 bios" src="https://i.imgur.com/97rTiZH.jpg"/>
<p class="caption"><span class="caption-text">Flashing the serial flash using a Raspberry Pi 3. Yes, I need to clean
up this computer.</span></p>
</div>
<p>The major difference from my previous setup is that my SSD had
<a class="reference external" href="https://en.wikipedia.org/wiki/Hardware-based_full_disk_encryption">hardware-based full disk encryption</a>.  I
ended up disabling this for two reasons: first, this isn’t very secure (the
key will remain in the disk RAM for as long as power is supplied); second, I
was not sure if Coreboot supported this.  So I disabled encryption prior to
flashing the new firmware.</p>
<p>But keeping a hard drive unencrypted on a laptop isn’t good practice.  I
decided to use <a class="reference external" href="https://en.wikipedia.org/wiki/Linux_Unified_Key_Setup">LUKS</a>
instead.</p>
<p>However, instead of using <a class="reference external" href="https://en.wikipedia.org/wiki/SeaBIOS">SeaBIOS</a>
as the payload and have a standard bootloader, I opted to go through a
slightly different route: have a custom-built Linux inside the ROM, open the
<code class="docutils literal notranslate"><span class="pre">/boot</span></code> partition with LUKS, and
<a class="reference external" href="http://man7.org/linux/man-pages/man2/kexec_load.2.html">kexec</a> the current
vmlinuz/initrd.</p>
<p>Compared to the usual setup of using SeaBIOS as a payload, this setup
reduces boot time by cutting the middlemen.  With the ability to boot from
external devices removed, it’s also arguably more secure.  The in-ROM Linux
has only the bare minimum: no network subsystem, only necessary filesystems,
bare minimum drivers are built-in, USB is limited to HID devices, etc; the
compressed kernel has ~1.7MiB with room to shrink.  The in-ROM initrd is
also quite minimal, containing just one file.</p>
<p>The only file is a <a class="reference external" href="https://gist.github.com/lpereira/845fe060ba68a5db95827cbc5496bb6d">hacked version</a> of
cryptsetup that acts as a primitive init, creating <code class="docutils literal notranslate"><span class="pre">/proc</span></code>, <code class="docutils literal notranslate"><span class="pre">/dev</span></code> (and mounting
these two), and <code class="docutils literal notranslate"><span class="pre">/boot</span></code>, decrypting <code class="docutils literal notranslate"><span class="pre">/boot</span></code>, and performing kexec.  It’s
statically linked with <a class="reference external" href="https://www.musl-libc.org/">musl libc</a>.</p>
<p>Flashing this requires opening the laptop, and I’m planning to do this next
weekend when replacing the USB ports.  However, the setup works very well
under <a class="reference external" href="http://www.qemu.org/">QEMU</a>.</p>
<p>This blog post isn’t meant as a tutorial – feel free to contact me if you
have questions or ideas on how to improve this.  If you end up using
something similar to this idea, I’d love to know as well.</p>
]]></description>
            <category><![CDATA[ linux ]]></category>
            <category><![CDATA[ x220 ]]></category>
            <category><![CDATA[ hack ]]></category>
             <pubDate>Mon, 08 May 2017 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2017/03/01/parsing_json.html</link>
            <guid>http://tia.mat.br/blog/html/2017/03/01/parsing_json.html</guid>
            <title><![CDATA[Parsing JSON]]></title>
            <description><![CDATA[<h1>Parsing JSON</h1>
<p>There are many libraries out there to parse JSON files.  It might be a
futile attempt, then, to write yet another one.  However, when you’re
working on a RTOS where memory is golden, and the alternatives don’t look
that great, you got to do something about it.</p>
<p>Recently I wrote a <a class="reference external" href="http://www.json.org">JSON</a> parser for a project at
work.  This parser uses constant memory, regardless of the amount of data
it’s working with, and deserializes directly to a C struct.  Similar, in
spirit, to the JSON parser that’s part of the Golang standard library, that
encodes and decodes data based on a tagged structure.</p>
<p>The lexer is the usual state machine, where the state itself is a function
pointer to a function that handles that particular state.</p>
<p>I’ve been using this technique for a while, and I found that it’s a very
clean and efficient way of describing state machines, specially for lexers.</p>
<p>I began using it after a coworker wrote a <a class="reference external" href="https://github.com/solettaproject/soletta/blob/3bda9802b243c2052555cf88263f754d34458414/src/shared/sol-fbp-internal-scanner.c">parser for a DSL</a>
using it – and he got the idea from the – you guessed – Golang template
package.  (There’s a <a class="reference external" href="https://www.youtube.com/watch?v=HxaD_trXwRE">nice talk by Rob Pike about it</a> – I recommend this talk
not only for the lexing goodness, but also for the tips on how to evolve a
concurrent design.)</p>
<p>The parser implementation itself is nothing to write home about.  However,
by using the same idea used in Lwan’s mustache template engine to <a class="reference external" href="https://tia.mat.br/posts/2012/11/11/mustache_templates_in_c.html">obtain
the variables</a>, it
manages to do some things that are not common in JSON parsers written in C:</p>
<ul class="simple">
<li><p>It will accept only values of known types for a particular key.</p></li>
<li><p>It will save the decoded value directly in a struct field.</p></li>
<li><p>It won’t try to decode the same field twice.</p></li>
</ul>
<p>The first point is crucial when working with data received from the network,
which is precisely the kind of thing I’m dealing with.  This avoids problems
such as type confusion and such, and moves the responsibility of checking
the types to the library rather than the user of the library.</p>
<p>By saving the decoded value directly into a struct field, it does use a
predictable amount of memory.  This is good, as it’s not going to balloon
out of control, or require some guesswork to know beforehand how many tokens
are going to be necessary to deserialize some values.  The C compiler
already knows exactly how many bytes a struct needs.</p>
<p>Some fields might be optional in a JSON blob.  So the parser uses a bitmask
to mark which fields have been decoded (and returns that, so that the
library user can efficiently test if a value has been deserialized or not).
Since it was easy to do, the library refuses to decode a key that has been
deserialized before.</p>
<p>So, a typical use is the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cm">/* First, define a struct to hold the values. */</span>
<span class="k">struct</span> <span class="n">values</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">some_string</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">some_int</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">some_bool</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Then, define a descriptor for that struct. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">json_descr</span> <span class="n">values_descr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">FIELD</span><span class="p">(</span><span class="k">struct</span> <span class="n">values</span><span class="p">,</span> <span class="n">some_string</span><span class="p">,</span> <span class="n">JSON_TOK_STRING</span><span class="p">),</span>
    <span class="n">FIELD</span><span class="p">(</span><span class="k">struct</span> <span class="n">values</span><span class="p">,</span> <span class="n">some_int</span><span class="p">,</span> <span class="n">JSON_TOK_NUMBER</span><span class="p">),</span>
    <span class="n">FIELD</span><span class="p">(</span><span class="k">struct</span> <span class="n">values</span><span class="p">,</span> <span class="n">some_bool</span><span class="p">,</span> <span class="n">JSON_TOK_TRUE</span><span class="p">),</span>
<span class="p">};</span>
<span class="cm">/* (FIELD is just a macro that saves the offsetof()</span>
<span class="cm"> * each struct member so that a pointer can be produced</span>
<span class="cm"> * afterwards.)  */</span>

<span class="cm">/* It's now just a matter of parsing the JSON now. */</span>
<span class="k">struct</span> <span class="n">values</span> <span class="n">values</span><span class="p">;</span>
<span class="kt">int32_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">json_parse</span><span class="p">(</span><span class="n">serialized</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">serialized</span><span class="p">),</span>
    <span class="n">values_descr</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">values_descr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">);</span>

<span class="cm">/* Bits 0, 1, and 2 of ret will be set if some_string,</span>
<span class="cm"> * some_int, and some_bool have been successfully</span>
<span class="cm"> * deserialized.  */</span>
</pre></div>
</div>
<p>Another thing that could be done – but that has not been implemented yet,
is to do the opposite as well: the descriptor and a struct to produce
JSON-encoded data.  This has many advantages over the usual JSON libraries
that require generating a JSON tree in memory just to serialize it
afterwards.</p>
<p>And although I’m quite happy with this code, there are still some
limitations that I’ll address whenever I have the need.</p>
<p>Mainly, there’s no way to parse nested objects or arrays.  I’ve written code
to do this but these changes haven’t gotten any fuzz-testing action so I’m
holding them off it until my living room heater^Wcomputer has worked on the
problem for at least a week.</p>
<p>Another one that’s not a deal breaker for an embedded OS is the lack of
floating pointing numbers (only integers for now).  Parsing floating point
is <a class="reference external" href="http://www.netlib.org/fp/dtoa.c">trickier than it sounds</a>, and
there’s no <code class="docutils literal notranslate"><span class="pre">strtod()</span></code> in Zephyr’s minimal libc.</p>
<p>As a minor issue to work around, there’s the return value: this limits the
number of fields to be parsed to 32; that should be plenty for most uses.
However, in the unlikely event that’s not sufficient, this can be worked
around by having multiple descriptors.</p>
<p>And, finally, there’s the JSON encoding part that I’ve mentioned already.</p>
<p>The major problem with this piece of code, that can’t be fixed by writing
more code, is that I can’t use it with Lwan due to licensing reasons:
although it is open source, part of the <a class="reference external" href="http://www.zephyrproject.org">Zephyr project</a>, it is licensed under the Apache 2
license, which is incompatible with the GPL2+ used by Lwan (would have to
bump it to [L]GPL3).</p>
<p>(For those that might ask how fast is it: it’s fast enough. I didn’t
measure, I didn’t compare, and I don’t really care: it’s readable,
maintainable, and does the job.)</p>
]]></description>
             <pubDate>Wed, 01 Mar 2017 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2016/11/08/infect_to_protect.html</link>
            <guid>http://tia.mat.br/blog/html/2016/11/08/infect_to_protect.html</guid>
            <title><![CDATA[Infect to Protect]]></title>
            <description><![CDATA[<h1>Infect to Protect</h1>
<div class="section" id="bandwagons">
<h2>Bandwagons</h2>
<p>I’m not one to jump on each and every bandwagon I see. Sometimes that’s a
good decision, sometimes it’s better to just wait and see where they go
before taking any action.</p>
<p>Containers are one of those ideas that, while promising and intriguing, were
quite clumsy in the beginning, so I ignored them for a good while.  It’s
sufficiently mature now; so much so that’s quite difficult to ignore them.
Time to investigate them again.</p>
<p>Now, most of my work revolve around writing embedded software that runs on
bare metal; containers don’t really solve any work-related problem I have.
For personal usage, package management is more than sufficient to install
programs.  However, the sandbox aspect of containers are quite interesting
and it’s something I’d like to know more about.</p>
<p>There are many articles around the web explaining how containers on Linux
work.  Some get out of their way to explain in depth all the machinery
necessary to make them work, so there’s no need to repeat it here.</p>
<p>But, in sum: almost all of the <a class="reference external" href="http://jvns.ca/blog/2016/10/10/what-even-is-a-container/">kernel side of things was already present</a> before
containers were actually a thing: cgroups, system call filters, etc.
Containers (and their runtimes) only make them so simple to use it’s
transparent for the user.</p>
<p>I usually have a hard time understanding things that I cannot build, so I
decided to build a toy container runtime.  It’s crude and it’s a far cry
from what any industrial-strength container runtime is capable of, but it’s
not only a start, it’s implemented in a way that makes things a
<em>lot</em> easier for the user.</p>
</div>
<div class="section" id="virulent-tutorials">
<h2>Virulent tutorials</h2>
<p>Before I go into details on how my contraption works, a little bit of
background. I’ve been using Linux for over 18 years, and began my forays
in C about 14 years ago.</p>
<p>Around that time, a pretty interesting HOWTO explaining <a class="reference external" href="http://virus.enemy.org/virus-writing-HOWTO/_html/">how to create
viruses for ELF binaries</a> came out.  It
explained not only various methods of infecting an ELF executable, but also
methods to detect them.  Suffice to say, I couldn’t understand a thing back
then.  A few months ago, though, a conversation in the <a class="reference external" href="https://lhc.net.br">local hackerspace</a> brought up that tutorial; I could now finally
not only understand the techniques but put them to use.</p>
<p>One of the techniques explained in the HOWTO involves finding some
unused space in an ELF segment that’s also executable, writing shellcode
to that area, rewiring the executable’s entry point to point to the shell
code, and modifying the shell code so that it points to the original entry
point. It’s all quite Rube Goldberg-ey, but it’s actually quite simple.</p>
<p>This way, a chunk of code can be executed every time that program
starts, without altering the size of the program. The perfect crime.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="http://tia.mat.br/blog/html/2016/11/08/https://media.giphy.com/media/oX13doUEAPtIY/giphy.gif"><img alt="Perfect crime" src="https://media.giphy.com/media/oX13doUEAPtIY/giphy.gif" style="width: 50%;"/></a>
</div>
</div>
<div class="section" id="dual-use-technology">
<h2>Dual use technology</h2>
<p>By now, you’ve most likely connected the dots: the idea is to use the
very same technique, originally designed for viruses, to create a program that
transforms any program into a sandboxed version of itself.</p>
<p>The prototype I wrote is very elementary; the only thing it does is
limiting, just once, which system calls a program can execute.</p>
<p>Sort of a less-powerful version of <a class="reference external" href="http://man.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man2/pledge.2">OpenBSD’s
pledge(2)</a>
(née <code class="docutils literal notranslate"><span class="pre">tame(2)</span></code>), which can be repeatedly called to reduce the amount of
privileges a process has. Useful, for instance, in cases where a
configuration file has to be read before processing user-supplied work.
That BSD version has <a class="reference external" href="https://www.openbsd.org/papers/hackfest2015-pledge/mgp00001.html">been sprinkling calls to
pledge()</a>
in almost all of the programs in the base install (which is easier for a
BSD system, since everything is kept under the same roof.)</p>
<p>But, unlike <code class="docutils literal notranslate"><span class="pre">pledge(2)</span></code>, this thing can be applied to binaries that have
been already built. No source code modifications are necessary. If your
distribution can withstand the stench, “infected” binaries could be a
thing in the default installation.</p>
</div>
<div class="section" id="filtering-the-system-calls">
<h2>Filtering the system calls</h2>
<p>Any respectable container runtime will perform a lot of tasks to sandbox
a process and their children. So, for a proof of concept, I decided to
do just the bare minimum: limit system calls using Seccomp-BPF.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Seccomp">Seccomp</a> is a set of features
present in the Linux kernel, since the 2.6.x days, that allows
restricting what a program can do, system call-wise. The original intent
was to do not permit any other system calls excepting those to end the
program, and read and write to already-opened file descriptors. In some
scenarios, this is perfectly acceptable. For others, there’s the
seccomp-BPF extension.</p>
<p>BPF stands for <a class="reference external" href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">Berkeley Packet
Filter</a>. A
famous use of BPFs is in the tcpdump program, where rules such as “only
give me back TCP fragments with the RST flag set” can be passed to the
kernel; packets that don’t match the filter are not copied back to the
userland, reducing a lot of the chatter between the two lands.</p>
<p>Obviously, this must be extremely performant, since kernel time must be
conserved at all costs (the kernel is there only to serve userland, after
all).  Linux has many ways to speed up BPF programs, including an in-kernel
JIT compiler.  Some restrictions are in place that wouldn’t allow BPF
programs to take an infinite amount of time to execute, and this <a class="reference external" href="https://blog.cloudflare.com/bpf-the-forgotten-bytecode/">blog post</a> is a good
introductory reading material on the subject.</p>
<p>Another, slightly less famous use of BPFs is with the seccomp-BPF
extension. Instead of filtering network packets, processes can, for
instance, pick which system calls they’re allowed to perform. And that’s
precisely what’s necessary for my proof of concept.</p>
</div>
<div class="section" id="scripting-like-a-kid">
<h2>Scripting like a kid</h2>
<p>There are many ways to skin a cat. I decided to take a look how other
programs were doing their sandboxes, and eventually <a class="reference external" href="https://github.com/brynet/file/commit/612a76f47d879d8c7cc5791b49a3704b54391e05">found one that
seemed easy
enough</a>
to copy the technique from.</p>
<p>Unfortunately, writing shellcodes in C isn’t that easy, specially if you
don’t know which C library a program was linked with (or if it were
linked to a C library in the first place). Luckily, all the shellcode
has to do is make two system calls, which is straightforward to do with
a little bit of assembly.</p>
<p>The first call will forbid the process from getting more privileges. The
second call will actually copy the BPF program to the kernel side.</p>
<p>The first call is painless: just set a few registers, invoke the syscall,
done.</p>
<p>The other one takes a little bit more work. A few things helped: I’ve
used <a class="reference external" href="http://www.nasm.us/">nasm</a>, which is a <a class="reference external" href="https://en.wikipedia.org/wiki/Assembly_language#Macros">macro
assembler</a>,
and wrote a few macros that let me write BPF programs as if they were
standard x86-64 instructions.</p>
<p>The remaining issue is that a pointer to the BPF program must be passed
to the call to <code class="docutils literal notranslate"><span class="pre">prctl()</span></code>, and the shellcode must be relocatable. A <a class="reference external" href="http://stackoverflow.com/a/15704848">common
trick</a> to perform in these
scenarios is to employ the fact that, on x86, when a call instruction is
made, the return address (i.e. the address of the byte right after the
call instruction) is pushed to the stack:</p>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span/>    <span class="c1">; …</span>
    <span class="nf">jmp</span> <span class="nv">push_bpf_addr</span>
<span class="nl">apply_filter:</span>
    <span class="nf">pop</span> <span class="nb">rdx</span>     <span class="c1">; rdx points to the BPF program</span>
    <span class="c1">; …</span>
<span class="nl">push_bpf_adr:</span>
    <span class="nf">call</span> <span class="nv">apply_filter</span>
<span class="nl">bpf:</span>
    <span class="nf">bpf_stmt</span> <span class="c1">; …</span>
    <span class="nf">bpf_jump</span> <span class="c1">; …</span>
    <span class="nf">sc_allow</span> <span class="c1">; …</span>
    <span class="c1">; …</span>
<span class="nl">bpf_end:</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">bpf</span></code> label doesn’t point to any x86 instruction: it contains only
macros that expands to the definitions of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock_filter</span></code> as defined
in <code class="docutils literal notranslate"><span class="pre">linux/filter.h</span></code>.  To copy the BPF program to the kernel, the <cite>prctl()</cite>
call expects a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock_fprog</span></code>, which contains the BPF program length
(in number of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock_filter</span></code> elements), and a pointer to the base of
that array.  Since there’s no way to know where this code is gong to land in
memory beforehand, this trick comes in handy: after the <code class="docutils literal notranslate"><span class="pre">call</span>
<span class="pre">apply_filter</span></code> instruction, the top of the stack now contains the base
address of that array.</p>
<p>Now that I had a way to write the shellcode, it was just the matter of
shoehorning it into the executable.</p>
<div class="figure align-center">
<img alt="Hacking time" src="https://media.giphy.com/media/l46C6sdSa5DVSJnLG/giphy.gif"/>
</div>
</div>
<div class="section" id="scoring-a-goal">
<h2>Scoring a goal</h2>
<p>For the proof of concept, I was initially going to write the infection
program in Python, as I usually do for throwaway code.  However, I wasn’t
successful in finding a working ELF library that would let me dump the
modified executable.</p>
<p>I was too lazy to actually fix or write support for that, so I kept
looking for alternatives and ended up finding the
<a class="reference external" href="http://www.muppetlabs.com/~breadbox/software/elfkickers.html">ELFkickers</a>
suite from the always excellent Muppet Labs. It includes an “infect”
program that does exactly what says in the tin: it takes in an
executable file, and produces another executable file that creates a
setuid shell before continuing to the original program. Exactly what one
would expect from a program with nefarious purposes.</p>
<p>So I substituted the original shellcode for the one I’ve just assembled, and
now I had a proof of concept.  Which of course didn’t work the first few
tries.  In fact, it took a long while to get it right.</p>
</div>
<div class="section" id="debugging-the-contraption-with-gdb">
<h2>Debugging the contraption with gdb</h2>
<p>The GNU Debugger is indeed very powerful, but ease of use (compared to
the Turbo Debugger I used to use in the DOS days) is not it’s strong
suit. I’m not used to using it to debug programs without access to
source, and this was a good opportunity to learn a few things.</p>
<p>Since the infection program modifies the ELF entry point, setting a
breakpoint on <code class="docutils literal notranslate"><span class="pre">main()</span></code> won’t actually work. But this is easily solvable:
just use <a class="reference external" href="https://linux.die.net/man/1/readelf">readelf(1)</a> to find
where the new entry point is, and set a breakpoint to that:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span/><span class="gp">$</span> gcc -o hello hello.c
<span class="gp">$</span> readelf -h hello <span class="p">|</span> grep Entry
<span class="go">  Entry point address: 0x400490</span>
<span class="gp">$</span> ./infect hello
<span class="gp">$</span> readelf -h hello <span class="p">|</span> grep Entry
<span class="go">  Entry point address: 0x4007bc</span>
<span class="gp">$</span> gdb ./hello
<span class="go">…</span>
<span class="go">(gdb) break *0x4007bc</span>
<span class="go">Breakpoint 1 at 0x4007bc</span>
</pre></div>
</div>
<p>From now on, it’s just the usual
execute-inspect-modify-reassemble-reinfect loop until it works. Although
it’s no <a class="reference external" href="https://www.youtube.com/watch?v=-ueCuJXF6po">td</a>, I’m
certainly glad GDB has layouts that displays both the <a class="reference external" href="https://reverseengineering.stackexchange.com/questions/1935/how-to-handle-stripped-binaries-with-gdb-no-source-no-symbols-and-gdb-only-sho">disassembly and
the
registers</a>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="http://tia.mat.br/blog/html/2016/11/08/https://data.photofunky.net/output/image/f/b/5/0/fb50ca/photofunky.gif"><img alt="Step-by-step debugging" src="https://data.photofunky.net/output/image/f/b/5/0/fb50ca/photofunky.gif" style="width: 50%;"/></a>
</div>
</div>
<div class="section" id="watching-the-magic-happen">
<h2>Watching the magic happen</h2>
<p>The <code class="docutils literal notranslate"><span class="pre">hello</span></code> program is very short and the call to <code class="docutils literal notranslate"><span class="pre">socket(2)</span></code> doesn’t
make much sense there.  It’s just a way to test what’s going to happen when
the filter is in place, without the need to modify the program to test this
assumption.  (<a class="reference external" href="https://www.bsdcan.org/2016/schedule/attachments/357_20160610-bsdcan-helloworld.pdf">Lots of things</a>
happens when executing a simple program such as this.)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp"/>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"no socket created</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"created socket, fd=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Executing the program before infecting it gives the following output, as
expected:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>$ ./hello
no socket created
$ ./hello 1
created socket, fd = 3
</pre></div>
</div>
<p>Indeed, if the program is executed under strace, it all goes exactly
like it’s supposed to be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>$ strace ./hello
execve("./hello", ["./hello"], [/* 58 vars */]) = 0
…
write(1, "no socket created\n", 18no socket created
)     = 18
exit_group(0)                           = ?
+++ exited with 0 +++
</pre></div>
</div>
<p>And, with a command-line argument, so the socket is created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>…
socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
…
write(1, "created socket, fd = 3\n", 23created socket, fd = 3
) = 23
exit_group(0)                           = ?
+++ exited with 0 +++
</pre></div>
</div>
<p>However, the magic happens after the “infected” binary is executed.
First, without creating a socket:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>…
prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)  = 0
prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, {len=30, filter=0x400824}) = 0
…
write(1, "no socket created\n", 18no socket created
)     = 18
exit_group(0)                           = ?
+++ exited with 0 +++
</pre></div>
</div>
<p>Notice the calls to <code class="docutils literal notranslate"><span class="pre">prctl()</span></code>, very similar to the ones found in the
previously-mentioned commit. And then the program executes as usual.
Now, if an argument is passed, the program will attempt to create a
socket:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>…
prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)  = 0
prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, {len=30, filter=0x400824}) = 0
socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 41
--- SIGSYS {si_signo=SIGSYS, si_code=SYS_SECCOMP, si_call_addr=0x7f2d01aa19e7, si_syscall=__NR_socket, si_arch=AUDIT_ARCH_X86_64} ---
+++ killed by SIGSYS (core dumped) +++
[1]    27536 invalid system call (core dumped)  strace ./hello 1
</pre></div>
</div>
<p>And Seccomp kicks in and kills the program with a <code class="docutils literal notranslate"><span class="pre">SIGSYS</span></code> signal. As
expected. <strong>It’s alive!</strong></p>
<div class="figure align-center">
<img alt="It's alive!" src="https://i.imgur.com/sWwquxp.jpg"/>
</div>
</div>
<div class="section" id="next-steps">
<h2>Next steps</h2>
<p>The prototype works. But there are a few things that must be considered
before even considering this idea for anything.</p>
<div class="section" id="system-call-whitelist">
<h3>System call whitelist</h3>
<p>The list of system calls is still hardcoded within the shellcode. That’s
not optimal. Maintaining a list such as this for each and every program
will most likely be so boring nobody is going to do that.</p>
<p>I can think of three possible ways of coming up with this list.</p>
<p>The first would be doing the same thing <code class="docutils literal notranslate"><span class="pre">pledge(2)</span></code> does: allowing a very
restrict set of system calls at first, with some limitations, and then
providing a few sets of calls per set of features a program might use: stdio,
inet, tty, etc.  The nice thing about this is that the filters are more fine
grained; it’s not just a whitelist of system calls.  (The <a class="reference external" href="http://man.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man2/pledge.2">man page</a> has
more details.)</p>
<p>The second way would involve running the program under <code class="docutils literal notranslate"><span class="pre">strace(1)</span></code> and
record which system calls the program makes from a few runs.  If the test
coverage for each run is sufficiently high, this will work very reliably;
this isn’t always the case, so the mileage may vary.  Also, for certain
large, complicated programs, stracing it all automatically could prove to be
a challenge.</p>
<p>Another way would be the following: Grab a list of undefined symbols a
program uses, and find them in the shared libraries it links to.  Then scan
the executable and the libraries for sequences like <code class="docutils literal notranslate"><span class="pre">mov</span> <span class="pre">eax,</span> <span class="pre">57;</span> <span class="pre">syscall</span></code>
(for the oldschool <code class="docutils literal notranslate"><span class="pre">fork(2)</span></code> syscall on x86-64) or <code class="docutils literal notranslate"><span class="pre">mov</span> <span class="pre">rdi,</span> <span class="pre">57;</span> <span class="pre">call</span>
<span class="pre">syscall@plt</span></code>.  This is still not foolproof, since not necessarily a system
call number (loaded into <code class="docutils literal notranslate"><span class="pre">eax</span></code>) will be hardcoded within a program or
shared library.</p>
<p>There’s a fourth idea, as well, which involves both doing the automated
static analysis on the binary and running strace to catch “runaway”
syscalls. This can get quite complicated and it’s unlikely I’ll get it
correct in the first few tries (and, yet, the same shortcomings will
apply in the end.)</p>
<p>For me, though, these experiments are all about the hunt, not about the
treasure. So the tried and true approach that <code class="docutils literal notranslate"><span class="pre">pledge(2)</span></code> uses won’t be
used at first.</p>
</div>
<div class="section" id="filter-optimization">
<h3>Filter optimization</h3>
<p>Another thing that might be a problem is: on x86-64, Linux has hundreds of
system calls.  (329 according to <code class="docutils literal notranslate"><span class="pre">sys/syscall.h</span></code> at the moment I write
this.)</p>
<p>Even if the JIT for BPFs is quite efficient, doing a linear search before each
and every system call will certainly be a bottleneck.  Also, BPF programs are
limited in size, and a large whitelist that’s implemented the same way as the
prototype will limit the possibility for more fine-grained filters.  Things
like “the <code class="docutils literal notranslate"><span class="pre">socket(2)</span></code> call is allowed only for UNIX-domain sockets”, rather than
allowing whatever call to <code class="docutils literal notranslate"><span class="pre">socket(2)</span></code> would be impractical.</p>
<p>Since each syscall is identified by a number, a simple bitmap could be
used to implement the whitelist. This will also free up some space in
the BPF program for more detailed whitelisting for certain syscalls (for
instance, only allowing certain family of sockets to be created).</p>
<p>After a quick read of
<a class="reference external" href="https://www.kernel.org/doc/Documentation/networking/filter.txt">networking/filter.txt</a>,
this seems doable by using an algorithm such as this, which will reduce
the number of comparisons as the number of acceptable system calls
increases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>        if syscall_number &lt; 32:
                if bitmask_0 &amp; 1&lt;&lt;syscall_number: goto accept
        if syscall_number &lt; 64:
                syscall_number -= 32
                if bitmask_1 &amp; 1&lt;&lt;syscall_number: goto accept
        if syscall_number &lt; 96:
                syscall_number -= 64
                if bitmask_2 &amp; 1&lt;&lt;syscall_number: goto accept
        …
        if syscall_number &lt; 352:
                syscall_number -= 320
                if bitmask_10 &amp; 1&lt;&lt;syscall_number: goto accept
        return SECCOMP_RET_KILL
accept:
        return SECCOMP_RET_ACCEPT
</pre></div>
</div>
<p>(Some of the <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">syscall_number</span> <span class="pre">&lt;</span> <span class="pre">N</span></code> blocks could be changed to
<code class="docutils literal notranslate"><span class="pre">syscall_number</span> <span class="pre">-=</span> <span class="pre">M</span></code> if their respective bitmask is <code class="docutils literal notranslate"><span class="pre">0</span></code>.)</p>
<p>Or maybe just a bloom filter instead of a series of bitmaps. I’ll have
to experiment.</p>
</div>
<div class="section" id="getting-a-larger-vessel">
<h3>Getting a larger vessel</h3>
<p>Containers, of course, are not just about restricting which system calls a
program is allowed to perform.  There are many things that can and must be
considered before even calling this a container runtime, or really consider
that this is in fact sandboxing anything.  Learning about namespaces,
cgroups and virtual machines are certainly on the list of things to learn
about.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>While the prototype I built isn’t practical and is of very limited use,
I find the idea of sandboxed programs without the need for specialized
runtimes very enticing.</p>
<p>Programs can be still packaged the way they have been packaged in the
past decades, without throwing away some of the sandboxing benefits that
containers provide, all the while not introducing new concepts for
users.</p>
<p>Of course, something like this – even if properly implemented – won’t
be a replacement for containers. Specially if one considers their role
as packets ready for deployment, which have a lot of value for devops
personnel.</p>
<p>The code, as usual, is open source, and available from <a class="reference external" href="https://github.com/lpereira/infect-to-protect">this Git
repository</a>.</p>
</div>
]]></description>
             <pubDate>Tue, 08 Nov 2016 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2015/05/01/initializing_a_heap_allocated_structure_in_c.html</link>
            <guid>http://tia.mat.br/blog/html/2015/05/01/initializing_a_heap_allocated_structure_in_c.html</guid>
            <title><![CDATA[Initializing a heap-allocated structure in C]]></title>
            <description><![CDATA[<h1>Initializing a heap-allocated structure in C</h1>
<p>A pretty common mistake that happens when programming things in C is to
allocate less memory than necessary to hold a structure:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">foobar</span> <span class="o">*</span><span class="n">foobar</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foobaz</span><span class="p">));</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">foobaz</span></code> is passed instead of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">foobar</span></code>. We might get
lucky, and <code class="docutils literal notranslate"><span class="pre">sizeof(struct</span> <span class="pre">foobaz)</span></code> might be larger or equal than
<code class="docutils literal notranslate"><span class="pre">sizeof(struct</span> <span class="pre">foobar)</span></code>, but we might not.</p>
<p>There are lots of tools out there that will catch these mistakes: static
analyzers such as the one from Clang, and Memcheck from Valgrind are just
two examples that should be in any C programmer’s toolbelt.</p>
<p>Even then, people often resort to a a nicer idiom: <code class="docutils literal notranslate"><span class="pre">sizeof(*foobar)</span></code>,
which not only avoids these problems, but also is somewhat future-proof,
should the type of <code class="docutils literal notranslate"><span class="pre">foobar</span></code> change:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">foobar</span> <span class="o">*</span><span class="n">foobar</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">foobar</span><span class="p">));</span>
</pre></div>
</div>
<p>However, structures often have members that, if someone forgets to
initialize, will inflict some undefined behavior pains on the user.  The
things in the toolbelt might help here, as well as the <code class="docutils literal notranslate"><span class="pre">calloc()</span></code>
function, that, in addition to allocating memory, also zero-out the memory
block:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">foobar</span> <span class="o">*</span><span class="n">foobar</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">foobar</span><span class="p">));</span>
</pre></div>
</div>
<p>Not always one would want to zero out the whole memory chunk just to fill
out important fields afterwards, though.</p>
<p>Here’s a trick that’s being used in a yet-to-be-released project I’ve been
working on and off for the past few months. It starts by defining the
generic-chunk-of-memory equivalent of <code class="docutils literal notranslate"><span class="pre">strdup()</span></code>, <code class="docutils literal notranslate"><span class="pre">memdup()</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="o">*</span><span class="nf">memdup</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">mem</span> <span class="o">?</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then a macro is defined:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cp">#define ALLOC_INIT(type, ...)   \</span>
<span class="cp">        (type *)memdup((type[]){ __VA_ARGS__ }, sizeof(type))</span>
</pre></div>
</div>
<p>Then it is used like so:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">foobar</span> <span class="o">*</span><span class="n">foobar</span> <span class="o">=</span> <span class="n">ALLOC_INIT</span><span class="p">(</span><span class="k">struct</span> <span class="n">foobar</span><span class="p">,</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span>
        <span class="p">.</span><span class="n">other_field</span> <span class="o">=</span> <span class="n">other_value</span><span class="p">,</span>
        <span class="p">.</span><span class="n">yet_another_field</span> <span class="o">=</span> <span class="n">yet_another_value</span>
<span class="p">});</span>
</pre></div>
</div>
<p>The compiler will check if <code class="docutils literal notranslate"><span class="pre">field</span></code>, <code class="docutils literal notranslate"><span class="pre">other_field</span></code>, and <code class="docutils literal notranslate"><span class="pre">yet_another_field</span></code>
are actually part of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">foobar</span></code>, and will abort compilation of a field
isn’t there or is of the wrong type.</p>
<p>The cast prevents the allocated memory block from being assigned to the wrong
type. (C will happily cast any <code class="docutils literal notranslate"><span class="pre">void*</span></code> to any other pointer.)</p>
<p>The amount of memory allocated will be exactly what’s needed by the
structure, and all fields that not mentioned will be initialized with their
default values as per <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">designated initializer rules</a>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">memdup()</span></code> is inlined, a good compiler will generate pretty good code,
that’s often byte-by-byte equivalent to allocating directly with
<code class="docutils literal notranslate"><span class="pre">malloc()</span></code>, initializing all the fields by hand, etc.</p>
<p>If GCC is being used, the <code class="docutils literal notranslate"><span class="pre">__auto_type</span></code> <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Typeof.html">extension</a> can be used, to avoid
having to type <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">foobar</span></code> twice. This has been suggested by <a class="reference external" href="https://plus.google.com/117917253135468806554/posts/DcBUyuicdLW">Thiago
Macieira</a>. I’d use this sparingly, though.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">__auto_type</span> <span class="n">foobar</span> <span class="o">=</span> <span class="n">ALLOC_INIT</span><span class="p">(</span><span class="k">struct</span> <span class="n">foobar</span><span class="p">,</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span>
        <span class="p">.</span><span class="n">other_field</span> <span class="o">=</span> <span class="n">other_value</span><span class="p">,</span>
        <span class="p">.</span><span class="n">yet_another_field</span> <span class="o">=</span> <span class="n">yet_another_value</span>
<span class="p">});</span>
</pre></div>
</div>
<p>It’s a pretty nice idiom that I haven’t seen anywhere else, and I’m blogging
here as the project I’m working on might not ever see the light of day and
it would be a shame if at least this didn’t become public.</p>
]]></description>
             <pubDate>Fri, 01 May 2015 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2014/11/02/hybrid_c_pascal_strings.html</link>
            <guid>http://tia.mat.br/blog/html/2014/11/02/hybrid_c_pascal_strings.html</guid>
            <title><![CDATA[Hybrid C/Pascal Strings]]></title>
            <description><![CDATA[<h1>Hybrid C/Pascal Strings</h1>
<p>I’ve been thinking for a while on how to reduce the overhead in <a class="reference external" href="http://lwan.ws">Lwan</a>’s
string buffer, when the strings are small. There are a number of
ways of accomplishing this.</p>
<p>A somewhat common way is what <code class="docutils literal notranslate"><span class="pre">std::string</span></code> does: it reuses the bits
reserved for <cite>effective string length</cite>, <cite>allocated buffer size</cite>, and
<cite>pointer to buffer</cite> to store the string contents inline.</p>
<p>A <a class="reference external" href="http://tulrich.com/rants-2009.html#d2009-01-03T00:00:00Z">clever improvement</a> is, when the string is small, to turn the
<cite>effective string length</cite> counter to a <cite>bytes remaining counter</cite>, and
put it after the buffer that’s storing the string; this way, when the
string is at full capacity, this serves as a <code class="docutils literal notranslate"><span class="pre">\0</span></code> terminator, which
is very useful for compatibility with C.  And, of course, as a result,
one more byte can be stored in that string.</p>
<p>Another common approach are the strings used in <a class="reference external" href="https://en.wikipedia.org/wiki/String_(computer_science)#Length-prefixed">Pascal</a>, where the first
byte tells the length of the string. This has the advantage of allowing
strings to contain <code class="docutils literal notranslate"><span class="pre">\0</span></code>, but the disadvantage of limiting the maximum
size of the string. If someone were to implement this in C, the
advantage would turn into a disadvantage, as most string-handling
routines present in the standard library would be then rendered useless.</p>
<p>Or would it?</p>
<p>I’m sure I’m not the first person to come up with the idea of having a
C/Pascal String hybrid.  But at least the <a class="reference external" href="https://en.wikipedia.org/wiki/String_(computer_science)">Wikipedia</a> article on
Strings doesn’t seem to mention this variant I just came up with:</p>
<ul class="simple">
<li><p>Keep the <code class="docutils literal notranslate"><span class="pre">\0</span></code> to terminate the string. This helps reusing the
string handling routines from the C standard library, which are usually
very fast, hand-tuned functions</p></li>
<li><p>The first byte tells the size, not in bytes, but in 8-byte blocks.
To calculate the string length, one just jumps that amount of 8-byte
blocks and find the position of the <code class="docutils literal notranslate"><span class="pre">\0</span></code> terminator.</p></li>
<li><p>Larger blocks could be considered if <a class="reference external" href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> instructions were available.</p></li>
</ul>
<p>With 8-byte blocks, this can yield strings up to 2KiB of size (256 *
8), with an overhead of only two bytes, while retaining compatibility
with C strings.  With SIMD, the maximum string size could be easily
doubled or quadrupled.</p>
<p>Of course, this isn’t actually an improvement on the kind of small
string optimization performed by <code class="docutils literal notranslate"><span class="pre">std::string</span></code>, so I’m not yet
convinced this is the way to go. This is one of the reasons I haven’t
yet implemented this, but I might use the fact that I’m currently
enjoying some vacation time and write a prototype.</p>
]]></description>
             <pubDate>Sun, 02 Nov 2014 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2014/10/06/life_of_a_http_request.html</link>
            <guid>http://tia.mat.br/blog/html/2014/10/06/life_of_a_http_request.html</guid>
            <title><![CDATA[Life of a HTTP request, as seen by my toy web server]]></title>
            <description><![CDATA[<h1>Life of a HTTP request, as seen by my toy web server</h1>
<p>When learning a new programming language, I tend to write two things with
it: a language interpreter (usually a FORTH-like language or Brainfuck if
I’m feeling lazy), and a HTTP server.  Sometimes, just as a challenge or a
way to quench my boredom, I do this even though I’ve been working with a
particular language for some time, as is the case with C.</p>
<p>None of these projects I’ve written over the years have been as complex as
<a class="reference external" href="http://lwan.ws">Lwan</a> ended up being: most of them were nothing but weekend hacks and were
never able to hold my attention for more than a few dozen hours.</p>
<p>It’s to be expected, then, that I might have a thing or two to say about it.
In fact, I’ve been <a class="reference external" href="http://tia.mat.br/blog/html/tags/lwan.html">doing this in homeopathic doses</a> over the almost two years
since I’ve started the project.  Never actually connected all the dots,
leaving out important details.</p>
<p>This article is an attempt to describe, from the perspective of Lwan, the
life of a HTTP request — from the socket being accepted to the response
being sent — and explaining details and reasoning behind the implementation.</p>
<div class="section" id="creating-the-listening-socket-accepting-connections">
<h2>Creating the listening socket &amp; accepting connections</h2>
<p>There’s nothing really special here: sockets are either created using the
<a class="reference external" href="http://linux.die.net/man/2/socket">standard POSIX stuff</a>, or are passed down from <a class="reference external" href="http://0pointer.net/blog/projects/socket-activation.html">systemd</a>.  In either case, TCP
<a class="reference external" href="http://lwn.net/Articles/508865/">Fastopen</a> and <a class="reference external" href="http://linux.die.net/man/7/tcp#TCP_QUICKACK">Quickack</a> are enabled, in addition to socket lingering.  The
socket is left in its default, blocking mode. The <a class="reference external" href="http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/023/2333/2333s2.html">listen() backlog</a> is the
maximum allowed by the system.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">int</span>
<span class="nf">_get_backlog_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef SOMAXCONN</span>
    <span class="kt">int</span> <span class="n">backlog</span> <span class="o">=</span> <span class="n">SOMAXCONN</span><span class="p">;</span>
<span class="cp">#else</span>
    <span class="kt">int</span> <span class="n">backlog</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">somaxconn</span><span class="p">;</span>

    <span class="n">somaxconn</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"/proc/sys/net/core/somaxconn"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">somaxconn</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fscanf</span><span class="p">(</span><span class="n">somaxconn</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">backlog</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">fclose</span><span class="p">(</span><span class="n">somaxconn</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">backlog</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It’s a blocking file descriptor since the main thread (responsible for
accepting all the sockets and scheduling clients) blocks on a call to
<a class="reference external" href="http://linux.die.net/man/2/accept4">accept4()</a> instead of something like <a class="reference external" href="http://linux.die.net/man/4/epoll">Epoll</a>.  This <a class="reference external" href="http://linux.die.net/man/2/accept">accept()</a> variant is
Linux-only and, among other things, lets one specify flags in sockets
without requiring an additional round trip to the kernel; the only flag that
interests Lwan is <code class="docutils literal notranslate"><span class="pre">SOCK_NONBLOCK</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">void</span>
<span class="nf">lwan_main_loop</span><span class="p">(</span><span class="n">lwan_t</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">setjmp</span><span class="p">(</span><span class="n">cleanup_jmp_buf</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">_signal_handler</span><span class="p">);</span>

    <span class="n">lwan_status_info</span><span class="p">(</span><span class="s">"Ready to serve"</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">client_fd</span> <span class="o">=</span> <span class="n">accept4</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">main_socket</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                                <span class="n">SOCK_NONBLOCK</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">client_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">lwan_status_perror</span><span class="p">(</span><span class="s">"accept"</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">_schedule_client</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">client_fd</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>File descriptor limits are raised to the <a class="reference external" href="https://github.com/lpereira/lwan/blob/e660ab753bfc83eb428c5b7de98bd40341589614/common/lwan.c#L415-L432">maximum allowed by system
settings</a> — at which time, Lwan pre-allocates an array of structures to hold
connection state for all possible file descriptors.</p>
</div>
<div class="section" id="scheduling-connection">
<h2>Scheduling connection</h2>
<p>In order to multiplex connections, Lwan spawns one thread per logical CPU,
and uses Epoll to determine which socket is ready to be written to or read
from.  Once a connection is scheduled to one of these threads, it stays
there until it is explicitly closed or a timeout occurs.</p>
<p>All threads share the preallocated connection array, and there are no
explicit locks.  The index to this array is the connection file descriptor,
which makes lookup very quick. This exploits the notion that file
descriptors are always allocated from the lowest possible number.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">lwan_connection_t_</span> <span class="p">{</span>
    <span class="cm">/* This structure is exactly 32-bytes on x86-64. If it is</span>
<span class="cm">     * changed, make sure the scheduler (lwan.c) is updated as</span>
<span class="cm">     * well. */</span>
    <span class="n">lwan_connection_flags_t</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time_to_die</span><span class="p">;</span> <span class="cm">/* In seconds since DQ epoch */</span>
    <span class="n">coro_t</span> <span class="o">*</span><span class="n">coro</span><span class="p">;</span>
    <span class="n">lwan_thread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>           <span class="cm">/* For death queue */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Since this structure is quite small, this leads to a form of implicit
lock called <a class="reference external" href="https://en.wikipedia.org/wiki/False_sharing">false sharing</a>, which is solved with a scheduler that is
aware of that problem and groups two connection structures per cache
line.  It’s simpler than it sounds:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="kr">thread</span> <span class="o">=</span> <span class="p">((</span><span class="n">fd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_threads</span><span class="p">;</span>
</pre></div>
</div>
<p>A <a class="reference external" href="https://en.wikipedia.org/wiki/Round-robin_scheduling">round robin scheduler</a> is used on other architectures.</p>
<p>An interesting curiosity about the connection structure is that it doesn’t
store the file descriptor: pointer arithmetic is performed to obtain it, as
the the base address for the connection array is known.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">ALWAYS_INLINE</span> <span class="kt">int</span>
<span class="nf">lwan_connection_get_fd</span><span class="p">(</span><span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">ptrdiff_t</span><span class="p">)(</span><span class="n">conn</span> <span class="o">-</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">lwan</span><span class="o">-&gt;</span><span class="n">conns</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After a thread has been chosen by the scheduler, the file descriptor number
is sent to a <a class="reference external" href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix domain socket</a> created with <a class="reference external" href="http://linux.die.net/man/2/socketpair">socketpair()</a> to that particular
thread’s Epoll. This part used to use <a class="reference external" href="http://linux.die.net/man/2/epoll_ctl">epoll_ctl()</a> directly — which, although
threadsafe, had a problem: <a class="reference external" href="http://linux.die.net/man/2/epoll_wait">epoll_wait()</a> will never timeout on a socket if
nothing was read from it previously. By writing to that socketpair, Epoll
awakens, the file descriptor is added to it, and that thread’s death queue
can handle the timeout by itself.</p>
<p>The sole purpose of each thread is to react to Epoll events, such as:</p>
<ul class="simple">
<li><p>Timeouts (in which case the death queue iterates, potentially
terminating connections);</p></li>
<li><p>Epoll errors (in which case the thread finishes gracefully);</p></li>
<li><p>Readiness events (can read, can write);</p></li>
<li><p>Connection hung up.</p></li>
</ul>
<p>Epoll events are used as signals to create, destroy, resume, and reset
coroutines: there’s one for each connection, and they’re used both as
lightweight threads and as resource management facilities.</p>
</div>
<div class="section" id="coroutines">
<h2>Coroutines</h2>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Coroutine">Coroutines</a> provides a reasonably simple model for asynchronous I/O handling
that’s less convoluted than the dreaded <a class="reference external" href="https://developer.gnome.org/gio/stable/">callback idiom</a> prevalent in C. They
also require a lot less stack space than a thread and their creation is
pretty efficient: essentially just a call to <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">coro_t</span> <span class="o">*</span>
<span class="nf">coro_new</span><span class="p">(</span><span class="n">coro_switcher_t</span> <span class="o">*</span><span class="n">switcher</span><span class="p">,</span>
         <span class="n">coro_function_t</span> <span class="n">function</span><span class="p">,</span>
         <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">coro_t</span> <span class="o">*</span><span class="n">coro</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">coro</span><span class="p">)</span> <span class="o">+</span> <span class="n">CORO_STACK_MIN</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">coro</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">coro</span><span class="o">-&gt;</span><span class="n">switcher</span> <span class="o">=</span> <span class="n">switcher</span><span class="p">;</span>
    <span class="n">coro</span><span class="o">-&gt;</span><span class="n">defer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* coro_reset() is just a few assignments on x86-64 */</span>
    <span class="n">coro_reset</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

<span class="cp">#if !defined(NDEBUG) &amp;&amp; defined(USE_VALGRIND)</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">stack</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">coro</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">coro</span><span class="o">-&gt;</span><span class="n">vg_stack_id</span> <span class="o">=</span> <span class="n">VALGRIND_STACK_REGISTER</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span>
                                   <span class="n">stack</span> <span class="o">+</span> <span class="n">CORO_STACK_MIN</span><span class="p">);</span>
<span class="cp">#endif</span>

    <span class="k">return</span> <span class="n">coro</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Request handlers can be written using an API that’s completely synchronous
on the surface but behind the curtains, I/O happens in the background
(client sockets are non-blocking) and control is given to the next coroutine
as commanded by each thread’s loop.</p>
<p>Execution resumes where the coroutine left off. This saves a lot of code,
not only making things easier to reason about, but also simplifying resource
management by having a single cleanup point.</p>
<p>To provide a synchronous-looking API, Lwan provides a few wrappers for
common operations, such as <a class="reference external" href="http://linux.die.net/man/2/writev">writev()</a> or <a class="reference external" href="http://linux.die.net/man/2/sendfile">sendfile()</a>. Unlike the functions
these wrap, they return no error:</p>
<ul class="simple">
<li><p>On success, the same return code is returned;</p></li>
<li><p>Recoverable errors (such as <code class="docutils literal notranslate"><span class="pre">EINTR</span></code>) are handled by trying them again a
few times before giving up;</p></li>
<li><p>When giving up, or on unrecoverable errors, coroutines are aborted.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">int</span>
<span class="nf">lwan_openat</span><span class="p">(</span><span class="n">lwan_request_t</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span>
            <span class="kt">int</span> <span class="n">dirfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">tries</span> <span class="o">=</span> <span class="n">max_failed_tries</span><span class="p">;</span> <span class="n">tries</span><span class="p">;</span> <span class="n">tries</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">openat</span><span class="p">(</span><span class="n">dirfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/*</span>
<span class="cm">             * close() will be called as soon as the</span>
<span class="cm">             * coroutine ends</span>
<span class="cm">             */</span>
            <span class="n">coro_defer</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">coro</span><span class="p">,</span> <span class="n">CORO_DEFER</span><span class="p">(</span><span class="n">close</span><span class="p">),</span>
                       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">intptr_t</span><span class="p">)</span><span class="n">fd</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">EINTR</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">EMFILE</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">ENFILE</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">ENOMEM</span><span class="p">:</span>
            <span class="n">coro_yield</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">coro</span><span class="p">,</span>
                       <span class="n">CONN_CORO_MAY_RESUME</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">errno</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When a coroutine is destroyed, user-defined callbacks are executed. These
include callbacks set by the wrapper functions, to close files, free memory,
and perform many other cleanup tasks. This ensures resources are released
regardless if the coroutine ended normally or an unrecoverable error has
been detected.</p>
<div class="figure align-center" id="id2">
<img alt="coroutines" src="https://i.imgur.com/7sHL2ZH.png"/>
<p class="caption"><span class="caption-text">Diagram of main loop plus two coroutines</span></p>
</div>
<p>On supported architectures, coroutine context switching is almost as cheap
as a function call.  This is possible because hand-written assembly routines
are used, which only performs the essential register exchange, as mandated
by the <a class="reference external" href="http://www.x86-64.org/documentation/abi.pdf">ABI</a>.  There is still some work to do in order to speed up this;
tricks used by <a class="reference external" href="http://byuu.org/programming/libco/">libco</a>, for instance, might be used in the future to reduce
some of the overhead.</p>
<p>On every other architecture, <a class="reference external" href="http://linux.die.net/man/3/swapcontext">swapcontext()</a> is used and this usually incurs
in saving and restoring the signal mask, in addition to swapping every
register (including those not required by the calling convention); this
might change to setjmp() in the future to avoid at least the two system
calls.</p>
<p>Another use for coroutines in Lwan is inside the Mustache templating engine,
described in more depth below.</p>
</div>
<div class="section" id="reading-requests">
<h2>Reading requests</h2>
<p>The loop within each I/O thread is <a class="reference external" href="https://github.com/lpereira/lwan/blob/e660ab753bfc83eb428c5b7de98bd40341589614/common/lwan-thread.c#L278-L342">quite crude</a>.</p>
<p>Essentially, a coroutine will only be resumed for reading once per request:
once it yields, Epoll will only be interested in write events. Because of
this, reading a request uses a purpose-built <a class="reference external" href="https://github.com/lpereira/lwan/blob/e660ab753bfc83eb428c5b7de98bd40341589614/common/lwan-request.c#L459-L514">read() wrapper</a> that tricks the
scheduler to still be interested in read events, unless the request has been
fully received (by ending with the “␍␊␍␊” separator).</p>
<p>As soon as the whole request has been received, it is then parsed and acted
upon.</p>
</div>
<div class="section" id="parsing-request">
<h2>Parsing request</h2>
<p>Request parsing in Lwan is quite efficient: there are no copies, no memory
allocations from the heap.  The buffer is modified in place by slicing and
storing pointers to stuff the server might be interested in.  Parsing of
HTTP request headers is delayed until needed (and they might not be needed).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">lwan_request_parse_t_</span> <span class="p">{</span>
    <span class="n">lwan_value_t</span> <span class="n">buffer</span><span class="p">;</span>            <span class="cm">/* The whole buffer */</span>
    <span class="n">lwan_value_t</span> <span class="n">query_string</span><span class="p">;</span>      <span class="cm">/* Stuff after URLs ? */</span>
    <span class="n">lwan_value_t</span> <span class="n">if_modified_since</span><span class="p">;</span> <span class="cm">/* If-Modified-Since: */</span>
    <span class="n">lwan_value_t</span> <span class="n">range</span><span class="p">;</span>             <span class="cm">/* Range: */</span>
    <span class="n">lwan_value_t</span> <span class="n">accept_encoding</span><span class="p">;</span>   <span class="cm">/* Accept-Encoding: */</span>
    <span class="n">lwan_value_t</span> <span class="n">fragment</span><span class="p">;</span>          <span class="cm">/* Stuff after URLs # */</span>
    <span class="n">lwan_value_t</span> <span class="n">content_length</span><span class="p">;</span>    <span class="cm">/* Content-Length: */</span>
    <span class="n">lwan_value_t</span> <span class="n">post_data</span><span class="p">;</span>         <span class="cm">/* POST data */</span>
    <span class="n">lwan_value_t</span> <span class="n">content_type</span><span class="p">;</span>      <span class="cm">/* Content-Type: */</span>
    <span class="n">lwan_value_t</span> <span class="n">authorization</span><span class="p">;</span>     <span class="cm">/* Authorization: */</span>
    <span class="kt">char</span> <span class="n">connection</span><span class="p">;</span>                <span class="cm">/* k=keep-alive, c=close */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Among other things, one that often receives comments is how headers are
parsed.  Two tricks are involved: avoiding <a class="reference external" href="https://en.wikipedia.org/wiki/Register_allocation#Spilling">spilling/filling registers</a> to
compare strings with <code class="docutils literal notranslate"><span class="pre">strncmp()</span></code>, and applying a heuristic to avoid
reading (and comparing) more than necessary.  Both tricks are intertwined
into a “string prefix switch”:</p>
<ul class="simple">
<li><p>Four bytes are read from memory, and are cast to a 32-bit integer pointer;</p></li>
<li><p>That pointer is then dereferenced;</p></li>
<li><p>A standard switch statement is used to perform cheap comparisons on a 32-bit
integer;</p></li>
<li><p>When a header prefix is matched, a simple heuristic of finding the
separating colon and space character where they’re supposed to be is used.</p>
<ul>
<li><p>This might give false positives, although that’s very unlikely in practice.</p></li>
</ul>
</li>
</ul>
<p>Once the request has been parsed, it is time to look up what is going to
handle it.</p>
</div>
<div class="section" id="looking-up-handler">
<h2>Looking up handler</h2>
<p>A <a class="reference external" href="https://en.wikipedia.org/wiki/Trie">prefix tree</a> is used to look up handlers. It is a modified trie data
structure that has only eight pointers per node, so that on x86-64, each
node fills one cache line exactly. This is achieved by hashing each
character used to build up a node by taking the 3 least significant bits.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">lwan_trie_node_t_</span> <span class="p">{</span>
    <span class="n">lwan_trie_node_t</span> <span class="o">*</span><span class="n">next</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="n">lwan_trie_leaf_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ref_count</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The canonical and naïve alternative to the hashed trie is having <a class="reference external" href="https://github.com/lpereira/lwan/blob/b2c9b37e63c7ffedfcbd00c25349ab9501dc4985/lwan-trie.c#L27-L31">256
pointers per node</a>, which puts too much virtual memory pressure: the approach
used in Lwan is a good compromise between keeping this pressure low and
implementation complexity.</p>
<p>Another alternative (which might be considered in the future) is to reduce
the amount of nodes by <a class="reference external" href="https://en.wikipedia.org/wiki/Trie#Compressing_tries">coalescing common prefixes</a>; this significantly
increases implementation complexity, though, but combined with the string
switch trick, this might yield a good performance boost.</p>
<p>Yet another technique investigated was to <a class="reference external" href="https://gist.github.com/lpereira/c744c08c74ca600e58ff">generate machine code to perform
lookup</a>: essentially turning a data structure into executable code. The idea
works but the instruction cache pressure isn’t worth the trouble. I’m still
partial to this solution, though, so I might revisit it later: <a class="reference external" href="http://www.varnish-cache.org">Varnish</a> does
something remotely similar with VCL and it seems to work, so this deserves a
little bit more research.</p>
<p>After a handler is found, a second round of parsing might happen. Each
handler contains a set of flags that signal if headers (which were sliced in
the request parsing stage) should be actually parsed. This include headers
such as Range, Accept-Encoding, If-Modified-Since, and authorization stuff.
Handlers that do not require parsing these headers will not trigger
potentially expensive string crunching.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">HANDLER_PARSE_QUERY_STRING</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">HANDLER_PARSE_IF_MODIFIED_SINCE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">HANDLER_PARSE_RANGE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">HANDLER_PARSE_ACCEPT_ENCODING</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">HANDLER_PARSE_POST_DATA</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">HANDLER_MUST_AUTHORIZE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">HANDLER_REMOVE_LEADING_SLASH</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">,</span>

    <span class="n">HANDLER_PARSE_MASK</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span>
<span class="p">}</span> <span class="n">lwan_handler_flags_t</span><span class="p">;</span>
</pre></div>
</div>
<p>To reduce the amount of boilerplate necessary to declare a handler, there’s
a shortcut that parses almost everything; these are the “request handlers”,
such as the “Hello world handler” example shown below.</p>
<p>Modules, on the other hand, provide much more fine-grained control of how
the request will be handled; an example is the static file serving feature,
also discussed further down.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">const</span> <span class="n">lwan_module_t</span> <span class="n">serve_files</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"serve_files"</span><span class="p">,</span>
    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">serve_files_init</span><span class="p">,</span>
    <span class="p">.</span><span class="n">init_from_hash</span> <span class="o">=</span> <span class="n">serve_files_init_from_hash</span><span class="p">,</span>
    <span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">serve_files_shutdown</span><span class="p">,</span>
    <span class="p">.</span><span class="n">handle</span> <span class="o">=</span> <span class="n">serve_files_handle_cb</span><span class="p">,</span>
    <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">HANDLER_REMOVE_LEADING_SLASH</span>
        <span class="o">|</span> <span class="n">HANDLER_PARSE_IF_MODIFIED_SINCE</span>
        <span class="o">|</span> <span class="n">HANDLER_PARSE_RANGE</span>
        <span class="o">|</span> <span class="n">HANDLER_PARSE_ACCEPT_ENCODING</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="section" id="hello-world-handler">
<h3>Hello world handler</h3>
<p>The simplest handler possible is a “Hello, World!“. This tests the raw
read-parse-write capacity of Lwan, without requiring more system calls than
absolutely necessary.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">lwan_http_status_t</span>
<span class="nf">hello_world</span><span class="p">(</span><span class="n">lwan_request_t</span> <span class="o">*</span><span class="n">request</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">)),</span>
            <span class="n">lwan_response_t</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">)))</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hello_world</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="p">;</span>

    <span class="n">response</span><span class="o">-&gt;</span><span class="n">mime_type</span> <span class="o">=</span> <span class="s">"text/plain"</span><span class="p">;</span>
    <span class="n">strbuf_set_static</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">hello_world</span><span class="p">,</span>
                      <span class="n">strlen</span><span class="p">(</span><span class="n">hello_world</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">HTTP_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These simple handlers will use whatever is inside their respective string
buffers (which is an array that grows automatically when needed, with some
bookkeeping attached). In the “Hello, World!” case, however, the string
buffer acts merely as a pointer to some read-only string stored in the text
section; this simplifies the interface a little bit, while avoiding string
copies and unneeded heap allocations.</p>
</div>
<div class="section" id="chunked-encoding-and-server-sent-events">
<h3>Chunked encoding and Server-sent events</h3>
<p>Supported also is the <a class="reference external" href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding">Chunked Encoding</a>. Using it is very simple: just set
the response MIME Type, fill the string buffer, and call
<code class="docutils literal notranslate"><span class="pre">lwan_response_send_chunk()</span></code>. From this point on, the response headers will be
sent alongside the first chunk, the string buffer will be cleared, and the
coroutine will yield. To send the next chunk, just fill the string buffer
again and send another chunk, until your handler is complete.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">lwan_http_status_t</span>
<span class="nf">test_chunked_encoding</span><span class="p">(</span><span class="n">lwan_request_t</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span>
            <span class="n">lwan_response_t</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">)))</span>
<span class="p">{</span>
    <span class="n">response</span><span class="o">-&gt;</span><span class="n">mime_type</span> <span class="o">=</span> <span class="s">"text/plain"</span><span class="p">;</span>

    <span class="n">strbuf_printf</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"First chunk</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">lwan_response_send_chunk</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">strbuf_printf</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"*Chunk #%d*</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">lwan_response_send_chunk</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">strbuf_printf</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"Last chunk</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">lwan_response_send_chunk</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">HTTP_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The same general idea is used by <a class="reference external" href="https://en.wikipedia.org/wiki/Server-sent_events">Server-sent events</a>; however, one uses
<code class="docutils literal notranslate"><span class="pre">lwan_response_send_event()</span></code>, and passes the event name as well.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">lwan_http_status_t</span>
<span class="nf">test_server_sent_event</span><span class="p">(</span><span class="n">lwan_request_t</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span>
            <span class="n">lwan_response_t</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">)))</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">strbuf_printf</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"{n: %d}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">lwan_response_send_event</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="s">"currval"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">HTTP_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation inside Lwan is as straightforward as it looks: coroutines
saved the day.</p>
</div>
<div class="section" id="file-serving-module">
<h3>File serving module</h3>
<p>Since files can be served using the <code class="docutils literal notranslate"><span class="pre">sendfile()</span></code> system call, the kind of
handlers used by Hello World can’t be used: responses are sent using
<code class="docutils literal notranslate"><span class="pre">writev()</span></code> to send both response headers and contents in one kernel roundtrip.
Because of this, there’s a different kind of handler that gives more control
as to how the response is sent: the (for the lack of a better name)
streaming handlers. Streaming handlers are expected to send the whole
response themselves.</p>
<p>To convert a “normal” handler into a streaming handler is simple: just set a
few pointers in the “normal” handler and return. With the exception of
producing error responses automatically — streaming handlers function
exactly the same as a “normal” handler that does not send the response
headers automatically.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="n">lwan_http_status_t</span>
<span class="nf">serve_files_handle_cb</span><span class="p">(</span><span class="n">lwan_request_t</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span>
                      <span class="n">lwan_response_t</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lwan_http_status_t</span> <span class="n">return_status</span> <span class="o">=</span> <span class="n">HTTP_NOT_FOUND</span><span class="p">;</span>
    <span class="n">serve_files_priv_t</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">cache_entry_t</span> <span class="o">*</span><span class="n">ce</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">return_status</span> <span class="o">=</span> <span class="n">HTTP_INTERNAL_ERROR</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ce</span> <span class="o">=</span> <span class="n">cache_coro_get_and_ref_entry</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">,</span>
                <span class="n">request</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">coro</span><span class="p">,</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">url</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">ce</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">file_cache_entry_t</span> <span class="o">*</span><span class="n">fce</span> <span class="o">=</span> <span class="p">(</span><span class="n">file_cache_entry_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ce</span><span class="p">;</span>
        <span class="n">response</span><span class="o">-&gt;</span><span class="n">mime_type</span> <span class="o">=</span> <span class="n">fce</span><span class="o">-&gt;</span><span class="n">mime_type</span><span class="p">;</span>
        <span class="n">response</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">fce</span><span class="o">-&gt;</span><span class="n">funcs</span><span class="o">-&gt;</span><span class="n">serve</span><span class="p">;</span>
        <span class="n">response</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">ce</span><span class="p">;</span>
        <span class="n">response</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">.</span><span class="n">priv</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">HTTP_OK</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">fail</span><span class="p">:</span>
    <span class="n">response</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">return_status</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To avoid having to obtain information about a file for every request, this
information is cached for a few seconds. The caching mechanism itself is
discussed in detail further down.</p>
<p>While caching file information, the file size is considered while picking
the way to serve it.  Files larger than 16KiB are served with <code class="docutils literal notranslate"><span class="pre">sendfile()</span></code>
to allow zero (or fewer) copy transfers, and smaller files are mapped in
memory using <code class="docutils literal notranslate"><span class="pre">mmap()</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">const</span> <span class="n">cache_funcs_t</span> <span class="o">*</span>
<span class="nf">_get_funcs</span><span class="p">(</span><span class="n">serve_files_priv_t</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
           <span class="kt">char</span> <span class="o">*</span><span class="n">full_path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">index_html_path_buf</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">index_html_path</span> <span class="o">=</span> <span class="n">index_html_path_buf</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">st_mode</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* It is a directory. It might be the root directory</span>
<span class="cm">         * (empty key), or something else.  In either case,</span>
<span class="cm">         * tack priv-&gt;index_html to the path.  */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">key</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">index_html_path</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">index_html</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* Redirect /path to /path/. This is to help</span>
<span class="cm">             * cases where there's something like &lt;img</span>
<span class="cm">             * src="../foo.png"&gt;, so that actually</span>
<span class="cm">             * /path/../foo.png is served instead of</span>
<span class="cm">             * /path../foo.png.  */</span>
            <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key_end</span> <span class="o">=</span> <span class="n">rawmemchr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">key_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">'/'</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">&amp;</span><span class="n">redir_funcs</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">snprintf</span><span class="p">(</span><span class="n">index_html_path</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">,</span>
                                  <span class="s">"%s%s"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
                                  <span class="n">priv</span><span class="o">-&gt;</span><span class="n">index_html</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* See if it exists. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fstatat</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">index_html_path</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">ENOENT</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

            <span class="cm">/* If it doesn't, generate a directory list. */</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">dirlist_funcs</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* If it does, we want its full path. */</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">path_len</span> <span class="o">+</span> <span class="mi">1</span> <span class="cm">/* slash */</span> <span class="o">+</span>
                     <span class="n">strlen</span><span class="p">(</span><span class="n">index_html_path</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">PATH_MAX</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="n">full_path</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">path_len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'/'</span><span class="p">;</span>
        <span class="n">strncpy</span><span class="p">(</span><span class="n">full_path</span> <span class="o">+</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">path_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">index_html_path</span><span class="p">,</span>
                <span class="n">PATH_MAX</span> <span class="o">-</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">path_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* It's not a directory: choose the fastest way to serve the</span>
<span class="cm">     * file judging by its size.  */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">st_size</span> <span class="o">&lt;</span> <span class="mi">16384</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="n">mmap_funcs</span><span class="p">;</span>

    <span class="k">return</span> <span class="o">&amp;</span><span class="n">sendfile_funcs</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Small files may also be compressed, unless compressed data ends up being
larger than the original data. Especially if the response header is
considered. Because of this, small files are only compressed if it’s worth
the trouble. The 16KiB threshold has been chosen empirically: larger values
did not yield substantial performance gains compared to using <code class="docutils literal notranslate"><span class="pre">sendfile()</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">void</span>
<span class="nf">_compress_cached_entry</span><span class="p">(</span><span class="n">mmap_cache_data_t</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">deflated_header_size</span> <span class="o">=</span>
            <span class="k">sizeof</span><span class="p">(</span><span class="s">"Content-Encoding: deflate"</span><span class="p">);</span>

    <span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">compressBound</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">uncompressed</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>

    <span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="o">!</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">contents</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">error_zero_out</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">contents</span><span class="p">,</span>
                       <span class="o">&amp;</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
                       <span class="n">md</span><span class="o">-&gt;</span><span class="n">uncompressed</span><span class="p">.</span><span class="n">contents</span><span class="p">,</span>
                       <span class="n">md</span><span class="o">-&gt;</span><span class="n">uncompressed</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">Z_OK</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">error_free_compressed</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">total_size</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span>
            <span class="o">+</span> <span class="n">deflated_header_size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">total_size</span> <span class="o">&lt;</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">uncompressed</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

<span class="nl">error_free_compressed</span><span class="p">:</span>
    <span class="n">free</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">contents</span><span class="p">);</span>
    <span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">error_zero_out</span><span class="p">:</span>
    <span class="n">md</span><span class="o">-&gt;</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For directories, the template engine is used to create the listing. The
contents are cached using the same mechanism files are. Templating is
discussed below.</p>
<p>An interesting optimization is that, to obtain the full path, a special
version of <a class="reference external" href="http://linux.die.net/man/3/realpath">realpath()</a>, forked from the GNU libc implementation, is used.
This version uses the <a class="reference external" href="http://lwn.net/Articles/164887/">lighter “-at()” variants</a> of system calls that operates
on paths; they do not need to perform path-to-inode conversion for the whole
path, only from a path pointed to by a directory file descriptor.</p>
<p>The file server is a module. It is a simple way to keep per instance state,
such as the file descriptor for the root directory, the directory list
template, and a few other things.</p>
</div>
</div>
<div class="section" id="mustache-templating-engine">
<h2>Mustache templating engine</h2>
<p>Not all features from <a class="reference external" href="http://mustache.github.io/">Mustache</a> are implemented: some are pretty much only
practical if using a language that’s more expressive than C. However,
without requiring (too much) boilerplate, a substantial amount of its
specification is implemented, in a pretty efficient way, and suits all Lwan
uses pretty well. (Being performant <a class="reference external" href="http://blog.codinghorror.com/the-sad-tragedy-of-micro-optimization-theater/">might not matter</a>, though, but I’m
here to have fun, not solve problems.)</p>
<p>Not everything is implemented exactly as in the standard, though: that’s
mostly for laziness reasons, but the non-dynamic nature of C would make
certain things needlessly difficult to implement and use, anyway. The
templating engine supports the basic stuff. In no particular order:</p>
<ul class="simple">
<li><p>Variables of different types;</p></li>
<li><p>Checking the emptiness of variables;</p></li>
<li><p>Iteration on lists (and any kind of sequences);</p></li>
<li><p>Partials;</p></li>
<li><p>Comments;</p></li>
<li><p>Inverted sections.</p></li>
</ul>
<p>Setting the delimiters, triple mustaches (for escaping HTML output),
ampersand to unescape strings — and possibly other things — are not
implemented, but could be implemented with relatively minimal effort. String
escaping is supported by using a special string type and should <a class="reference external" href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content">conform to
best practices</a>.</p>
<p>Templates are pre-processed. This pre-processing step uses a state machine
parser to break down its text representation into a series of actions that
can be performed by the engine very efficiently. Actions include things like
“append string”, “append variable”, “start iteration”, and so on.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">TPL_ACTION_APPEND</span><span class="p">,</span>
    <span class="n">TPL_ACTION_APPEND_CHAR</span><span class="p">,</span>
    <span class="n">TPL_ACTION_VARIABLE</span><span class="p">,</span>
    <span class="n">TPL_ACTION_LIST_START_ITER</span><span class="p">,</span>
    <span class="n">TPL_ACTION_LIST_END_ITER</span><span class="p">,</span>
    <span class="n">TPL_ACTION_IF_VARIABLE_NOT_EMPTY</span><span class="p">,</span>
    <span class="n">TPL_ACTION_END_IF_VARIABLE_NOT_EMPTY</span><span class="p">,</span>
    <span class="n">TPL_ACTION_APPLY_TPL</span><span class="p">,</span>
    <span class="n">TPL_ACTION_LAST</span>
<span class="p">}</span> <span class="n">lwan_tpl_action_t</span><span class="p">;</span>
</pre></div>
</div>
<p>For instance, a stack of hash tables is used during this pre-processing step
to act as a symbol table; this table can be thrown away as soon as the
pre-processing step is complete, as all variables have been resolved and a
much more efficient value lookup mechanism can be used instead.</p>
<div class="section" id="obtaining-variables">
<h3>Obtaining variables</h3>
<p>To use the templating mechanism, one should have a structure for each
template. Structures are cheap and provide some welcome compile-time type
checking that wouldn’t be possible otherwise.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">typedef</span> <span class="k">struct</span> <span class="n">hello_t</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In addition to a structure, due to the lack of introspection in C, an array
of variable descriptors should be declared. A variable descriptor contains a
string representation of a variable name, the offset in bytes of that
variable within the structure, and pointers to functions to test the
emptiness of that kind of variable and to append the variable to the string
buffer; macros help alleviate boilerplate headaches.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">lwan_var_descriptor_t</span> <span class="n">hello_descriptor</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">TPL_VAR_STR</span><span class="p">(</span><span class="n">hello_t</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span>
  <span class="n">TPL_VAR_INT</span><span class="p">(</span><span class="n">hello_t</span><span class="p">,</span> <span class="n">age</span><span class="p">),</span>
  <span class="n">TPL_VAR_SENTINEL</span>
<span class="p">};</span>

<span class="n">lwan_tpl_t</span> <span class="o">*</span><span class="n">hello</span> <span class="o">=</span> <span class="n">lwan_tpl_compile</span><span class="p">(</span><span class="s">"hello.tpl"</span><span class="p">,</span>
                                     <span class="n">hello_descriptor</span><span class="p">);</span>
</pre></div>
</div>
<p>A structure containing all the variables can then be supplied by some sort
of database layer, caching layer, or be declared on the spot: compound
literals with designated initializers make this use case pretty
straightforward.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">strbuf_t</span> <span class="o">*</span><span class="n">rendered</span> <span class="o">=</span> <span class="n">lwan_tpl_render</span><span class="p">(</span><span class="n">hello</span><span class="p">,</span> <span class="p">(</span><span class="n">hello_t</span><span class="p">[])</span> <span class="p">{{</span>
  <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"World"</span><span class="p">,</span>
  <span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">42</span>
<span class="p">}});</span>

<span class="cm">/* Do something with `rendered` */</span>

<span class="n">strbuf_free</span><span class="p">(</span><span class="n">rendered</span><span class="p">);</span>
</pre></div>
</div>
<p>Appending a variable is then just the matter of calling the
appropriate callback function (conveniently in the descriptor), passing the
base address of that structure plus the byte offset within it.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">void</span>
<span class="nf">append_var_to_strbuf</span><span class="p">(</span><span class="n">lwan_tpl_chunk_t</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">variables</span><span class="p">,</span>
                     <span class="n">strbuf_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lwan_var_descriptor_t</span> <span class="o">*</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">descriptor</span><span class="p">))</span>
        <span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">append_to_strbuf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span>
                      <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">variables</span> <span class="o">+</span> <span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sequences">
<h3>Sequences</h3>
<p>To avoid creating potentially lots of small, temporary objects, for lists
and sequences a coroutine is created and is used as a makeshift generator
function. Another option was to implement iterators using a structure to
hold state plus a few callbacks — I gave up while imagining the amount of
boilerplate necessary. A function is simple to write on the other hand, and
can include initialization, iteration, and cleanup.</p>
<div class="figure align-center" id="id3">
<img alt="sequences" src="https://i.imgur.com/VsAfnsC.png"/>
<p class="caption"><span class="caption-text">How sequences are evaluated by the templating engine</span></p>
</div>
<p>The only user of sequences in templates within Lwan is the file listing
feature in the file serving module. The generator function is pretty
straightforward, and is responsible for opening the directory, obtaining
information for each entry, and then closing the directory. A shorter
version of it is described in the original blog post about <a class="reference external" href="http://tia.mat.br/blog/html/2013/09/26/implementing_sequences_in_lwan_template_engine.html">sequences in the
templating engine</a>.</p>
</div>
</div>
<div class="section" id="caching">
<h2>Caching</h2>
<p>I’ve used and implemented a few caching infrastructures over the years, and
I believe that the one in Lwan is, so far, the simplest one I’ve used. Most
caches will require items to be created — and then added manually to the
cache. Not only clumsy, but could also lead to race conditions.</p>
<p>The one in Lwan knows how to create and destroy a cache entry: one just asks
the cache to obtain a value for a given key. If it’s not there, the entry is
created and returned. The lifetime of a cache entry is controlled
automatically, and a low priority thread kicks in every now and then to
prune old entries.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">cache_t</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">hash</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
        <span class="n">pthread_rwlock_t</span> <span class="n">lock</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">hash</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
        <span class="n">pthread_rwlock_t</span> <span class="n">lock</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">queue</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
        <span class="n">CreateEntryCallback</span> <span class="n">create_entry</span><span class="p">;</span>
        <span class="n">DestroyEntryCallback</span> <span class="n">destroy_entry</span><span class="p">;</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">cb</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">time_t</span> <span class="n">time_to_live</span><span class="p">;</span>
        <span class="kt">clockid_t</span> <span class="n">clock_id</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">settings</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">;</span>

<span class="cp">#ifndef NDEBUG</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">hits</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="n">misses</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="n">evicted</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">stats</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Unlike most caches, the one in Lwan isn’t limited by size: items stay in the
cache for a predetermined amount of time.</p>
<p>Cache entries are reference-counted, and they’re not automatically reaped if
something is holding on a reference: these items are marked as floating when
this happens, and the last one to give up the reference will also destroy
the entry.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">cache_entry_t</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">list_node</span> <span class="n">entries</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">refs</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">timespec</span> <span class="n">time_to_die</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">file_cache_entry_t_</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">cache_entry_t</span> <span class="n">base</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">string</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
        <span class="kt">time_t</span> <span class="n">integer</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">last_modified</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mime_type</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">cache_funcs_t</span> <span class="o">*</span><span class="n">funcs</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When used within a coroutine, two things can happen: ➀ the coroutine might
yield if the cache lock were to become contended and ➁ automatically
releasing a reference when a coroutine is destroyed.</p>
<p>In addition to floating entries, there are also temporary entries. The cache
uses read-write locks, but most of the time, locks are only obtained using
the “trylock” primitive: if a lock can’t be obtained for a reason, Lwan
tries to move on to something else. This could be attending to another
request (by yielding the coroutine), or merely returning an off-the-books
entry that will be destroyed as soon as its sole user releases its
reference. The difference to floating entries is merely an implementation
detail, so that an atomic decrement (and its accompanying memory barrier)
isn’t used.</p>
<p>The cache tries to avoid keeping the locks locked. As an example, while an
item is being created, no locks are held. This can, of course, lead to
multiple entries being created concurrently, but if caching would be useful
anyway, having a few temporary entries lying around isn’t a problem, as at
least one will be cached for future access.</p>
<p>As nice as the cache subsystem ended up being, there is a lot of room for
improvement.  Reducing the amount of concurrent reference counting is high
on the list.  Reducing the latency is also in consideration.  Making HTTP
responses cacheable without special code in the handler is there as well.</p>
</div>
<div class="section" id="keep-alive-connections-death-queue">
<h2>Keep-alive connections, death queue</h2>
<p>Connection lifetime is managed by a per-thread queue.</p>
<p>Each time a connection is scheduled to a certain thread, it is pushed to the
queue, and a time to die is set. When there are connections in this queue,
Epoll will timeout every second to iterate through it and kill connections
when their time has come. Timeouts are infinite when the queue is empty, to
avoid waking the process unnecessarily. Every time a coroutine is resumed,
the time to die is updated, and the connection is pushed to the end of the
queue.</p>
<p>Each death queue has its own epoch, which starts at zero and increments at
every timeout. Whenever the last connection is removed from a queue, the
epoch restarts. Keeping the epoch a small number will help shave a few bytes
from each connection in the future.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">death_queue_t</span> <span class="p">{</span>
    <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">conns</span><span class="p">;</span>
    <span class="n">lwan_connection_t</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">time</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">keep_alive_timeout</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The same timeout value is used for keep-alive connections and coroutines.
This ensures coroutines will not linger indefinitely when not performing any
kind of work.</p>
<p>The death queue is so important that almost a third of the connection
structure is dedicated to its existence. Three integers keep state for the
death queue: the time to die (as an unsigned int), and two integers as
pointers to a doubly linked list.</p>
<p>Integers were used instead of pointers in order to save memory. This was
possible since in reality they are indices to the connection array. A doubly
linked list was also chosen since removing a connection from the middle of
the queue should be efficient, as it is done very frequently to move the
entry to the end. The list is also circular, in order to avoid branching to
handle empty queue cases. Maintaining the queue inline with the connection
structures help reducing cache pressure.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">_death_queue_node_to_idx</span><span class="p">(</span>
            <span class="k">struct</span> <span class="n">death_queue_t</span> <span class="o">*</span><span class="n">dq</span><span class="p">,</span> <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">conn</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span> <span class="o">?</span>
            <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">ptrdiff_t</span><span class="p">)(</span><span class="n">conn</span> <span class="o">-</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">conns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="nf">_death_queue_idx_to_node</span><span class="p">(</span>
            <span class="k">struct</span> <span class="n">death_queue_t</span> <span class="o">*</span><span class="n">dq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">dq</span><span class="o">-&gt;</span><span class="nl">head</span> <span class="p">:</span> <span class="o">&amp;</span><span class="n">dq</span><span class="o">-&gt;</span><span class="n">conns</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_death_queue_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">death_queue_t</span> <span class="o">*</span><span class="n">dq</span><span class="p">,</span>
    <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">new_node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
    <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">_death_queue_idx_to_node</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span>
                                           <span class="n">dq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>
    <span class="n">dq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">_death_queue_node_to_idx</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span>
                                                   <span class="n">new_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_death_queue_remove</span><span class="p">(</span>
            <span class="k">struct</span> <span class="n">death_queue_t</span> <span class="o">*</span><span class="n">dq</span><span class="p">,</span> <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">_death_queue_idx_to_node</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span>
                                              <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">);</span>
    <span class="n">lwan_connection_t</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">_death_queue_idx_to_node</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span>
                                              <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="closing-words">
<h2>Closing words</h2>
<p>That’s pretty much it: when a response has been sent, the connection can
either be closed, or a new request can be serviced in the same connection.
Repeat ad infinitum and there’s the <a class="reference external" href="http://lwan.ws">HTTP server</a>.</p>
<p>If you’ve made this far, I invite you to take a look at the <a class="reference external" href="https://github.com/lpereira/lwan">full source code</a>.
There are things that were not mentioned in this article. It’s also a young
Free Software project with no entry barrier: just fork and issue a pull
request.</p>
</div>
]]></description>
             <pubDate>Mon, 06 Oct 2014 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2014/06/23/integer_to_string_conversion.html</link>
            <guid>http://tia.mat.br/blog/html/2014/06/23/integer_to_string_conversion.html</guid>
            <title><![CDATA[Integer to string conversion]]></title>
            <description><![CDATA[<h1>Integer to string conversion</h1>
<p>There are various ways to convert integers to their string representation.
These conversions are rarely a bottleneck, but they often show up while
profiling certain applications.  For instance, they’re very common in
<a class="reference external" href="http://lwan.ws">Lwan</a> while building the response headers.</p>
<p>To use Lwan as an example: initially, <code class="docutils literal notranslate"><span class="pre">snprintf()</span></code> was used to convert
numbers.  Although this works, it is quite boring, performance-wise.</p>
<p>The second approach was using the naïve algorithm, which basically divides
the number by <code class="docutils literal notranslate"><span class="pre">10</span></code> in succession, writing backwards the result of modulus by
<code class="docutils literal notranslate"><span class="pre">10</span></code> to a string, and then reversing the string when the number reaches <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="c1">// Code based on https://code.google.com/p/stringencoders/</span>
<span class="kt">size_t</span> <span class="nf">naive_uint32_to_str</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">wstr</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
    <span class="c1">// Conversion. Number is reversed.</span>
    <span class="k">do</span>
       <span class="o">*</span><span class="n">wstr</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">decimal_digits</span><span class="p">[</span><span class="n">uvalue</span> <span class="o">%</span> <span class="mi">10</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">uvalue</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">);</span>
    <span class="o">*</span><span class="n">wstr</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="c1">// Reverse string</span>
    <span class="n">strreverse</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">wstr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">wstr</span> <span class="o">-</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This was fine for a while, but that string reversion step always bothered
me.  Why not just write the string backwards already?</p>
<p>I’ve then changed the code in Lwan to the following snippet. Note the nice
trick of multiplying the size of an integer in bytes by <code class="docutils literal notranslate"><span class="pre">3</span></code> to obtain an
approximation of the number of digits for <code class="docutils literal notranslate"><span class="pre">MAX_INT</span></code>, including the zero
terminator, regardless of what <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span></code> is.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cp">#define INT_TO_STR_BUFFER_SIZE (3 * sizeof(int))</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">lwan_uint32_to_str</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">value</span><span class="p">,</span>
            <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="k">static</span> <span class="n">INT_TO_STR_BUFFER_SIZE</span><span class="p">],</span>
            <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">INT_TO_STR_BUFFER_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="o">*--</span><span class="n">p</span> <span class="o">=</span> <span class="s">"0123456789"</span><span class="p">[</span><span class="n">value</span> <span class="o">%</span> <span class="mi">10</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">value</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">);</span>

    <span class="kt">size_t</span> <span class="n">difference</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">);</span>
    <span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">INT_TO_STR_BUFFER_SIZE</span> <span class="o">-</span> <span class="n">difference</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Reducing writes to the array made this algorithm significantly faster.
However, I eventually did what one should always avoid when tinkering with
this kind of thing: I’ve changed the array lookup to an addition, without
measuring if it would perform better, and committed the code anyway.  The
lookup table is ~9% faster.  Ouch!</p>
<p>Last year, the Facebook Engineering team <a class="reference external" href="https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920">posted a function</a> to convert
integers to strings that manages to be even faster.  They do use the same
idea of avoiding having to reverse the string after they’re done converting
each digit, and they use a lookup table as well.</p>
<p>But the nice trick is that, instead of having a lookup table for 10 digits,
there’s a table for all pair of digits, from <cite>00</cite> to <cite>99</cite>.  This cuts the
amount of divisions by half, yielding a significantly faster algorithm:
around 31% faster than the above snippet:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">size_t</span> <span class="nf">facebook_uint32_to_str</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">digits</span><span class="p">[</span><span class="mi">201</span><span class="p">]</span> <span class="o">=</span>
        <span class="s">"0001020304050607080910111213141516171819"</span>
        <span class="s">"2021222324252627282930313233343536373839"</span>
        <span class="s">"4041424344454647484950515253545556575859"</span>
        <span class="s">"6061626364656667686970717273747576777879"</span>
        <span class="s">"8081828384858687888990919293949596979899"</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">digits10</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">next</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="k">const</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">%</span> <span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">value</span> <span class="o">/=</span> <span class="mi">100</span><span class="p">;</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="n">digits</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">next</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">next</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Handle last 1-2 digits</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="o">+</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="n">digits</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">next</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">digits10()</span></code> function is also another function that calculates the
number of digits of a number in a very efficient manner.  Even being
performant, though, one can get rid of the call altogether: using a constant
like <code class="docutils literal notranslate"><span class="pre">numeric_limits&lt;uint32_t&gt;::digits10</span></code> will keep the same interface.
This is possible because the <code class="docutils literal notranslate"><span class="pre">dst</span></code> buffer should be large enough to hold
all the digits of the largest 32-bit unsigned integer anyway.</p>
<p>Because of implementation details – the function basically compares numbers
to powers of 10 and recurses when the number of digits surpasses the maximum
power that they’re comparing to – the speedup of using a constant length
won’t be significant for small numbers (one and two digits); but if you’re
optimizing to this level, using a constant won’t hurt.  So much so, that it
is consistently faster on my machine (a Core i7 2640M laptop, with an
up-to-date 64-bit Arch Linux):</p>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="http://tia.mat.br/blog/html/2014/06/23/https://i.imgur.com/9V0PsPK.png"><img alt="relativespeedup" src="https://i.imgur.com/9V0PsPK.png" style="width: 100%;"/></a>
<p class="caption"><span class="caption-text">Relative speedup of <code class="docutils literal notranslate"><span class="pre">facebook_uint32_to_str()</span></code> using <code class="docutils literal notranslate"><span class="pre">digits10()</span></code> and a
constant value</span></p>
</div>
<p>That chart was obtained by using a <a class="reference external" href="https://gist.github.com/lpereira/c0bf3ca3148321395037">benchmark program</a> I wrote that will
test all these ways of converting an integer to their string representation.
To compare with other methods, here’s the full chart:</p>
<div class="figure align-center" id="id2">
<a class="reference internal image-reference" href="http://tia.mat.br/blog/html/2014/06/23/https://i.imgur.com/b2enLNt.png"><img alt="benchmark" src="https://i.imgur.com/b2enLNt.png" style="width: 100%;"/></a>
<p class="caption"><span class="caption-text">Results for <code class="docutils literal notranslate"><span class="pre">snprintf()</span></code> omitted to not skew results. Spoiler: it’s slow.</span></p>
</div>
<p>Unfortunately, there’s a licencing issue that won’t let me use this code in
Lwan.  The blog post doesn’t mention the license.  I’ve found this <a class="reference external" href="https://mail-archives.apache.org/mod_mbox/apr-dev/200704.mbox/%3C344-65769@sneakemail.com%3E">two-digit
lookup table in places unrelated to Facebook</a> as well, so I’m not sure who
had this idea first.  My go-to source of this kind of thing is usually
<a class="reference external" href="http://www.hackersdelight.org/">Hacker’s Delight</a>, but even then it’s not there.</p>
]]></description>
             <pubDate>Mon, 23 Jun 2014 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2013/12/08/reducing_lwan_memory_usage.html</link>
            <guid>http://tia.mat.br/blog/html/2013/12/08/reducing_lwan_memory_usage.html</guid>
            <title><![CDATA[Reducing Lwan memory usage by 94%]]></title>
            <description><![CDATA[<h1>Reducing Lwan memory usage by 94%</h1>
<p>One of the things that bothers me when I’m writing software is that I <a class="reference external" href="https://www.youtube.com/watch?v=csyL9EC0S0c">never
get things right the first time</a>.  It takes me quite a few iterations to
achieve a good result – be it performance, memory usage, or a good
architecture.  Getting things to a “good enough” state is also very frequent
as projects need to move forward; however, written code often ends up in
sort of a low priority refactoring thread inside my head.  Sometimes this
thread is able to produce a thing or two, and I’m able to revisit these
things.</p>
<div class="figure align-center" id="id1">
<img alt="projectmovingforward" src="https://farm1.staticflickr.com/64/169229347_f554a9c9ea.jpg"/>
<p class="caption"><span class="caption-text">Project moving forward picture by <a class="reference external" href="http://www.flickr.com/photos/tsdesign/">Todd Smith</a>. Sometimes you’re so
focused on the goal that you end up not appreciating the journey.</span></p>
</div>
<div class="section" id="background-toys">
<h2>Background toys</h2>
<p>One of the things that were in that refactoring thread was <a class="reference external" href="http://github.com/lpereira/lwan">my toy web
server</a>’s memory usage.  It would consume a whopping <strong>855MB</strong> of memory
while idling; recent commits dropped this amount to a mere <strong>32MB</strong> (with
maybe some more room to spare).  It used to use <strong>2670%</strong> more memory.</p>
<p>This was only possible because I know the code inside out and was able to
refactor the code a few times.</p>
<div class="figure align-center" id="id2">
<a class="reference internal image-reference" href="http://tia.mat.br/blog/html/2013/12/08/https://i.imgur.com/xSB5PZp.png"><img alt="massifscreenshot0" src="https://i.imgur.com/xSB5PZp.png" style="width: 100%;"/></a>
<p class="caption"><span class="caption-text">Massif-visualizer windows shown at different scales.</span></p>
</div>
</div>
<div class="section" id="structure-diet">
<h2>Structure diet</h2>
<p>Lwan allocates almost all memory it is going to need even before creating
the main socket.  This means it has to keep around some structures with
information about connections, requests, and their responses.</p>
<p>The first drop in memory usage was the highest one. It was possible because
the structure that keep state for these things also kept state that was only
useful during the request parsing stage.  By segregating this temporary
state to another structure, which is allocated in the request parsing
routine stack, memory usage fell dramatically.</p>
<p>Lots of flags were saved using bitfields in different substructures. Most of
these were booleans, and having less than 32 of them meant I could coalesce
all of them in a single unsigned integer.  Memory usage dropped again.</p>
</div>
<div class="section" id="architecture-smell">
<h2>Architecture smell</h2>
<p>Then a few months passed, and out of the blue I realized that there was
something wrong in the architecture: the same structure I was using to track
request state, I was also using to track connection state.</p>
<p>So I moved all things that only matters to a connection to a structure –
which is the structure that’s preallocated on startup – and made the
request structure be allocated in the request processor routine’s stack.
This stack lives in a coroutine – which won’t use more memory than it was
already allocated for the coroutine stack.  Another worthy reduction of
memory usage.</p>
<p>This also made keep-alive connections a tiny bit faster, as there’s no need to
<code class="docutils literal notranslate"><span class="pre">memset()</span></code> the request structure to clean state for the next request
anymore.</p>
<div class="figure align-center" id="id3">
<a class="reference internal image-reference" href="http://tia.mat.br/blog/html/2013/12/08/https://i.imgur.com/3BrC0KB.png"><img alt="massifscreenshot" src="https://i.imgur.com/3BrC0KB.png" style="width: 100%;"/></a>
<p class="caption"><span class="caption-text">Same scale this time. <em>That drop</em>.</span></p>
</div>
</div>
<div class="section" id="reducing-it-further">
<h2>Reducing it further</h2>
<p>There’s another possibility for memory reduction, but I’m not sure if it is
worthy implementing.</p>
<p>Lwan uses <code class="docutils literal notranslate"><span class="pre">epoll()</span></code> – and when a file descriptor is added to a poller,
one can pass arbitrary data inside <code class="docutils literal notranslate"><span class="pre">epoll_data_t</span></code>, up to 64-bit in size.
Both the file descriptor and the remote IP address could then be passed as
this data, removing both fields from the connection structure.</p>
<p>This is possible because these are constant values while the connection is
active; everything else is either useless to identify the connection (the
file descriptor is used as an index in an array of connections) or changes
all the time, such as the flags (which would incur the penalty of calling
<code class="docutils literal notranslate"><span class="pre">epoll_ctl()</span></code> every time they change).</p>
<p>This would reduce structures by a few megabytes, which isn’t really worth
the effort considering IPv6 support would need to be implemented someday and
this trick would be then rendered useless.  Maybe my refactoring thread will
be able to answer that in a few months.</p>
<p>I’m still considering if it is worthy the trouble of leaking the
request/connection abstraction and removing an integer from the request
structure so all request-related flags would be set in the connection
structure.</p>
<p><strong>Update (11 Dec):</strong> I’ve found another way to remove these two structure
members; I’ve committed this code on a <a class="reference external" href="https://github.com/lpereira/lwan/tree/32-byte-connection-struct">separate branch</a> as further tests
must be performed.  In the same circumstances as the other tests, the server
is now using 2MiB less memory.  Basically:</p>
<ol class="arabic simple">
<li><p>The remote IP address can be obtained through the <code class="docutils literal notranslate"><span class="pre">getpeername()</span></code> function; since it’s not usually required, the need to keep this information around is reduced.</p></li>
<li><p>The socket file descriptor can be calculated by pointer arithmetic. Each connection has a reference to the huge connection array that it is part of; subtracting this from the connection pointer yields the file descriptor.</p></li>
</ol>
</div>
]]></description>
             <pubDate>Sun, 08 Dec 2013 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2013/09/26/implementing_sequences_in_lwan_template_engine.html</link>
            <guid>http://tia.mat.br/blog/html/2013/09/26/implementing_sequences_in_lwan_template_engine.html</guid>
            <title><![CDATA[Implementing sequences in lwan template engine]]></title>
            <description><![CDATA[<h1>Implementing sequences in lwan template engine</h1>
<p>When I wrote about lwan’s templating engine on a <a class="reference external" href="http://tia.mat.br/blog/html/2012/11/11/mustache_templates_in_c.html">blog post</a> last year, I
purposedly ommitted the fact that it didn’t support sequences. Took me
almost a year, but I’ve finally implemented it this week. (Lwan is usually a
low priority weekend project. Maybe that should do as an excuse for my
laziness.)</p>
<p>It took me three tries to get this right. <a class="reference external" href="https://en.wikipedia.org/wiki/Rube_Goldberg_machine">Rube Goldberg machine</a> kind of
right, but there’s always some elegance in ingenuity.</p>
<p>The first try would require one to create the list beforehand, and then pass
it to the template engine to render.  Not only cumbersome, but would require
the creation of (potentially) large amounts of temporary objects.</p>
<p>The latter reason lead me to think of a way to implement iterators in C.
This is usually done using callbacks; and although performant, it gets
pretty verbose and tedious as there is usually the need to create structures
to keep state, and different callbacks to initialize, destroy, and advance
the iterator.</p>
<p>Lots of <a class="reference external" href="https://01.org/blogs/imad/2013/welcome-profusion">things happened since then</a>, and this feature sort of creeped
under the low priority rug for the most part of a year.</p>
<p>While writing a completely different program in Python, however, it struck
me: I could use the <a class="reference external" href="http://tia.mat.br/blog/html/2012/09/29/asynchronous_i_o_in_c_with_coroutines.html">coroutine stuff</a> I was already using in lwan and
implement <a class="reference external" href="https://wiki.python.org/moin/Generators">generator functions</a>.  A few minutes later and I had a working
prototype, which can probably be better explained with the help of a
diagram:</p>
<img alt="diagram" class="align-center" src="https://i.imgur.com/VsAfnsC.png"/>
<p>In short, the engine will create a coroutine whenever it finds a
<code class="docutils literal notranslate"><span class="pre">{{#sequence}}</span></code> template tag.  This coroutine will start, and will execute
as usual until it yields.</p>
<p>Yielding <code class="docutils literal notranslate"><span class="pre">false</span></code>, the engine assumes the iteration ended, and proceeds to
find the next matching <code class="docutils literal notranslate"><span class="pre">{{/sequence}}</span></code> tag to continue from there.</p>
<p>On a <code class="docutils literal notranslate"><span class="pre">true</span></code> yield, however, the engine will recurse to apply everything is
between the iteration tags, repeating the process when the iteration-end tag
is found and the coroutine yields <code class="docutils literal notranslate"><span class="pre">true</span></code> again.</p>
<p>The coroutine is supposed to clean up after itself before returning a
<code class="docutils literal notranslate"><span class="pre">false</span></code> value.</p>
<div class="figure align-center" id="id1">
<img alt="rubegoldbergmachine" src="https://i.imgur.com/7P2yadJ.jpg"/>
<p class="caption"><span class="caption-text">Professor Butts would be proud. Maybe. <a class="reference external" href="https://en.wikipedia.org/wiki/File:Rubenvent.jpg">Source</a>.</span></p>
</div>
<p>A sample generator function is shown below. It iterates over a directory
with <code class="docutils literal notranslate"><span class="pre">readdir()</span></code>, returning <code class="docutils literal notranslate"><span class="pre">1</span></code> on new item availability and <code class="docutils literal notranslate"><span class="pre">0</span></code> when there
isn’t anything else to do. Notice that initialization, iteration, and cleanup
is all contained within a single function.</p>
<p>Also, notice that there’s no need to copy any values to and from the
structure – calling <code class="docutils literal notranslate"><span class="pre">coro_yield()</span></code> will of course maintain the stack
alive, so local variables can be used outside this function as long as a
reference to them can be obtained.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">dir_list_generator</span><span class="p">(</span><span class="n">coro_t</span> <span class="o">*</span><span class="n">coro</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">DIR</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="n">ent</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">file_list</span> <span class="o">*</span><span class="n">fl</span> <span class="o">=</span> <span class="n">coro_get_data</span><span class="p">(</span><span class="n">coro</span><span class="p">);</span>

    <span class="n">dir</span> <span class="o">=</span> <span class="n">opendir</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">((</span><span class="n">ent</span> <span class="o">=</span> <span class="n">readdir</span><span class="p">(</span><span class="n">dir</span><span class="p">)))</span> <span class="p">{</span>
      <span class="n">fl</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">;</span>
      <span class="n">coro_yield</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>   <span class="cm">/* !0 means "iter not done yet" */</span>
    <span class="p">}</span>

    <span class="n">closedir</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The details of how the variable descriptors are set up are explained in the
<a class="reference external" href="https://github.com/lpereira/lwan/commit/a4188d73a00cec4c99d50473803c44bfb2218d13">commit message</a> that introduced this change.  (The commit itself is quite
buggy, but whatever I could find has been fixed in <a class="reference external" href="https://github.com/lpereira/lwan">HEAD</a> already.)</p>
<p>In an ideal world, one would use something akin to Golang’s <a class="reference external" href="http://golang.org/doc/effective_go.html#channels">Channels</a>, but
if I were to implement them in lwan it would take perhaps another year.
Plus, they wouldn’t be as efficient as setting some pointers.  But they
might be useful in the future, so I’m not completely discarding the idea.
Although I’ve never written a single line of Go code, I’m reading a lot
about it recently and it is sort of positively impacting the way I think
about programming.  But I digress.</p>
]]></description>
             <pubDate>Thu, 26 Sep 2013 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2013/07/20/partial_functions_in_c.html</link>
            <guid>http://tia.mat.br/blog/html/2013/07/20/partial_functions_in_c.html</guid>
            <title><![CDATA[Partially Applied Functions in C]]></title>
            <description><![CDATA[<h1>Partially Applied Functions in C</h1>
<p>There are some functions in the standard C library that takes a function
pointer to be used as a callback later on.  Examples include <code class="docutils literal notranslate"><span class="pre">atexit()</span></code>
and <code class="docutils literal notranslate"><span class="pre">signal()</span></code>.  However, these functions can’t receive an arbitrary
pointer (which could hold some important program state) in addition to the
function pointer, so you’re left with pesky global variables:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cm">/* You have: */</span>
<span class="n">atexit</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span> <span class="cm">/* foo() will have to fetch program state from globals */</span>

<span class="cm">/* Instead of: */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">program_state</span> <span class="n">state</span><span class="p">;</span>
<span class="n">atexit</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">);</span> <span class="cm">/* foo() now have a pointer to program state */</span>
</pre></div>
</div>
<p>Turns out that there’s a workaround, but it involves some black magic.</p>
<p>I believe the overall mechanism to be quite interesting, however I do not
recommend its usage.  Not only because the implementation wastes a whole
<a class="reference external" href="https://en.wikipedia.org/wiki/Page_(computer_memory)">memory page</a> for a callback, but also because I don’t want to encourage
people to perpetuate this kind of take-pointer-to-function-without-argument
nonsense.</p>
<p>I’ll try to explain how this contraption works by showing the smaller parts
first.  I’ll begin with the template function.  The idea is to have a
function whose code can be patched up later – however that code turns out
to be generated by the compiler:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cp">#define PARAMETER_CONSTANT 0xFEEDBEEF</span>
<span class="cp">#define FUNCTION_CONSTANT 0xABAD1DEA</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">partial_template_function</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span><span class="n">FUNCTION_CONSTANT</span><span class="p">)((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">PARAMETER_CONSTANT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The funky-looking cast basically says “call a function pointer at
<code class="docutils literal notranslate"><span class="pre">FUNCTION_CONSTANT</span></code> with a pointer pointing to <code class="docutils literal notranslate"><span class="pre">PARAMETER_CONSTANT</span></code>”. Of
course, if you call this code as is, the program will most likely crash.
The idea is that this generates this code (IA32 assembly):</p>
<div class="highlight-objdump notranslate"><div class="highlight"><pre><span/><span class="mh">0f00deba</span> <span class="p">&lt;</span><span class="nf">partial_template_function</span><span class="p">&gt;:</span>
<span class="x">   0:    55                       push   %ebp</span>
<span class="x">   1:    89 e5                    mov    %esp,%ebp</span>
<span class="x">   3:    83 ec 18                 sub    $0x18,%esp</span>
<span class="x">   6:    c7 04 24 ef be ed fe     movl   $0xfeedbeef,(%esp)</span>
<span class="x">   d:    b8 ea 1d ad ab           mov    $0xabad1dea,%eax</span>
<span class="x">  12:    ff d0                    call   *%eax</span>
<span class="x">  14:    c9                       leave</span>
<span class="x">  15:    c3                       ret</span>
</pre></div>
</div>
<p>Even if you don’t know assembly, if you squint a little bit, you can clearly
see the magic constants defined in the C code above.  By writing a trivial
function to patch these magic values to something useful (such as a real
function or some real pointer argument):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">bool</span>
<span class="nf">patch_pointer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">code_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">code_len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">look_for</span><span class="p">,</span> <span class="kt">void</span>
<span class="o">*</span><span class="n">patch_with</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">code</span> <span class="o">=</span> <span class="n">code_addr</span><span class="p">;</span>
    <span class="kt">intptr_t</span> <span class="n">look</span> <span class="o">=</span> <span class="p">(</span><span class="kt">intptr_t</span><span class="p">)</span><span class="n">look_for</span><span class="p">;</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">intptr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">code</span><span class="p">)</span> <span class="o">==</span> <span class="n">look</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">union</span> <span class="p">{</span>
              <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">octet</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)];</span>
              <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
            <span class="p">}</span> <span class="n">patch</span><span class="p">;</span>

            <span class="n">patch</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">patch_with</span><span class="p">;</span>
            <span class="n">code</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">patch</span><span class="p">.</span><span class="n">octet</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">code</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">patch</span><span class="p">.</span><span class="n">octet</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">code</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">patch</span><span class="p">.</span><span class="n">octet</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
            <span class="n">code</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">patch</span><span class="p">.</span><span class="n">octet</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">code</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">code_len</span><span class="o">--</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And using it to patch the pointers in a page allocated with <code class="docutils literal notranslate"><span class="pre">mmap()</span></code>
(comments and error recovery have been ommitted for brevity; full source
code is linked below):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Partial</span> <span class="o">*</span>
<span class="nf">partial_new</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">Partial</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">func</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">));</span>
    <span class="cm">/* partial_template_function must be declared just before partial_new</span>
<span class="cm">     * so that caller_len is calculated correctly */</span>
    <span class="n">t</span><span class="o">-&gt;</span><span class="n">caller_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)((</span><span class="kt">intptr_t</span><span class="p">)</span><span class="n">partial_new</span> <span class="o">-</span>
          <span class="p">(</span><span class="kt">intptr_t</span><span class="p">)</span><span class="n">partial_template_function</span><span class="p">);</span>

    <span class="n">t</span><span class="o">-&gt;</span><span class="n">caller</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">caller_len</span><span class="p">,</span> <span class="n">PROT_WRITE</span> <span class="o">|</span> <span class="n">PROT_READ</span><span class="p">,</span>
          <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">caller</span><span class="p">,</span> <span class="n">partial_template_function</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">caller_len</span><span class="p">);</span>

    <span class="n">patch_pointer</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">caller</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">caller_len</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">FUNCTION_CONSTANT</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
    <span class="n">patch_pointer</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">caller</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">caller_len</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">PARAMETER_CONSTANT</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="n">mprotect</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">caller</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">caller_len</span><span class="p">,</span> <span class="n">PROT_EXEC</span> <span class="o">|</span> <span class="n">PROT_READ</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The end result will be a function that can be called without arguments –
which will magically call another function with a given parameter:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="kt">void</span>
<span class="nf">test</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Test called with data=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">Partial</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">partial_new</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x12341337</span><span class="p">);</span>
    <span class="n">atexit</span><span class="p">(</span><span class="n">partial_to_function</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Which, when executed, will print:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="gp">[leandro@navi /tmp]$</span> ./a.out
<span class="go">Test called with data=0x12341337</span>
</pre></div>
</div>
<p>So there you have it, <a class="reference external" href="https://en.wikipedia.org/wiki/Partial_application">partially applied functions</a> in C. Useful? Hardly.
Interesting?  I think so.  Fun?  Yup.</p>
<p>If you’d like to try, the full source code, with comments and error recovery
is available in this <a class="reference external" href="https://gist.github.com/lpereira/5062388">gist</a>.</p>
]]></description>
             <pubDate>Sat, 20 Jul 2013 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2012/11/11/mustache_templates_in_c.html</link>
            <guid>http://tia.mat.br/blog/html/2012/11/11/mustache_templates_in_c.html</guid>
            <title><![CDATA[Mustache templates in C]]></title>
            <description><![CDATA[<h1>Mustache templates in C</h1>
<p>Generating textual output is a lot easier with templates than it is with
handcrafted functions. And it is a lot easier in languages such as Python,
where things like introspection are easy and cheap. But that doesn’t
necessarily mean we can’t do that in C if we know where to look.</p>
<p>I’ve implemented a subset of <a class="reference external" href="http://mustache.github.com/">Mustache</a> templates in C that leverages some
tricks that makes template rendering both convenient and efficient. For
instance, if you have a template such as this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">Hello</span><span class="p">,</span> <span class="p">{{</span><span class="n">name</span><span class="p">}}</span><span class="o">!</span>
</pre></div>
</div>
<p>It can easily be rendered with the following code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">hello_t</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"World"</span>
<span class="p">};</span>
<span class="n">lwan_tpl_render</span><span class="p">(</span><span class="n">hello</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">hello</span></code> is the template that was previously compiled into a series of
simple instructions (such as <strong>append text</strong> or <strong>append the value of a
variable</strong>), and the second parameter is a structure containing the data
needed by the renderer.</p>
<p>My first thought to render these templates would involve the use of a hash
table. While reasonably efficient (even considering the overhead to create
and destroy the table every time the template had to be rendered), they’re
not first class citizens in C, and the usage would be pretty clumsy, to say
the least:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">hash_table</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">hash_table_new</span><span class="p">();</span>
<span class="n">hash_table_add</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="s">"name"</span><span class="p">,</span> <span class="s">"World"</span><span class="p">);</span>

<span class="n">lwan_tpl_render</span><span class="p">(</span><span class="n">hello</span><span class="p">,</span> <span class="n">ht</span><span class="p">);</span>

<span class="n">hash_table_free</span><span class="p">(</span><span class="n">ht</span><span class="p">);</span>
</pre></div>
</div>
<p>Instead, I’ve decided to go on another road: use standard C structures to
store the values in their native form, and then find a way to lookup these
values whenever necessary to render the template.</p>
<p>The first trick, then, was to use a C99 feature called <a class="reference external" href="http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Compound-Literals.html">compound literals</a>,
which is supported by GCC even in C89 mode. This trick allows the use of
<a class="reference external" href="http://www.run.montefiore.ulg.ac.be/~martin/resources/kung-f00.html">anonymous arrays</a>, among other things, and provides enough syntactic sugar
to conveniently group the template variables:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">lwan_tpl_render</span><span class="p">(</span><span class="n">hello</span><span class="p">,</span> <span class="p">(</span><span class="n">hello_t</span><span class="p">[])</span> <span class="p">{{</span>
  <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"World"</span>
<span class="p">}});</span>
</pre></div>
</div>
<p>Without a way to lookup which value to obtain from the structure, however,
this would not help much. Enter the second trick: the <code class="docutils literal notranslate"><span class="pre">offsetof(3)</span></code> macro,
which computes the offset of a field in a given structure. By storing this
offset alongside data type information, the value lookup is not only possible
but can also work with types different than strings:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">typedef</span> <span class="k">struct</span> <span class="n">hello_t</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> * The TPL_VAR_??? macros provides some convenience to declare each</span>
<span class="cm"> * descriptor. These expand to a declaration containing the name of</span>
<span class="cm"> * the variable as a string (used to validate the template during</span>
<span class="cm"> * compile time), the field offset, and pointers to functions that</span>
<span class="cm"> * convert the values to string and check if they're empty.</span>
<span class="cm"> *</span>
<span class="cm"> * The SENTINEL type is there so the template compiler knows when to</span>
<span class="cm"> * stop looking for descriptors, since of course you can have as</span>
<span class="cm"> many</span>
<span class="cm"> * fields as necessary.</span>
<span class="cm"> */</span>
<span class="n">lwan_var_descriptor_t</span> <span class="n">hello_descriptor</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">TPL_VAR_STR</span><span class="p">(</span><span class="n">hello_t</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span>
  <span class="n">TPL_VAR_INT</span><span class="p">(</span><span class="n">hello_t</span><span class="p">,</span> <span class="n">age</span><span class="p">),</span>
  <span class="n">TPL_VAR_SENTINEL</span>
<span class="p">};</span>
<span class="n">lwan_tpl_t</span> <span class="o">*</span><span class="n">hello</span><span class="p">;</span>
<span class="n">strbuf_t</span> <span class="o">*</span><span class="n">rendered</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * ``hello'' would usually be compiled once and kept around for</span>
<span class="cm"> * the whole duration of the program.</span>
<span class="cm"> */</span>
<span class="n">hello</span> <span class="o">=</span> <span class="n">lwan_tpl_compile</span><span class="p">(</span><span class="s">"hello.tpl"</span><span class="p">,</span> <span class="n">hello_descriptor</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Rendering the template then would be just the matter of calling</span>
<span class="cm"> * this function, which will output a ``strbuf_t''. The template</span>
<span class="cm"> * compiler estimates the starting size of this string buffer, so</span>
<span class="cm"> * rendering will incur in very few expensive reallocations, if</span>
<span class="cm"> * there are reallocations at all.</span>
<span class="cm"> */</span>
<span class="n">rendered</span> <span class="o">=</span> <span class="n">lwan_tpl_render</span><span class="p">(</span><span class="n">hello</span><span class="p">,</span> <span class="p">(</span><span class="n">hello_t</span><span class="p">[])</span> <span class="p">{{</span>
  <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"World"</span><span class="p">,</span>
  <span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">42</span>
<span class="p">}});</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strbuf_get_buffer</span><span class="p">(</span><span class="n">rendered</span><span class="p">));</span>
<span class="n">strbuf_free</span><span class="p">(</span><span class="n">rendered</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference external" href="https://github.com/lpereira/lwan/blob/wip/template.c">Code for this engine</a> is available in the <a class="reference external" href="https://github.com/lpereira/lwan/tree/wip/">wip branch</a> of my toy web
server, lwan. It is not currently used there, but it is built alongside the
main program and can be tested by invoking the generated <code class="docutils literal notranslate"><span class="pre">template</span></code>
executable.</p>
<p>Before using that in lwan, though, I’ll try to employ this <a class="reference external" href="http://dginasa.blogspot.com.br/2012/10/brainfuck-jit-compiler-in-around-155.html">nifty trick</a> to
JIT-compile the template and avoid some of the overhead where it really
matters. While at the same time possibly opening a whole can of worms from
the security standpoint, though – but it wouldn’t be fun without some risk,
would it? :)</p>
]]></description>
             <pubDate>Sun, 11 Nov 2012 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2012/10/27/programming_on_an_arduino_without_a_pc.html</link>
            <guid>http://tia.mat.br/blog/html/2012/10/27/programming_on_an_arduino_without_a_pc.html</guid>
            <title><![CDATA[Programming on an Arduino without a PC]]></title>
            <description><![CDATA[<h1>Programming on an Arduino without a PC</h1>
<p>I’ve attended this year’s <a class="reference external" href="http://softwarelivre.org/fisl13">FISL</a>, both as a booth attendee (at
<a class="reference external" href="http://profusion.mobi">ProFUSION</a>’s booth, demonstrating a few of our end-user-visible projects),
and as a speaker for my old <a class="reference external" href="http://github.com/lpereira/finf">FINF</a> project.</p>
<p>FINF is a <a class="reference external" href="http://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a>-like programming environment that I’ve written in my first
year at the college. It’s not the first compiler I wrote, but it was the
first that was actually fun to write. Some years later, I’ve decided to
rewrite it so that it would work on the <a class="reference external" href="http://www.arduino.cc">Arduino</a> – and that’s what I went
to FISL to talk about.</p>
<img alt="audience" class="align-center" src="https://i.imgur.com/AsCOr.jpg"/>
<p>Arduinos are traditionally programmed by using its IDE, in a language that
resembles C++. In fact, it is C++, but some of the (boring) details are
hidden. But, being C++, it’s bound to the slow write-compile-upload-test
procedures; there’s no interactive prompt, such as you have with Python or
the venerable 8-bit Microsoft Basic. And since Arduino is all about
experimentation, an interactive prompt is a must.</p>
<p>FINF is there to fill this gap. It is not a full <a class="reference external" href="http://en.wikipedia.org/wiki/Forth_(programming_language)">FORTH</a> implementation;
only a small subset of it is there, but it’s enough to blink some LEDs, make
some noise, and – if a video output shield is used – use the Arduino as an
8-bit computer! But, since user code actually runs on top of a very simple
virtual machine due to the <a class="reference external" href="http://en.wikipedia.org/wiki/Harvard_architecture">Harvard architecture</a> used by the AVR
microcontroller, it’s not possible to expand the interpreter without getting
dirt in your hands. Add that to the quite messy code, mix it with myself not
being a good marketer, and you have yet another failed open source project of
mine! :)</p>
<p>In any case, the <a class="reference external" href="https://docs.google.com/presentation/d/1w23aLeFgbvjztjtDIFcGTAl7ghlfxsxH_lW4Fyw8lzw/edit">slides</a> (in Portuguese) are available online.
Unfortunately, the presentation was not recorded, so if you were not there,
you’ve missed the great opportunity of seeing myself making a LED blink in
front of an audience.</p>
<p>(By the way, I’ll be talking during EFL Developer Day in Barcelona early next
month. If you’re there for LinuxCon/Embedded Linux Conference and would like
to join me for some beers, don’t hesitate to contact me!)</p>
]]></description>
             <pubDate>Sat, 27 Oct 2012 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2012/10/14/vectored_i_o_with_mmap___to_serve_files.html</link>
            <guid>http://tia.mat.br/blog/html/2012/10/14/vectored_i_o_with_mmap___to_serve_files.html</guid>
            <title><![CDATA[Vectored I/O with mmap() to serve files]]></title>
            <description><![CDATA[<h1>Vectored I/O with mmap() to serve files</h1>
<p>Previously, I’ve <a class="reference external" href="/posts/file_serving_with_few_syscalls/">improved file serving performance</a> in <a class="reference external" href="http://github.com/lpereira/lwan">lwan</a> by
dramatially cutting down on the number of system calls performed to serve a
file. However, for small files (&lt; 16KiB), the throughput drop from the
<code class="docutils literal notranslate"><span class="pre">hello</span></code> handler (which merely responds “Hello, World!”) was significant,
since lwan was still performing system calls to open, obtain the size, and
close the file.</p>
<p>I’ve experimented with userland caching before, but it never occurred to me
to use <code class="docutils literal notranslate"><span class="pre">mmap()</span></code>. For the unitiated, this system call offers a way to map a
file into memory, by giving a pointer to the process virtual memory space,
that, when dereferenced, will perform the necessary disk I/O if the pages
were not already present in the kernel buffers. <a class="reference external" href="https://en.wikipedia.org/wiki/Mmap">Wikipedia</a> has more details
about it. Using <code class="docutils literal notranslate"><span class="pre">mmap()</span></code> greatly simplifies caching code by relaying it to
the kernel, closer to where the low level buffers are.</p>
<p>By using a memory-mapped buffer and <a class="reference external" href="https://en.wikipedia.org/wiki/Vectored_I/O">writev()</a> (which the <code class="docutils literal notranslate"><span class="pre">hello</span></code> handler
uses through lwan’s abstractions), the file serving performance improved
about 60%! Before the optimization, <a class="reference external" href="https://github.com/lighttpd/weighttp">weighttp</a> would be able to make ~170000
requests/s. Now, ~286000 requests/s can be made. (That’s on my laptop, a Core
i7 2640m, with 8GiB of RAM and without spinning platters.)</p>
<p>Of course, introducing caching also introduces a lot of complexity. Not only
the file serving handler almost doubled its size (from 350 lines to 610
lines), but I’ve had to add a hash table implementation (with around 430
lines) and a directory watcher that uses <a class="reference external" href="https://en.wikipedia.org/wiki/Inotify">inotify</a> at around 150 lines of C
code. In the order of 840 lines of code to improve performance by about 60%.
About 30% more lines of code to improve performance in 60% – not bad,
methinks.</p>
<p>On the other hand, the cache mechanism brings shared mutable state. This is
protected by mutexes, of course, but I’m not sure if I got it right. One more
reason to <strong>not</strong> use lwan in production.</p>
<p>As a bonus to these things, lwan now offers <a class="reference external" href="https://en.wikipedia.org/wiki/Deflate">deflated</a> content for the files
in the cache when asked.</p>
]]></description>
             <pubDate>Sun, 14 Oct 2012 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2012/09/29/asynchronous_i_o_in_c_with_coroutines.html</link>
            <guid>http://tia.mat.br/blog/html/2012/09/29/asynchronous_i_o_in_c_with_coroutines.html</guid>
            <title><![CDATA[Asynchronous I/O in C with Coroutines]]></title>
            <description><![CDATA[<h1>Asynchronous I/O in C with Coroutines</h1>
<p>Writing asynchronous I/O code in C is kind of tedious, and often leads to a
callback hell. But it doesn’t have to be this way; if you have a main loop,
it’s quite simple to use <a class="reference external" href="https://en.wikipedia.org/wiki/Coroutine">coroutines</a> and write code in a soothing, old
school, synchronous way.</p>
<img alt="yodawg" class="align-center" src="https://i.imgur.com/dHCqj.jpg"/>
<p>Under POSIX, it’s also quite easy to implement coroutines, via the use of the
stuff contained in the <a class="reference external" href="https://en.wikipedia.org/wiki/Setcontext">ucontext.h</a> header. Unfortunately deprecated in
favor of threads, the functions and structures found in this header are one
of the unpopular gems in the POSIX C library.</p>
<div class="section" id="coroutines-in-lwan-my-toy-web-server">
<h2>Coroutines in lwan, my toy web server</h2>
<p>In <a class="reference external" href="http://github.com/lpereira/lwan">lwan</a>, there are <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code> worker threads, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of
logical CPUs. One thread is the <em>acceptor</em> thread, which accepts connections,
and gives control to the other <code class="docutils literal notranslate"><span class="pre">n</span></code> threads, which in turn do all the work
of receiving a request, parsing, and delivering the response.</p>
<p>Each of these worker threads can multiplex thousands of connections by
polling on events: so, for each worker thread, only one request can be
handled at a time. And, if one blocking operation (say, write to a socket)
would block, all other requests would wait for a response.</p>
<p>By <em>yielding</em> the coroutine at the right moments, lwan blocks only on calls
to <a class="reference external" href="http://linux.die.net/man/4/epoll">epoll(4)</a>. Whenever the socket can be written again, that coroutine is
resumed. The request handler function does not know what happened.</p>
</div>
<div class="section" id="implementing-coroutines-using-ucontext">
<h2>Implementing coroutines using ucontext</h2>
<p>As said earlier, POSIX offers some infrastructure that can be used to
implement coroutines or more powerful concepts, like <a class="reference external" href="https://en.wikipedia.org/wiki/Call-with-current-continuation">call/cc</a>. However,
they’re quite tricky to use, so it’s often a good idea to offer a thin
wrapper on top of them. The API used in lwan is the following (implementation
details omitted for brevity):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">coro_t</span> <span class="o">*</span><span class="nf">coro_new</span><span class="p">(</span><span class="n">coro_function_t</span> <span class="n">function</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">coro_free</span><span class="p">(</span><span class="n">coro_t</span> <span class="o">*</span><span class="n">coro</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">coro_resume</span><span class="p">(</span><span class="n">coro_t</span> <span class="o">*</span><span class="n">coro</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">coro_yield</span><span class="p">(</span><span class="n">coro_t</span> <span class="o">*</span><span class="n">coro</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="coroutine-allocation">
<h2>Coroutine allocation</h2>
<p>A coroutine is pretty much a simple data structure; the real implementation
has more fields, but they’re implementation details:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">coro_t_</span> <span class="p">{</span>
    <span class="n">coro_function_t</span> <span class="n">function</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

    <span class="n">ucontext_t</span> <span class="n">context</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">yield_value</span><span class="p">;</span>

    <span class="kt">char</span> <span class="n">stack</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>To allocate one, just allocate space for <code class="docutils literal notranslate"><span class="pre">sizeof(coro_t_)</span> <span class="pre">+</span> <span class="pre">stack_size</span></code>,
initialize the variables, and call <code class="docutils literal notranslate"><span class="pre">getcontext(&amp;coro-&gt;context)</span></code>. (These
context-swapping functions are weirdly-named in my opinion: <code class="docutils literal notranslate"><span class="pre">getcontext</span></code>
actually <em>saves</em> the current context into the variable pointed to by its sole
parameter.)</p>
<p>After that, one just need to set up the context so that it points to the
newly-allocated stack:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">coro</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_sp</span> <span class="o">=</span> <span class="n">coro</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">;</span>
<span class="n">coro</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_size</span> <span class="o">=</span> <span class="n">stack_size</span><span class="p">;</span>
<span class="n">coro</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">coro</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">uc_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div>
</div>
<p>And then call <code class="docutils literal notranslate"><span class="pre">makecontext()</span></code> so that the coroutine entry point can be
called when resuming the coroutine. (Another weirdly-named function. No
wonder why this thing is quite unpopular.) This function takes a variable
number of parameters, each one being a 32-bit integer value. I don’t know why
a <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> wasn’t used instead – so, on 64-bit, I use an union to break a
pointer into two 32-bit components:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">union</span> <span class="n">ptr_splitter</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">part</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>That’s it to allocate a coroutine.</p>
</div>
<div class="section" id="freeing-a-coroutine">
<h2>Freeing a coroutine</h2>
<p>Just free the coroutine’s <code class="docutils literal notranslate"><span class="pre">coro_t</span></code> structure. Lwan’s implementation does
run the deferred statements at this moment.</p>
</div>
<div class="section" id="resuming-a-coroutine">
<h2>Resuming a coroutine</h2>
<p>Resuming a coroutine pretty simple: one has to save the current context, swap
the current context with the coroutine context, and when the coroutine
yields, return the contexts where they were.</p>
</div>
<div class="section" id="yielding-from-a-coroutine">
<h2>Yielding from a coroutine</h2>
<p>To yield from a coroutine, just save <code class="docutils literal notranslate"><span class="pre">value</span></code> into <code class="docutils literal notranslate"><span class="pre">coro_t</span></code>’s
<code class="docutils literal notranslate"><span class="pre">yield_value</span></code> field, and make a call to <code class="docutils literal notranslate"><span class="pre">swapcontext()</span></code>, swapping the
current coroutine stack with the context that was active when the coroutine
was resumed (which happens to be the routine that resumes a coroutine – which
now cleans up and return to whoever called it, most probably the main loop).
<code class="docutils literal notranslate"><span class="pre">value</span></code> is now available to whoever called <code class="docutils literal notranslate"><span class="pre">coro_resume()</span></code> and is used in
lwan to determine if a coroutine should be resumed.</p>
</div>
<div class="section" id="using-the-coroutines">
<h2>Using the coroutines</h2>
<p>From the user perspective, it’s just like calling some blocking function:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">lwan_sendfile</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">,</span> <span class="n">file_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_bytes</span><span class="p">);</span>
</pre></div>
</div>
<p>Behind the scenes, <code class="docutils literal notranslate"><span class="pre">lwan_sendfile</span></code> is actually doing this (error handling
omitted for brevity):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">while</span> <span class="p">(</span><span class="n">sent_bytes</span> <span class="o">&lt;</span> <span class="n">total_bytes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">read_bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">file_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">);</span>
    <span class="n">sent_bytes</span> <span class="o">+=</span> <span class="n">read_bytes</span><span class="p">;</span>
    <span class="n">write</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">read_bytes</span><span class="p">);</span>

    <span class="n">coro_yield</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(Of course, if available, <a class="reference external" href="http://linux.die.net/man/2/sendfile">sendfile(2)</a> is used instead in a similar
fashion, but this better illustrates the point.)</p>
<p>Whenever the coroutine yields, it goes back to the main loop, which is now
free to resume another coroutine. Ideally, one could yield to be resumed on a
certain condition (instead of assuming that the condition is just “the socket
is ready to be written to”), but this isn’t possible in the current
implementation.</p>
<p>For implementation simplicity, the same timer code that is used for keep-
alive connections is used for coroutines, so that they don’t linger
indefinitely.</p>
</div>
<div class="section" id="implementation-details">
<h2>Implementation details</h2>
<ul class="simple">
<li><p>On 64-bit, hand-tuned assembly versions of <code class="docutils literal notranslate"><span class="pre">ucontext</span></code> routines are
used. These routines avoid saving and restoring the signal mask (avoiding
two roundtrips to the kernel), and does not save the floating point
registers.</p></li>
<li><p>Also, on 64-bit, resuming a coroutine is orders of magnitude faster,
since not everything is copied when switching contexts.</p></li>
<li><p>Swapping stacks makes tools like <a class="reference external" href="http://valgrind.org/">Valgrind</a> get pretty crazy. Lwan’s
implementation uses Valgrind-provided macros that marks the newly-
allocated blocks (from the heap) as stacks.</p></li>
<li><p>The real implementation has a <code class="docutils literal notranslate"><span class="pre">coro_switcher_t</span></code> data structure.
This structure is used to both avoid race conditions when swapping
coroutines in different threads, but also to maintain coroutine state
from different threads.</p></li>
</ul>
<p>There are other details that were ommitted from this post. Lwan’s source code
is small enough it can digested easily, and if you’re not sleeping already,
check it out.</p>
</div>
<div class="section" id="closing-notes">
<h2>Closing notes</h2>
<p>Although not as performant as the traditional way of using callbacks
(resuming and yielding from coroutines are a little bit more expensive than
calling a function), coroutines brings a lot of simplicity when writing
asynchronous code.</p>
<p>The example shown here might not be expressive, but imagine an application
fetching data from a key-value store from another machine: there might be
dozens of calls to the database to build a web page, which would be pretty
difficult to handle if there were dozen callbacks. With a synchronous style,
that would be a lot easier to write and maintain.</p>
<p>One could argue that the same thing could be done in threads. But creating
more threads than there are processors will often hurt performance (for
various reasons) in noticeable ways. Also, coroutines are cheaper on the
memory requirements: in Lwan, they sport 16KiB of stack space and it takes a
little bit more than a <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> to set them up.</p>
<p>I believe we should stop using callbacks for asynchronous I/O and use things
like this. Even if <code class="docutils literal notranslate"><span class="pre">ucontext.h</span></code> is deprecated from POSIX, the functions a
fairly trivial to write (even in assembly language) – actually, encouraged,
given that <code class="docutils literal notranslate"><span class="pre">swapcontext()</span></code> and <code class="docutils literal notranslate"><span class="pre">getcontext()</span></code> makes often unnecessary
system calls.</p>
</div>
]]></description>
             <pubDate>Sat, 29 Sep 2012 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2012/09/21/presenting_easyui.html</link>
            <guid>http://tia.mat.br/blog/html/2012/09/21/presenting_easyui.html</guid>
            <title><![CDATA[Presenting EasyUI]]></title>
            <description><![CDATA[<h1>Presenting EasyUI</h1>
<div class="section" id="introduction">
<h2>Introduction</h2>
<p>I’ve been working at <a class="reference external" href="http://profusion.mobi">ProFUSION</a> on a project called EasyUI for the past few
months. This library is based on Google’s <a class="reference external" href="http://code.google.com/p/v8">V8</a> JavaScript engine and the
<a class="reference external" href="http://enlightenment.org">Enlightenment Foundation Libraries</a> and aims to diminish the hurdle in
writing native applications for the forthcoming <a class="reference external" href="http://tizen.org">Tizen</a> platform.</p>
<p>EFL itself – specially its UI toolkit, Elementary – follows a pretty
traditional approach to creating applications: the library user must know how
to join all bits and pieces, which often leads to common code that is written
and rewritten in each new application.</p>
<p>By observing common patterns and providing an uniform <a class="reference external" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> interface,
EasyUI parts from this traditional approach and offers a new way to create
applications using EFL.</p>
<p>Before talking about code, let me show a video (best viewed in HD) of some
sample EasyUI applications being executed:</p>
<iframe src="https://www.youtube.com/embed/NsRoj3s2Tok" style="border: 0; height: 345px; width: 560px">
</iframe></div>
<div class="section" id="brief-overview-of-an-easyui-app">
<h2>Brief overview of an EasyUI app</h2>
<dl class="simple">
<dt>An app begins with a simple call to <code class="docutils literal notranslate"><span class="pre">EUI.app()</span></code>, passing at least one parameter:</dt><dd><p>the main view-controller. The other parameter is an optional object that
contains application settings, such as the theme or window titles. EasyUI
applications are contained inside one window only, since the main focus
are apps for mobile devices with stacked lists and the eventual popup
that appears on top of the content.</p>
</dd>
</dl>
<p>The code below shows a typical controller-view; explanation will follow.</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span/><span class="nx">MainController</span> <span class="o">=</span> <span class="nx">EUI</span><span class="p">.</span><span class="nx">ListController</span><span class="p">({</span>
    <span class="nx">title</span><span class="o">:</span> <span class="s1">'My Favorite Fruits'</span><span class="p">,</span>
    <span class="nx">model</span><span class="o">:</span> <span class="k">new</span> <span class="nx">ArrayModel</span><span class="p">([</span><span class="s1">'Pear'</span><span class="p">,</span> <span class="s1">'Banana'</span><span class="p">,</span> <span class="s1">'Uvaia'</span><span class="p">]),</span>
    <span class="nx">itemAtIndex</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span>
                    <span class="nx">text</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">itemAtIndex</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
            <span class="p">};</span>
    <span class="p">},</span>
    <span class="nx">selectedItemAtIndex</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">fruit</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">itemAtIndex</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">pushController</span><span class="p">(</span><span class="k">new</span> <span class="nx">FruitController</span><span class="p">(</span><span class="nx">fruit</span><span class="p">));</span>
    <span class="p">},</span>
    <span class="nx">navigationBarItems</span><span class="o">:</span> <span class="p">{</span> <span class="nx">right</span><span class="o">:</span> <span class="s1">'Add'</span> <span class="p">},</span>
    <span class="nx">selectedNavigationBarItem</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">item</span> <span class="o">===</span> <span class="s1">'Add'</span><span class="p">)</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">pushController</span><span class="p">(</span><span class="k">new</span> <span class="nx">AddFruitController</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Lots of things happens with the declaration of <code class="docutils literal notranslate"><span class="pre">MainController</span></code>. Of note:</p>
<ul class="simple">
<li><p>As opposed to the traditional way of laying out components on screen
with EFL, controllers implements the basic user interface and the
application developer focuses only on defining behavior.</p></li>
<li><p>Attributes can be functions, which will be called whenever EasyUI
needs them. For instance, one could change the title based on how many
fruits were in the model, by writing a <code class="docutils literal notranslate"><span class="pre">title</span></code> function like so:</p></li>
</ul>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span/><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">"My Favorite Fruit"</span><span class="p">;</span>
    <span class="k">return</span> <span class="s2">"My Favourite Fruits"</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MainController</span></code> is derived from <code class="docutils literal notranslate"><span class="pre">ListController</span></code>. This means
that it follows a <em>collection</em> contract, and must implement methods like
<code class="docutils literal notranslate"><span class="pre">itemAtIndex</span></code> and <code class="docutils literal notranslate"><span class="pre">selectedItemAtIndex</span></code>, as well as providing a
<code class="docutils literal notranslate"><span class="pre">model</span></code> attribute.</p></li>
<li><p>One could simply swap <code class="docutils literal notranslate"><span class="pre">ListController</span></code> for <code class="docutils literal notranslate"><span class="pre">GridController</span></code> if a
grid layout were to be more appropriate for this particular application.</p></li>
<li><p>In addition to the basic <em>contract</em>, controllers might sign for more;
for instance by declaring <code class="docutils literal notranslate"><span class="pre">navigationBarItems</span></code>, one is required to
implement <code class="docutils literal notranslate"><span class="pre">selectedNavigationBarItem</span></code>.</p></li>
</ul>
<p>Behind the scenes, the framework will initialize the EFL, create the window
and required widgets, listen to callbacks – and call the application code in
appropriate moments.</p>
<p>The next post in this series will show the anatomy of a <a class="reference external" href="http://reddit.com/">Reddit</a> client.</p>
</div>
<div class="section" id="show-me-the-code">
<h2>Show me the code</h2>
<p>We’re just working on some licensing issues right now. This should be
released as an open source project. As soon as this is cleared up, EasyUI
should hit Enlightenment’s SVN repository.</p>
</div>
]]></description>
             <pubDate>Fri, 21 Sep 2012 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2012/08/12/file_serving_with_few_system_calls.html</link>
            <guid>http://tia.mat.br/blog/html/2012/08/12/file_serving_with_few_system_calls.html</guid>
            <title><![CDATA[File serving with few system calls]]></title>
            <description><![CDATA[<h1>File serving with few system calls</h1>
<p>When I first wrote <a class="reference external" href="http://github.com/lpereira/lwan">lwan</a>, file serving was not a primary goal. I’ve added
this capability later, never giving much thought to the number of system
calls required to serve one file. As a result, static file serving was quite
slow compared to “hello world” requests. Bored one day, I’ve decided to speed
this as much as I could.</p>
<p>Before optimizing, serving a file would look like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="o">&lt;</span><span class="p">...</span> <span class="n">epoll_wait</span> <span class="n">resumed</span><span class="o">&gt;</span> <span class="p">{{</span><span class="n">EPOLLIN</span><span class="p">,</span> <span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">u64</span><span class="o">=</span><span class="mi">8</span><span class="p">}}},</span> <span class="mi">16383</span><span class="p">,</span>
<span class="mi">4294967295</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">rt_sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">"GET / HTTP/1.0</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">getcwd</span><span class="p">(</span><span class="s">"/home/leandro/git/lwan/build"</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span> <span class="o">=</span> <span class="mi">29</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">"/home/leandro/git/lwan/build/files_root"</span><span class="p">,</span>
<span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFLNK</span><span class="o">|</span><span class="mo">0777</span><span class="p">,</span> <span class="n">st_size</span><span class="o">=</span><span class="mi">33</span><span class="p">,</span> <span class="p">...})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">readlink</span><span class="p">(</span><span class="s">"/home/leandro/git/lwan/build/files_root"</span><span class="p">,</span>
<span class="s">"/home/leandro/git/blotest/output/"</span><span class="p">,</span> <span class="mi">4095</span><span class="p">)</span> <span class="o">=</span> <span class="mi">33</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">"/home"</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="mo">0755</span><span class="p">,</span> <span class="n">st_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="p">...})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">"/home/leandro"</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="mo">0755</span><span class="p">,</span> <span class="n">st_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="p">...})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">"/home/leandro/git"</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="mo">0775</span><span class="p">,</span> <span class="n">st_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="p">...})</span>
<span class="o">=</span> <span class="mi">0</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">"/home/leandro/git/blotest"</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="mo">0755</span><span class="p">,</span>
<span class="n">st_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="p">...})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">"/home/leandro/git/blotest/output"</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="mo">0775</span><span class="p">,</span>
<span class="n">st_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="p">...})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">getcwd</span><span class="p">(</span><span class="s">"/home/leandro/git/lwan/build"</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span> <span class="o">=</span> <span class="mi">29</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">"/home/leandro/git/lwan/build/files_root"</span><span class="p">,</span>
<span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFLNK</span><span class="o">|</span><span class="mo">0777</span><span class="p">,</span> <span class="n">st_size</span><span class="o">=</span><span class="mi">33</span><span class="p">,</span> <span class="p">...})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">readlink</span><span class="p">(</span><span class="s">"/home/leandro/git/lwan/build/files_root"</span><span class="p">,</span>
<span class="s">"/home/leandro/git/blotest/output/"</span><span class="p">,</span> <span class="mi">4095</span><span class="p">)</span> <span class="o">=</span> <span class="mi">33</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">"/home"</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="mo">0755</span><span class="p">,</span> <span class="n">st_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="p">...})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">"/home/leandro"</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="mo">0755</span><span class="p">,</span> <span class="n">st_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="p">...})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">"/home/leandro/git"</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="mo">0775</span><span class="p">,</span> <span class="n">st_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="p">...})</span>
<span class="o">=</span> <span class="mi">0</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">"/home/leandro/git/blotest"</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="mo">0755</span><span class="p">,</span>
<span class="n">st_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="p">...})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">"/home/leandro/git/blotest/output"</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="mo">0775</span><span class="p">,</span>
<span class="n">st_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="p">...})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">open</span><span class="p">(</span><span class="s">"/home/leandro/git/blotest/output"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_NOATIME</span><span class="p">)</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">fstat</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="mo">0775</span><span class="p">,</span> <span class="n">st_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="p">...})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">close</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>                    <span class="o">=</span> <span class="mi">0</span>
<span class="n">open</span><span class="p">(</span><span class="s">"/home/leandro/git/blotest/output/index.html"</span><span class="p">,</span>
<span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_NOATIME</span><span class="p">)</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">fstat</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFREG</span><span class="o">|</span><span class="mo">0664</span><span class="p">,</span> <span class="n">st_size</span><span class="o">=</span><span class="mi">13200</span><span class="p">,</span> <span class="p">...})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">SOL_TCP</span><span class="p">,</span> <span class="n">TCP_CORK</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">write</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">"HTTP/1.0 200 OK</span><span class="se">\r\n</span><span class="s">Content-Length:"</span><span class="p">...,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">fadvise64</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">13200</span><span class="p">,</span> <span class="n">POSIX_FADV_SEQUENTIAL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">sendfile</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1400</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">1400</span>
<span class="n">epoll_ctl</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="p">{</span><span class="n">EPOLLOUT</span><span class="o">|</span><span class="n">EPOLLERR</span><span class="o">|</span><span class="mh">0x2000</span><span class="p">,</span> <span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
<span class="n">u64</span><span class="o">=</span><span class="mi">8</span><span class="p">}})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">epoll_wait</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">{{</span><span class="n">EPOLLOUT</span><span class="p">,</span> <span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">u64</span><span class="o">=</span><span class="mi">8</span><span class="p">}}},</span> <span class="mi">16383</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">sendfile</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1400</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">1400</span>
<span class="n">epoll_wait</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">{{</span><span class="n">EPOLLOUT</span><span class="p">,</span> <span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">u64</span><span class="o">=</span><span class="mi">8</span><span class="p">}}},</span> <span class="mi">16383</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">sendfile</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1400</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">1400</span>
<span class="n">epoll_wait</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">{{</span><span class="n">EPOLLOUT</span><span class="p">,</span> <span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">u64</span><span class="o">=</span><span class="mi">8</span><span class="p">}}},</span> <span class="mi">16383</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">sendfile</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1400</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">1400</span>
<span class="n">epoll_wait</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">{{</span><span class="n">EPOLLOUT</span><span class="p">,</span> <span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">u64</span><span class="o">=</span><span class="mi">8</span><span class="p">}}},</span> <span class="mi">16383</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">sendfile</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1400</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">1400</span>
<span class="n">epoll_wait</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">{{</span><span class="n">EPOLLOUT</span><span class="p">,</span> <span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">u64</span><span class="o">=</span><span class="mi">8</span><span class="p">}}},</span> <span class="mi">16383</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">sendfile</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1400</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">1400</span>
<span class="n">epoll_wait</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">{{</span><span class="n">EPOLLOUT</span><span class="p">,</span> <span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">u64</span><span class="o">=</span><span class="mi">8</span><span class="p">}}},</span> <span class="mi">16383</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">sendfile</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1400</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">1400</span>
<span class="n">epoll_wait</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">{{</span><span class="n">EPOLLOUT</span><span class="p">,</span> <span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">u64</span><span class="o">=</span><span class="mi">8</span><span class="p">}}},</span> <span class="mi">16383</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">sendfile</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1400</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">1400</span>
<span class="n">epoll_wait</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">{{</span><span class="n">EPOLLOUT</span><span class="p">,</span> <span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">u64</span><span class="o">=</span><span class="mi">8</span><span class="p">}}},</span> <span class="mi">16383</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">sendfile</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1400</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">1400</span>
<span class="n">epoll_wait</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">{{</span><span class="n">EPOLLOUT</span><span class="p">,</span> <span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">u64</span><span class="o">=</span><span class="mi">8</span><span class="p">}}},</span> <span class="mi">16383</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">sendfile</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1400</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">600</span>
<span class="n">close</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>                    <span class="o">=</span> <span class="mi">0</span>
<span class="n">epoll_ctl</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="p">{</span><span class="n">EPOLLIN</span><span class="o">|</span><span class="n">EPOLLERR</span><span class="o">|</span><span class="n">EPOLLET</span><span class="o">|</span><span class="mh">0x2000</span><span class="p">,</span>
<span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">u64</span><span class="o">=</span><span class="mi">8</span><span class="p">}})</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">close</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>                    <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Yes. That many system calls – I was not kidding when I said that file serving
was added as an afterthought. After some experiments, I’ve managed to turn
that mess into this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="o">&lt;</span><span class="p">...</span> <span class="n">epoll_wait</span> <span class="n">resumed</span><span class="o">&gt;</span> <span class="p">{{</span><span class="n">EPOLLIN</span><span class="p">,</span> <span class="p">{</span><span class="n">u32</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">u64</span><span class="o">=</span><span class="mi">9</span><span class="p">}}},</span> <span class="mi">16383</span><span class="p">,</span>
<span class="mi">4294967295</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">read</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="s">"GET / HTTP/1.0</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">newfstatat</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s">"index.html"</span><span class="p">,</span> <span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFREG</span><span class="o">|</span><span class="mo">0664</span><span class="p">,</span> <span class="n">st_size</span><span class="o">=</span><span class="mi">13200</span><span class="p">,</span>
<span class="p">...},</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">openat</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s">"index.html"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_NOATIME</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">sendto</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="s">"HTTP/1.0 200 OK</span><span class="se">\r\n</span><span class="s">Content-Length:"</span><span class="p">...,</span> <span class="mi">223</span><span class="p">,</span> <span class="n">MSG_MORE</span><span class="p">,</span>
<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">223</span>
<span class="n">fadvise64</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">13200</span><span class="p">,</span> <span class="n">POSIX_FADV_SEQUENTIAL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">sendfile</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">13200</span><span class="p">)</span> <span class="o">=</span> <span class="mi">13200</span>
<span class="n">close</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>                   <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Ah, much better! This was a result of these steps:</p>
<ol class="arabic simple">
<li><p>Caching the root directory information. This is mainly its
<code class="docutils literal notranslate"><span class="pre">realpath()</span></code> and an open file descriptor to the directory.</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">realpath()</span></code> result is used with a <code class="docutils literal notranslate"><span class="pre">strncmp()</span></code> after so that requests to file outside the root directory are not served successfully. The string length for the root path is also calculated only once.</p></li>
<li><p>The astute reader will notice the usage of the Linux-only <code class="docutils literal notranslate"><span class="pre">openat()</span></code> and <code class="docutils literal notranslate"><span class="pre">newfstatat()</span></code> system calls. These <code class="docutils literal notranslate"><span class="pre">-at()</span></code> variants perform much like their standard ones, but they work relative to the directory pointed to the file descriptor passed as the first parameter, avoiding some expensive path-to-inode conversions.</p></li>
</ul>
</li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">sendto()</span></code> with <code class="docutils literal notranslate"><span class="pre">MSG_MORE</span></code> flag instead of using
<code class="docutils literal notranslate"><span class="pre">TCP_CORK</span></code> flag. This makes for two less roundtrips to the kernel to
set a socket option.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">sendfile()</span></code> with the whole file instead of sending it in
chunks, to avoid coroutine context switches. <code class="docutils literal notranslate"><span class="pre">sendfile()</span></code> might still
block, but in this case, the coroutine will yield and the next time, try
to send a smaller chunk.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">-at()</span></code> version of system calls are also being used by a
replacement <code class="docutils literal notranslate"><span class="pre">realpath()</span></code> routine that I’ve adapted from <a class="reference external" href="http://www.gnu.org/software/libc/">glibc</a>. This
improved the performance as well by not only reducing the number of
system calls (the standard <code class="docutils literal notranslate"><span class="pre">realpath()</span></code> will perform a <code class="docutils literal notranslate"><span class="pre">lstat()</span></code> for
every path component, whereas this version will only perform
<code class="docutils literal notranslate"><span class="pre">newfstatat()</span></code> for relative components), but also using the lighter
<code class="docutils literal notranslate"><span class="pre">-at()</span></code> variants.</p></li>
</ol>
<p>These improvements resulted in <em>very low overhead</em> while serving files. In
fact, compared to a simple <em>hello world</em> handler and file serving – without
keep-alive – the performance drop even comparing the I/O involved is about
5%.</p>
]]></description>
             <pubDate>Sun, 12 Aug 2012 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2012/08/11/deferred_statements_in_c.html</link>
            <guid>http://tia.mat.br/blog/html/2012/08/11/deferred_statements_in_c.html</guid>
            <title><![CDATA[Deferred statements in C]]></title>
            <description><![CDATA[<h1>Deferred statements in C</h1>
<p><a class="reference external" href="http://golang.org">Golang</a> has a lot of nice features – and one I found pretty interesting is
called <a class="reference external" href="http://blog.golang.org/2010/08/defer-panic-and-recover.html">deferred statements</a>. This can be implemented in C++ pretty easily
through <a class="reference external" href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>, but in C we’re pretty much out of luck. Or are we?</p>
<p>In <a class="reference external" href="http://github.com/lpereira/lwan">lwan</a>, I’m using my own home-cooked <a class="reference external" href="https://en.wikipedia.org/wiki/Coroutine">coroutine</a> implementation. All
requests are handled by coroutines, so that it makes easy to condition the
execution of deferred statements with the cleanup of a coroutine. And that’s
what I did, by implementing <code class="docutils literal notranslate"><span class="pre">coro_defer()</span></code>, which adds hooks that will be
called sequentially by <code class="docutils literal notranslate"><span class="pre">coro_free()</span></code>.</p>
<p>This can be used for various purposes, including garbage collection and other
miscellaneous cleanup code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="kt">void</span><span class="o">*</span> <span class="nf">coro_malloc</span><span class="p">(</span><span class="n">coro_t</span> <span class="o">*</span><span class="n">coro</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
            <span class="n">coro_defer</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">coro_strdup</span><span class="p">(</span><span class="n">coro_t</span> <span class="o">*</span><span class="n">coro</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">dup</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dup</span><span class="p">)</span>
            <span class="n">coro_defer</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">dup</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">coro_open</span><span class="p">(</span><span class="n">coro_t</span> <span class="o">*</span><span class="n">coro</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">coro_defer</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">close</span><span class="p">,</span> <span class="n">INT_TO_PTR</span><span class="p">(</span><span class="n">fd</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This way, one can easily allocate memory, lock mutexes, open files – and
leave the cleanup to <a class="reference external" href="http://github.com/lpereira/lwan">lwan</a>.</p>
]]></description>
             <pubDate>Sat, 11 Aug 2012 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2012/08/10/hash_trie.html</link>
            <guid>http://tia.mat.br/blog/html/2012/08/10/hash_trie.html</guid>
            <title><![CDATA[Hash trie]]></title>
            <description><![CDATA[<h1>Hash trie</h1>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Trie">Tries</a> are very useful data structures if you need to perform longest
subprefix matching. Unfortunately, simple implementations uses a lot of
memory, which is often solved by collapsing common prefixes in a single node
(like a <a class="reference external" href="https://en.wikipedia.org/wiki/Radix_tree">Radix tree</a>). However, this adds to the implementation complexity,
which is something I like to avoid.</p>
<p><a class="reference external" href="http://github.com/lpereira/lwan">Lwan</a>’s original trie implementation required 256 pointers per trie node
(one per possible byte). This is not only wasteful, but also meant lwan would
get a lot of cache misses.</p>
<p>Instead of just using a <a class="reference external" href="https://en.wikipedia.org/wiki/Radix_tree">Radix tree</a>, I decided to keep the same basic
implementation but lower the number of pointers per node to just 8 – and hash
each key byte by calculating <code class="docutils literal notranslate"><span class="pre">MOD</span> <span class="pre">8</span></code>. This was a very cheap optimization,
which works pretty well.</p>
<p>But this optimization leads to the same problem found in <a class="reference external" href="https://en.wikipedia.org/wiki/Hash_table">hash tables</a>:
<a class="reference external" href="https://en.wikipedia.org/wiki/Collision_(computer_science)">collisions</a>. The problem is minimized by the fact that collisions can only
happen when using keys with the same length – which is uncommon in the basic
use case for these tries in <a class="reference external" href="http://github.com/lpereira/lwan">lwan</a>: matching URLs by their prefix to
determine which handler to call.</p>
<p>Nonetheless, this is easily fixed by adding a linked list to each leaf node.
To avoid having to perform one last string comparison if there’s just one
node in this linked list (and hence no collisions), <a class="reference external" href="http://github.com/lpereira/lwan">lwan</a>’s trie assume it
was a match.</p>
]]></description>
             <pubDate>Fri, 10 Aug 2012 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2012/08/09/string_switch_in_c.html</link>
            <guid>http://tia.mat.br/blog/html/2012/08/09/string_switch_in_c.html</guid>
            <title><![CDATA[String switch in C]]></title>
            <description><![CDATA[<h1>String switch in C</h1>
<p>C’s <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement is very powerful. However, it can’t be used with
strings, only with constant integral types. This is understandable, since
strings in C are merely arrays – they’re not first-class citizens.</p>
<p>There are cases where such statement would be useful for strings. Here’s a
trick I’m employing in <a class="reference external" href="http://github.com/lpereira/lwan">lwan</a> to avoid calling the <code class="docutils literal notranslate"><span class="pre">strcmp</span></code> family of
functions in some hot paths. This exploits the notion that strings are just
an array of bytes – and by casting them to a pointer to a 32-bit integer, and
dereferencing this pointer, we’ll be able to perform a switch statement on
very small strings (such as file extensions, which are usually comprised of
four characters, including the dot).</p>
<p>C also supports multicharacters integral constants. However, because of
endianess concerns, GCC warns by default when <code class="docutils literal notranslate"><span class="pre">-Wall</span> <span class="pre">-Wextra</span></code> is used with
these constants. My solution was to just use a macro in conjuntion with an
<code class="docutils literal notranslate"><span class="pre">enum</span></code>, to create the constant integral types expected by the compiler.</p>
<p>The code below, copied directly from <a class="reference external" href="http://github.com/lpereira/lwan">lwan</a>, illustrates an usage of this
<code class="docutils literal notranslate"><span class="pre">STRING_SWITCH</span></code> statement:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="cp">#define STRING_SWITCH_L(s) switch (*((int32_t *)(s)) | 0x20202020)</span>
<span class="cp">#define MULTICHAR_CONSTANT(a,b,c,d) ((int32_t)((a) | (b) &lt;&lt; 8 | (c)</span>
<span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">))</span>

<span class="k">enum</span> <span class="p">{</span>
    <span class="n">EXT_JPG</span> <span class="o">=</span> <span class="n">MULTICHAR_CONSTANT_L</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span><span class="sc">'j'</span><span class="p">,</span><span class="sc">'p'</span><span class="p">,</span><span class="sc">'g'</span><span class="p">),</span>
    <span class="n">EXT_PNG</span> <span class="o">=</span> <span class="n">MULTICHAR_CONSTANT_L</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span><span class="sc">'p'</span><span class="p">,</span><span class="sc">'n'</span><span class="p">,</span><span class="sc">'g'</span><span class="p">),</span>
    <span class="n">EXT_HTM</span> <span class="o">=</span> <span class="n">MULTICHAR_CONSTANT_L</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span><span class="sc">'h'</span><span class="p">,</span><span class="sc">'t'</span><span class="p">,</span><span class="sc">'m'</span><span class="p">),</span>
    <span class="n">EXT_CSS</span> <span class="o">=</span> <span class="n">MULTICHAR_CONSTANT_L</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span><span class="sc">'c'</span><span class="p">,</span><span class="sc">'s'</span><span class="p">,</span><span class="sc">'s'</span><span class="p">),</span>
    <span class="n">EXT_TXT</span> <span class="o">=</span> <span class="n">MULTICHAR_CONSTANT_L</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span><span class="sc">'t'</span><span class="p">,</span><span class="sc">'x'</span><span class="p">,</span><span class="sc">'t'</span><span class="p">),</span>
    <span class="n">EXT_JS</span>  <span class="o">=</span> <span class="n">MULTICHAR_CONSTANT_L</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span><span class="sc">'j'</span><span class="p">,</span><span class="sc">'s'</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
<span class="p">}</span> <span class="n">lwan_mime_ext_t</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">lwan_determine_mime_type_for_file_name</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">file_name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">last_dot</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="sc">'.'</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="o">!</span><span class="n">last_dot</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>

    <span class="n">STRING_SWITCH_L</span><span class="p">(</span><span class="n">last_dot</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">EXT_CSS</span><span class="p">:</span> <span class="k">return</span> <span class="s">"text/css"</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">EXT_HTM</span><span class="p">:</span> <span class="k">return</span> <span class="s">"text/html"</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">EXT_JPG</span><span class="p">:</span> <span class="k">return</span> <span class="s">"image/jpeg"</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">EXT_JS</span><span class="p">:</span>  <span class="k">return</span> <span class="s">"application/javascript"</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">EXT_PNG</span><span class="p">:</span> <span class="k">return</span> <span class="s">"image/png"</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">EXT_TXT</span><span class="p">:</span> <span class="k">return</span> <span class="s">"text/plain"</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">fallback</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"application/octet-stream"</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">STRING_SWITCH_L</span></code> performs a bitwise OR with the 32-bit integral
value – this is a fast means of lowering the case of four characters at once.</p>
<p>This kind of switch statement is used in <a class="reference external" href="http://github.com/lpereira/lwan">lwan</a> to match HTTP headers and
HTTP methods, and also the naïve file extension to MIME-Type conversion code
shown above.</p>
]]></description>
             <pubDate>Thu, 09 Aug 2012 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://tia.mat.br/blog/html/2012/02/13/fosdem_2012.html</link>
            <guid>http://tia.mat.br/blog/html/2012/02/13/fosdem_2012.html</guid>
            <title><![CDATA[FOSDEM 2012]]></title>
            <description><![CDATA[<h1>FOSDEM 2012</h1>
<p>Last week I was in Belgium, attending the Free and Open Source Developers
European Meeting — FOSDEM, for short. This conference is held every year and
gathers people from all around the globe to discuss and publish FOSS-related
matters. Belgian beer, waffles, french fries, and sub-zero temperatures were
also in the agenda.</p>
<img alt="groupphoto" class="align-center" src="https://i.imgur.com/ufLRC.jpg"/>
<p>I talked briefly about testing in WebKit EFL, after the required tools have
been implemented last year, and how it affected the quality of the port.
Although I could broadcast what I was there for, the need to improve my
public-speaking skills (specially in a foreign language) surely exists; I
guess that the only way to improve this is practice. One could say I traveled
a long distance just to talk fifteen minutes about software testing, but such
places have a lot more to offer.</p>
<p>I’ve met a lot of people this time around (I’ve attended the same conference
last year as well): people from the WebKit project (from Qt and GTK+ ports
mostly — unfortunately meeting the Mac/Chromium guys in such events is a
little bit more complicated), the EFL project, and watched some lectures on
interesting subjects, such as domain-specific-languages&amp;LLVM, text input in
mobile devices (and how difficult it is), multi-path TCP (very interesting,
by the way!), and even saw the Rasterman talking about EFL to a large
audience. Unfortunately, I wasn’t able to meet people I’d like to meet (the
CMake guys, which I talked briefly while working on the WebKit-EFL build
system), due to overlapping schedules. Oh, well.</p>
<p>Devices with Tizen were also there if you knew where to look and I was able
to play around with them. Despite it still being a little bit rough in the
edges (pun intended), I was very impressed by the overall smoothness. Granted
that the hardware isn’t too shabby, but it was as snappy as an user interface
should be. Can’t wait to get my hands on a Tizen device I can call my own.</p>
<p>I’ve also had the opportunity to drink more Club-Mate in the Brussels
Hackerspace (in a new place since last year). Unfortunately my hackerspace
passport arrived in the mail a couple days after I left for Europe, so I
couldn’t get it properly stamped.</p>
<p>All in all, it was a great experience. I sure hope I’ll be able to attend
this conference next year. And last, but certainly not least, I’d like to
thank my employer, ProFUSION Embedded Systems, for sponsoring my trip.</p>
]]></description>
             <pubDate>Mon, 13 Feb 2012 00:00:00 -0800</pubDate>
        </item>
    
    </channel>
</rss>